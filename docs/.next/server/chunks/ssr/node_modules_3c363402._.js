module.exports = {

"[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-353BL4L5.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "populateCommonDb": (()=>populateCommonDb)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-3XYRH5AP.mjs [app-ssr] (ecmascript)");
;
// src/diagrams/common/populateCommonDb.ts
function populateCommonDb(ast, db) {
    if (ast.accDescr) {
        db.setAccDescription?.(ast.accDescr);
    }
    if (ast.accTitle) {
        db.setAccTitle?.(ast.accTitle);
    }
    if (ast.title) {
        db.setDiagramTitle?.(ast.title);
    }
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(populateCommonDb, "populateCommonDb");
;
}}),
"[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-AACKK3MU.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ImperativeState": (()=>ImperativeState)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-3XYRH5AP.mjs [app-ssr] (ecmascript)");
;
// src/utils/imperativeState.ts
var ImperativeState = class {
    /**
   * @param init - Function that creates the default state.
   */ constructor(init){
        this.init = init;
        this.records = this.init();
    }
    static{
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(this, "ImperativeState");
    }
    reset() {
        this.records = this.init();
    }
};
;
}}),
"[project]/node_modules/mermaid/dist/chunks/mermaid.core/architectureDiagram-NQ2NVSRB.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "diagram": (()=>diagram)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-QESNASVV.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$353BL4L5$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-353BL4L5.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$AACKK3MU$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-AACKK3MU.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$55PJQP7W$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-55PJQP7W.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$P3VETL53$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-P3VETL53.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/mermaid/dist/chunks/mermaid.core/chunk-3XYRH5AP.mjs [app-ssr] (ecmascript)");
// src/diagrams/architecture/architectureParser.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mermaid$2d$js$2f$parser$2f$dist$2f$mermaid$2d$parser$2e$core$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mermaid$2d$js$2f$parser$2f$dist$2f$mermaid$2d$parser$2e$core$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@mermaid-js/parser/dist/mermaid-parser.core.mjs [app-ssr] (ecmascript) <locals>");
// src/diagrams/architecture/architectureRenderer.ts
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cytoscape$2f$dist$2f$cytoscape$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cytoscape/dist/cytoscape.esm.mjs [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cytoscape$2d$fcose$2f$cytoscape$2d$fcose$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/cytoscape-fcose/cytoscape-fcose.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2f$src$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/d3/src/index.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__ = __turbopack_context__.i("[project]/node_modules/d3-selection/src/select.js [app-ssr] (ecmascript) <export default as select>");
;
;
;
;
;
;
;
// src/diagrams/architecture/architectureTypes.ts
var ArchitectureDirectionName = {
    L: "left",
    R: "right",
    T: "top",
    B: "bottom"
};
var ArchitectureDirectionArrow = {
    L: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((scale)=>`${scale},${scale / 2} 0,${scale} 0,0`, "L"),
    R: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((scale)=>`0,${scale / 2} ${scale},0 ${scale},${scale}`, "R"),
    T: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((scale)=>`0,0 ${scale},0 ${scale / 2},${scale}`, "T"),
    B: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((scale)=>`${scale / 2},0 ${scale},${scale} 0,${scale}`, "B")
};
var ArchitectureDirectionArrowShift = {
    L: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((orig, arrowSize)=>orig - arrowSize + 2, "L"),
    R: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((orig, _arrowSize)=>orig - 2, "R"),
    T: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((orig, arrowSize)=>orig - arrowSize + 2, "T"),
    B: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((orig, _arrowSize)=>orig - 2, "B")
};
var getOppositeArchitectureDirection = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(x) {
    if (isArchitectureDirectionX(x)) {
        return x === "L" ? "R" : "L";
    } else {
        return x === "T" ? "B" : "T";
    }
}, "getOppositeArchitectureDirection");
var isArchitectureDirection = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(x) {
    const temp = x;
    return temp === "L" || temp === "R" || temp === "T" || temp === "B";
}, "isArchitectureDirection");
var isArchitectureDirectionX = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(x) {
    const temp = x;
    return temp === "L" || temp === "R";
}, "isArchitectureDirectionX");
var isArchitectureDirectionY = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(x) {
    const temp = x;
    return temp === "T" || temp === "B";
}, "isArchitectureDirectionY");
var isArchitectureDirectionXY = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(a, b) {
    const aX_bY = isArchitectureDirectionX(a) && isArchitectureDirectionY(b);
    const aY_bX = isArchitectureDirectionY(a) && isArchitectureDirectionX(b);
    return aX_bY || aY_bX;
}, "isArchitectureDirectionXY");
var isArchitecturePairXY = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(pair) {
    const lhs = pair[0];
    const rhs = pair[1];
    const aX_bY = isArchitectureDirectionX(lhs) && isArchitectureDirectionY(rhs);
    const aY_bX = isArchitectureDirectionY(lhs) && isArchitectureDirectionX(rhs);
    return aX_bY || aY_bX;
}, "isArchitecturePairXY");
var isValidArchitectureDirectionPair = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(x) {
    return x !== "LL" && x !== "RR" && x !== "TT" && x !== "BB";
}, "isValidArchitectureDirectionPair");
var getArchitectureDirectionPair = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(sourceDir, targetDir) {
    const pair = `${sourceDir}${targetDir}`;
    return isValidArchitectureDirectionPair(pair) ? pair : void 0;
}, "getArchitectureDirectionPair");
var shiftPositionByArchitectureDirectionPair = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function([x, y], pair) {
    const lhs = pair[0];
    const rhs = pair[1];
    if (isArchitectureDirectionX(lhs)) {
        if (isArchitectureDirectionY(rhs)) {
            return [
                x + (lhs === "L" ? -1 : 1),
                y + (rhs === "T" ? 1 : -1)
            ];
        } else {
            return [
                x + (lhs === "L" ? -1 : 1),
                y
            ];
        }
    } else {
        if (isArchitectureDirectionX(rhs)) {
            return [
                x + (rhs === "L" ? 1 : -1),
                y + (lhs === "T" ? 1 : -1)
            ];
        } else {
            return [
                x,
                y + (lhs === "T" ? 1 : -1)
            ];
        }
    }
}, "shiftPositionByArchitectureDirectionPair");
var getArchitectureDirectionXYFactors = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(pair) {
    if (pair === "LT" || pair === "TL") {
        return [
            1,
            1
        ];
    } else if (pair === "BL" || pair === "LB") {
        return [
            1,
            -1
        ];
    } else if (pair === "BR" || pair === "RB") {
        return [
            -1,
            -1
        ];
    } else {
        return [
            -1,
            1
        ];
    }
}, "getArchitectureDirectionXYFactors");
var getArchitectureDirectionAlignment = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(a, b) {
    if (isArchitectureDirectionXY(a, b)) {
        return "bend";
    } else if (isArchitectureDirectionX(a)) {
        return "horizontal";
    }
    return "vertical";
}, "getArchitectureDirectionAlignment");
var isArchitectureService = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(x) {
    const temp = x;
    return temp.type === "service";
}, "isArchitectureService");
var isArchitectureJunction = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(x) {
    const temp = x;
    return temp.type === "junction";
}, "isArchitectureJunction");
var edgeData = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((edge)=>{
    return edge.data();
}, "edgeData");
var nodeData = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((node)=>{
    return node.data();
}, "nodeData");
// src/diagrams/architecture/architectureDb.ts
var DEFAULT_ARCHITECTURE_CONFIG = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["defaultConfig_default"].architecture;
var state = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$AACKK3MU$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ImperativeState"](()=>({
        nodes: {},
        groups: {},
        edges: [],
        registeredIds: {},
        config: DEFAULT_ARCHITECTURE_CONFIG,
        dataStructures: void 0,
        elements: {}
    }));
var clear2 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(()=>{
    state.reset();
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["clear"])();
}, "clear");
var addService = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function({ id, icon, in: parent, title, iconText }) {
    if (state.records.registeredIds[id] !== void 0) {
        throw new Error(`The service id [${id}] is already in use by another ${state.records.registeredIds[id]}`);
    }
    if (parent !== void 0) {
        if (id === parent) {
            throw new Error(`The service [${id}] cannot be placed within itself`);
        }
        if (state.records.registeredIds[parent] === void 0) {
            throw new Error(`The service [${id}]'s parent does not exist. Please make sure the parent is created before this service`);
        }
        if (state.records.registeredIds[parent] === "node") {
            throw new Error(`The service [${id}]'s parent is not a group`);
        }
    }
    state.records.registeredIds[id] = "node";
    state.records.nodes[id] = {
        id,
        type: "service",
        icon,
        iconText,
        title,
        edges: [],
        in: parent
    };
}, "addService");
var getServices = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(()=>Object.values(state.records.nodes).filter(isArchitectureService), "getServices");
var addJunction = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function({ id, in: parent }) {
    state.records.registeredIds[id] = "node";
    state.records.nodes[id] = {
        id,
        type: "junction",
        edges: [],
        in: parent
    };
}, "addJunction");
var getJunctions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(()=>Object.values(state.records.nodes).filter(isArchitectureJunction), "getJunctions");
var getNodes = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(()=>Object.values(state.records.nodes), "getNodes");
var getNode = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((id)=>state.records.nodes[id], "getNode");
var addGroup = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function({ id, icon, in: parent, title }) {
    if (state.records.registeredIds[id] !== void 0) {
        throw new Error(`The group id [${id}] is already in use by another ${state.records.registeredIds[id]}`);
    }
    if (parent !== void 0) {
        if (id === parent) {
            throw new Error(`The group [${id}] cannot be placed within itself`);
        }
        if (state.records.registeredIds[parent] === void 0) {
            throw new Error(`The group [${id}]'s parent does not exist. Please make sure the parent is created before this group`);
        }
        if (state.records.registeredIds[parent] === "node") {
            throw new Error(`The group [${id}]'s parent is not a group`);
        }
    }
    state.records.registeredIds[id] = "group";
    state.records.groups[id] = {
        id,
        icon,
        title,
        in: parent
    };
}, "addGroup");
var getGroups = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(()=>{
    return Object.values(state.records.groups);
}, "getGroups");
var addEdge = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function({ lhsId, rhsId, lhsDir, rhsDir, lhsInto, rhsInto, lhsGroup, rhsGroup, title }) {
    if (!isArchitectureDirection(lhsDir)) {
        throw new Error(`Invalid direction given for left hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${lhsDir}`);
    }
    if (!isArchitectureDirection(rhsDir)) {
        throw new Error(`Invalid direction given for right hand side of edge ${lhsId}--${rhsId}. Expected (L,R,T,B) got ${rhsDir}`);
    }
    if (state.records.nodes[lhsId] === void 0 && state.records.groups[lhsId] === void 0) {
        throw new Error(`The left-hand id [${lhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`);
    }
    if (state.records.nodes[rhsId] === void 0 && state.records.groups[lhsId] === void 0) {
        throw new Error(`The right-hand id [${rhsId}] does not yet exist. Please create the service/group before declaring an edge to it.`);
    }
    const lhsGroupId = state.records.nodes[lhsId].in;
    const rhsGroupId = state.records.nodes[rhsId].in;
    if (lhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {
        throw new Error(`The left-hand id [${lhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`);
    }
    if (rhsGroup && lhsGroupId && rhsGroupId && lhsGroupId == rhsGroupId) {
        throw new Error(`The right-hand id [${rhsId}] is modified to traverse the group boundary, but the edge does not pass through two groups.`);
    }
    const edge = {
        lhsId,
        lhsDir,
        lhsInto,
        lhsGroup,
        rhsId,
        rhsDir,
        rhsInto,
        rhsGroup,
        title
    };
    state.records.edges.push(edge);
    if (state.records.nodes[lhsId] && state.records.nodes[rhsId]) {
        state.records.nodes[lhsId].edges.push(state.records.edges[state.records.edges.length - 1]);
        state.records.nodes[rhsId].edges.push(state.records.edges[state.records.edges.length - 1]);
    }
}, "addEdge");
var getEdges = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(()=>state.records.edges, "getEdges");
var getDataStructures = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(()=>{
    if (state.records.dataStructures === void 0) {
        const groupAlignments = {};
        const adjList = Object.entries(state.records.nodes).reduce((prevOuter, [id, service])=>{
            prevOuter[id] = service.edges.reduce((prevInner, edge)=>{
                const lhsGroupId = getNode(edge.lhsId)?.in;
                const rhsGroupId = getNode(edge.rhsId)?.in;
                if (lhsGroupId && rhsGroupId && lhsGroupId !== rhsGroupId) {
                    const alignment = getArchitectureDirectionAlignment(edge.lhsDir, edge.rhsDir);
                    if (alignment !== "bend") {
                        groupAlignments[lhsGroupId] ??= {};
                        groupAlignments[lhsGroupId][rhsGroupId] = alignment;
                        groupAlignments[rhsGroupId] ??= {};
                        groupAlignments[rhsGroupId][lhsGroupId] = alignment;
                    }
                }
                if (edge.lhsId === id) {
                    const pair = getArchitectureDirectionPair(edge.lhsDir, edge.rhsDir);
                    if (pair) {
                        prevInner[pair] = edge.rhsId;
                    }
                } else {
                    const pair = getArchitectureDirectionPair(edge.rhsDir, edge.lhsDir);
                    if (pair) {
                        prevInner[pair] = edge.lhsId;
                    }
                }
                return prevInner;
            }, {});
            return prevOuter;
        }, {});
        const firstId = Object.keys(adjList)[0];
        const visited = {
            [firstId]: 1
        };
        const notVisited = Object.keys(adjList).reduce((prev, id)=>id === firstId ? prev : {
                ...prev,
                [id]: 1
            }, {});
        const BFS = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((startingId)=>{
            const spatialMap = {
                [startingId]: [
                    0,
                    0
                ]
            };
            const queue = [
                startingId
            ];
            while(queue.length > 0){
                const id = queue.shift();
                if (id) {
                    visited[id] = 1;
                    delete notVisited[id];
                    const adj = adjList[id];
                    const [posX, posY] = spatialMap[id];
                    Object.entries(adj).forEach(([dir, rhsId])=>{
                        if (!visited[rhsId]) {
                            spatialMap[rhsId] = shiftPositionByArchitectureDirectionPair([
                                posX,
                                posY
                            ], dir);
                            queue.push(rhsId);
                        }
                    });
                }
            }
            return spatialMap;
        }, "BFS");
        const spatialMaps = [
            BFS(firstId)
        ];
        while(Object.keys(notVisited).length > 0){
            spatialMaps.push(BFS(Object.keys(notVisited)[0]));
        }
        state.records.dataStructures = {
            adjList,
            spatialMaps,
            groupAlignments
        };
    }
    return state.records.dataStructures;
}, "getDataStructures");
var setElementForId = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((id, element)=>{
    state.records.elements[id] = element;
}, "setElementForId");
var getElementById = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((id)=>state.records.elements[id], "getElementById");
var getConfig3 = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(()=>{
    const config = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$55PJQP7W$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cleanAndMerge"])({
        ...DEFAULT_ARCHITECTURE_CONFIG,
        ...(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getConfig"])().architecture
    });
    return config;
}, "getConfig");
var db = {
    clear: clear2,
    setDiagramTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setDiagramTitle"],
    getDiagramTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getDiagramTitle"],
    setAccTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setAccTitle"],
    getAccTitle: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAccTitle"],
    setAccDescription: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setAccDescription"],
    getAccDescription: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getAccDescription"],
    getConfig: getConfig3,
    addService,
    getServices,
    addJunction,
    getJunctions,
    getNodes,
    getNode,
    addGroup,
    getGroups,
    addEdge,
    getEdges,
    setElementForId,
    getElementById,
    getDataStructures
};
function getConfigField(field) {
    return getConfig3()[field];
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(getConfigField, "getConfigField");
// src/diagrams/architecture/architectureParser.ts
var populateDb = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((ast, db2)=>{
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$353BL4L5$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["populateCommonDb"])(ast, db2);
    ast.groups.map(db2.addGroup);
    ast.services.map((service)=>db2.addService({
            ...service,
            type: "service"
        }));
    ast.junctions.map((service)=>db2.addJunction({
            ...service,
            type: "junction"
        }));
    ast.edges.map(db2.addEdge);
}, "populateDb");
var parser = {
    parse: /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(async (input)=>{
        const ast = await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$mermaid$2d$js$2f$parser$2f$dist$2f$mermaid$2d$parser$2e$core$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__["parse"])("architecture", input);
        __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log"].debug(ast);
        populateDb(ast, db);
    }, "parse")
};
// src/diagrams/architecture/architectureStyles.ts
var getStyles = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((options)=>`
  .edge {
    stroke-width: ${options.archEdgeWidth};
    stroke: ${options.archEdgeColor};
    fill: none;
  }

  .arrow {
    fill: ${options.archEdgeArrowColor};
  }

  .node-bkg {
    fill: none;
    stroke: ${options.archGroupBorderColor};
    stroke-width: ${options.archGroupBorderWidth};
    stroke-dasharray: 8;
  }
  .node-icon-text {
    display: flex; 
    align-items: center;
  }
  
  .node-icon-text > div {
    color: #fff;
    margin: 1px;
    height: fit-content;
    text-align: center;
    overflow: hidden;
    display: -webkit-box;
    -webkit-box-orient: vertical;
  }
`, "getStyles");
var architectureStyles_default = getStyles;
;
;
;
// src/diagrams/architecture/architectureIcons.ts
var wrapIcon = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((icon)=>{
    return `<g><rect width="80" height="80" style="fill: #087ebf; stroke-width: 0px;"/>${icon}</g>`;
}, "wrapIcon");
var architectureIcons = {
    prefix: "mermaid-architecture",
    height: 80,
    width: 80,
    icons: {
        database: {
            body: wrapIcon('<path id="b" data-name="4" d="m20,57.86c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="c" data-name="3" d="m20,45.95c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path id="d" data-name="2" d="m20,34.05c0,3.94,8.95,7.14,20,7.14s20-3.2,20-7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse id="e" data-name="1" cx="40" cy="22.14" rx="20" ry="7.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="20" y1="57.86" x2="20" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="60" y1="57.86" x2="60" y2="22.14" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>')
        },
        server: {
            body: wrapIcon('<rect x="17.5" y="17.5" width="45" height="45" rx="2" ry="2" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="32.5" x2="62.5" y2="32.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="47.5" x2="62.5" y2="47.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><g><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,25c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,40c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: #fff; stroke-width: 0px;"/><path d="m56.25,55c0,.27-.45.5-1,.5h-10.5c-.55,0-1-.23-1-.5s.45-.5,1-.5h10.5c.55,0,1,.23,1,.5Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="25" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="40" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g><g><circle cx="32.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="27.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/><circle cx="22.5" cy="55" r=".75" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10;"/></g>')
        },
        disk: {
            body: wrapIcon('<rect x="20" y="15" width="40" height="50" rx="1" ry="1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="19.17" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="24" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="56" cy="60.83" rx=".8" ry=".83" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="14" ry="14.58" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><ellipse cx="40" cy="33.75" rx="4" ry="4.17" style="fill: #fff; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m37.51,42.52l-4.83,13.22c-.26.71-1.1,1.02-1.76.64l-4.18-2.42c-.66-.38-.81-1.26-.33-1.84l9.01-10.8c.88-1.05,2.56-.08,2.09,1.2Z" style="fill: #fff; stroke-width: 0px;"/>')
        },
        internet: {
            body: wrapIcon('<circle cx="40" cy="40" r="22.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="40" y1="17.5" x2="40" y2="62.5" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="17.5" y1="40" x2="62.5" y2="40" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m39.99,17.51c-15.28,11.1-15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><path d="m40.01,17.51c15.28,11.1,15.28,33.88,0,44.98" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="30.1" x2="60.25" y2="30.1" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/><line x1="19.75" y1="49.9" x2="60.25" y2="49.9" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>')
        },
        cloud: {
            body: wrapIcon('<path d="m65,47.5c0,2.76-2.24,5-5,5H20c-2.76,0-5-2.24-5-5,0-1.87,1.03-3.51,2.56-4.36-.04-.21-.06-.42-.06-.64,0-2.6,2.48-4.74,5.65-4.97,1.65-4.51,6.34-7.76,11.85-7.76.86,0,1.69.08,2.5.23,2.09-1.57,4.69-2.5,7.5-2.5,6.1,0,11.19,4.38,12.28,10.17,2.14.56,3.72,2.51,3.72,4.83,0,.03,0,.07-.01.1,2.29.46,4.01,2.48,4.01,4.9Z" style="fill: none; stroke: #fff; stroke-miterlimit: 10; stroke-width: 2px;"/>')
        },
        unknown: __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["unknownIcon"],
        blank: {
            body: wrapIcon("")
        }
    }
};
// src/diagrams/architecture/svgDraw.ts
var drawEdges = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(async function(edgesEl, cy) {
    const padding = getConfigField("padding");
    const iconSize = getConfigField("iconSize");
    const halfIconSize = iconSize / 2;
    const arrowSize = iconSize / 6;
    const halfArrowSize = arrowSize / 2;
    await Promise.all(cy.edges().map(async (edge)=>{
        const { source, sourceDir, sourceArrow, sourceGroup, target, targetDir, targetArrow, targetGroup, label } = edgeData(edge);
        let { x: startX, y: startY } = edge[0].sourceEndpoint();
        const { x: midX, y: midY } = edge[0].midpoint();
        let { x: endX, y: endY } = edge[0].targetEndpoint();
        const groupEdgeShift = padding + 4;
        if (sourceGroup) {
            if (isArchitectureDirectionX(sourceDir)) {
                startX += sourceDir === "L" ? -groupEdgeShift : groupEdgeShift;
            } else {
                startY += sourceDir === "T" ? -groupEdgeShift : groupEdgeShift + 18;
            }
        }
        if (targetGroup) {
            if (isArchitectureDirectionX(targetDir)) {
                endX += targetDir === "L" ? -groupEdgeShift : groupEdgeShift;
            } else {
                endY += targetDir === "T" ? -groupEdgeShift : groupEdgeShift + 18;
            }
        }
        if (!sourceGroup && db.getNode(source)?.type === "junction") {
            if (isArchitectureDirectionX(sourceDir)) {
                startX += sourceDir === "L" ? halfIconSize : -halfIconSize;
            } else {
                startY += sourceDir === "T" ? halfIconSize : -halfIconSize;
            }
        }
        if (!targetGroup && db.getNode(target)?.type === "junction") {
            if (isArchitectureDirectionX(targetDir)) {
                endX += targetDir === "L" ? halfIconSize : -halfIconSize;
            } else {
                endY += targetDir === "T" ? halfIconSize : -halfIconSize;
            }
        }
        if (edge[0]._private.rscratch) {
            const g = edgesEl.insert("g");
            g.insert("path").attr("d", `M ${startX},${startY} L ${midX},${midY} L${endX},${endY} `).attr("class", "edge");
            if (sourceArrow) {
                const xShift = isArchitectureDirectionX(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startX, arrowSize) : startX - halfArrowSize;
                const yShift = isArchitectureDirectionY(sourceDir) ? ArchitectureDirectionArrowShift[sourceDir](startY, arrowSize) : startY - halfArrowSize;
                g.insert("polygon").attr("points", ArchitectureDirectionArrow[sourceDir](arrowSize)).attr("transform", `translate(${xShift},${yShift})`).attr("class", "arrow");
            }
            if (targetArrow) {
                const xShift = isArchitectureDirectionX(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endX, arrowSize) : endX - halfArrowSize;
                const yShift = isArchitectureDirectionY(targetDir) ? ArchitectureDirectionArrowShift[targetDir](endY, arrowSize) : endY - halfArrowSize;
                g.insert("polygon").attr("points", ArchitectureDirectionArrow[targetDir](arrowSize)).attr("transform", `translate(${xShift},${yShift})`).attr("class", "arrow");
            }
            if (label) {
                const axis = !isArchitectureDirectionXY(sourceDir, targetDir) ? isArchitectureDirectionX(sourceDir) ? "X" : "Y" : "XY";
                let width = 0;
                if (axis === "X") {
                    width = Math.abs(startX - endX);
                } else if (axis === "Y") {
                    width = Math.abs(startY - endY) / 1.5;
                } else {
                    width = Math.abs(startX - endX) / 2;
                }
                const textElem = g.append("g");
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createText"])(textElem, label, {
                    useHtmlLabels: false,
                    width,
                    classes: "architecture-service-label"
                }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getConfig2"])());
                textElem.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle");
                if (axis === "X") {
                    textElem.attr("transform", "translate(" + midX + ", " + midY + ")");
                } else if (axis === "Y") {
                    textElem.attr("transform", "translate(" + midX + ", " + midY + ") rotate(-90)");
                } else if (axis === "XY") {
                    const pair = getArchitectureDirectionPair(sourceDir, targetDir);
                    if (pair && isArchitecturePairXY(pair)) {
                        const bboxOrig = textElem.node().getBoundingClientRect();
                        const [x, y] = getArchitectureDirectionXYFactors(pair);
                        textElem.attr("dominant-baseline", "auto").attr("transform", `rotate(${-1 * x * y * 45})`);
                        const bboxNew = textElem.node().getBoundingClientRect();
                        textElem.attr("transform", `
                translate(${midX}, ${midY - bboxOrig.height / 2})
                translate(${x * bboxNew.width / 2}, ${y * bboxNew.height / 2})
                rotate(${-1 * x * y * 45}, 0, ${bboxOrig.height / 2})
              `);
                    }
                }
            }
        }
    }));
}, "drawEdges");
var drawGroups = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(async function(groupsEl, cy) {
    const padding = getConfigField("padding");
    const groupIconSize = padding * 0.75;
    const fontSize = getConfigField("fontSize");
    const iconSize = getConfigField("iconSize");
    const halfIconSize = iconSize / 2;
    await Promise.all(cy.nodes().map(async (node)=>{
        const data = nodeData(node);
        if (data.type === "group") {
            const { h, w, x1, y1 } = node.boundingBox();
            groupsEl.append("rect").attr("x", x1 + halfIconSize).attr("y", y1 + halfIconSize).attr("width", w).attr("height", h).attr("class", "node-bkg");
            const groupLabelContainer = groupsEl.append("g");
            let shiftedX1 = x1;
            let shiftedY1 = y1;
            if (data.icon) {
                const bkgElem = groupLabelContainer.append("g");
                bkgElem.html(`<g>${await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIconSVG"])(data.icon, {
                    height: groupIconSize,
                    width: groupIconSize,
                    fallbackPrefix: architectureIcons.prefix
                })}</g>`);
                bkgElem.attr("transform", "translate(" + (shiftedX1 + halfIconSize + 1) + ", " + (shiftedY1 + halfIconSize + 1) + ")");
                shiftedX1 += groupIconSize;
                shiftedY1 += fontSize / 2 - 1 - 2;
            }
            if (data.label) {
                const textElem = groupLabelContainer.append("g");
                await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createText"])(textElem, data.label, {
                    useHtmlLabels: false,
                    width: w,
                    classes: "architecture-service-label"
                }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getConfig2"])());
                textElem.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "start").attr("text-anchor", "start");
                textElem.attr("transform", "translate(" + (shiftedX1 + halfIconSize + 4) + ", " + (shiftedY1 + halfIconSize + 2) + ")");
            }
        }
    }));
}, "drawGroups");
var drawServices = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(async function(db2, elem, services) {
    for (const service of services){
        const serviceElem = elem.append("g");
        const iconSize = getConfigField("iconSize");
        if (service.title) {
            const textElem = serviceElem.append("g");
            await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createText"])(textElem, service.title, {
                useHtmlLabels: false,
                width: iconSize * 1.5,
                classes: "architecture-service-label"
            }, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getConfig2"])());
            textElem.attr("dy", "1em").attr("alignment-baseline", "middle").attr("dominant-baseline", "middle").attr("text-anchor", "middle");
            textElem.attr("transform", "translate(" + iconSize / 2 + ", " + iconSize + ")");
        }
        const bkgElem = serviceElem.append("g");
        if (service.icon) {
            bkgElem.html(`<g>${await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIconSVG"])(service.icon, {
                height: iconSize,
                width: iconSize,
                fallbackPrefix: architectureIcons.prefix
            })}</g>`);
        } else if (service.iconText) {
            bkgElem.html(`<g>${await (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getIconSVG"])("blank", {
                height: iconSize,
                width: iconSize,
                fallbackPrefix: architectureIcons.prefix
            })}</g>`);
            const textElemContainer = bkgElem.append("g");
            const fo = textElemContainer.append("foreignObject").attr("width", iconSize).attr("height", iconSize);
            const divElem = fo.append("div").attr("class", "node-icon-text").attr("style", `height: ${iconSize}px;`).append("div").html(service.iconText);
            const fontSize = parseInt(window.getComputedStyle(divElem.node(), null).getPropertyValue("font-size").replace(/\D/g, "")) ?? 16;
            divElem.attr("style", `-webkit-line-clamp: ${Math.floor((iconSize - 2) / fontSize)};`);
        } else {
            bkgElem.append("path").attr("class", "node-bkg").attr("id", "node-" + service.id).attr("d", `M0 ${iconSize} v${-iconSize} q0,-5 5,-5 h${iconSize} q5,0 5,5 v${iconSize} H0 Z`);
        }
        serviceElem.attr("class", "architecture-service");
        const { width, height } = serviceElem._groups[0][0].getBBox();
        service.width = width;
        service.height = height;
        db2.setElementForId(service.id, serviceElem);
    }
    return 0;
}, "drawServices");
var drawJunctions = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(function(db2, elem, junctions) {
    junctions.forEach((junction)=>{
        const junctionElem = elem.append("g");
        const iconSize = getConfigField("iconSize");
        const bkgElem = junctionElem.append("g");
        bkgElem.append("rect").attr("id", "node-" + junction.id).attr("fill-opacity", "0").attr("width", iconSize).attr("height", iconSize);
        junctionElem.attr("class", "architecture-junction");
        const { width, height } = junctionElem._groups[0][0].getBBox();
        junctionElem.width = width;
        junctionElem.height = height;
        db2.setElementForId(junction.id, junctionElem);
    });
}, "drawJunctions");
// src/diagrams/architecture/architectureRenderer.ts
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$QESNASVV$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["registerIconPacks"])([
    {
        name: architectureIcons.prefix,
        icons: architectureIcons
    }
]);
__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cytoscape$2f$dist$2f$cytoscape$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"].use(__TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cytoscape$2d$fcose$2f$cytoscape$2d$fcose$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"]);
function addServices(services, cy) {
    services.forEach((service)=>{
        cy.add({
            group: "nodes",
            data: {
                type: "service",
                id: service.id,
                icon: service.icon,
                label: service.title,
                parent: service.in,
                width: getConfigField("iconSize"),
                height: getConfigField("iconSize")
            },
            classes: "node-service"
        });
    });
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(addServices, "addServices");
function addJunctions(junctions, cy) {
    junctions.forEach((junction)=>{
        cy.add({
            group: "nodes",
            data: {
                type: "junction",
                id: junction.id,
                parent: junction.in,
                width: getConfigField("iconSize"),
                height: getConfigField("iconSize")
            },
            classes: "node-junction"
        });
    });
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(addJunctions, "addJunctions");
function positionNodes(db2, cy) {
    cy.nodes().map((node)=>{
        const data = nodeData(node);
        if (data.type === "group") {
            return;
        }
        data.x = node.position().x;
        data.y = node.position().y;
        const nodeElem = db2.getElementById(data.id);
        nodeElem.attr("transform", "translate(" + (data.x || 0) + "," + (data.y || 0) + ")");
    });
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(positionNodes, "positionNodes");
function addGroups(groups, cy) {
    groups.forEach((group)=>{
        cy.add({
            group: "nodes",
            data: {
                type: "group",
                id: group.id,
                icon: group.icon,
                label: group.title,
                parent: group.in
            },
            classes: "node-group"
        });
    });
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(addGroups, "addGroups");
function addEdges(edges, cy) {
    edges.forEach((parsedEdge)=>{
        const { lhsId, rhsId, lhsInto, lhsGroup, rhsInto, lhsDir, rhsDir, rhsGroup, title } = parsedEdge;
        const edgeType = isArchitectureDirectionXY(parsedEdge.lhsDir, parsedEdge.rhsDir) ? "segments" : "straight";
        const edge = {
            id: `${lhsId}-${rhsId}`,
            label: title,
            source: lhsId,
            sourceDir: lhsDir,
            sourceArrow: lhsInto,
            sourceGroup: lhsGroup,
            sourceEndpoint: lhsDir === "L" ? "0 50%" : lhsDir === "R" ? "100% 50%" : lhsDir === "T" ? "50% 0" : "50% 100%",
            target: rhsId,
            targetDir: rhsDir,
            targetArrow: rhsInto,
            targetGroup: rhsGroup,
            targetEndpoint: rhsDir === "L" ? "0 50%" : rhsDir === "R" ? "100% 50%" : rhsDir === "T" ? "50% 0" : "50% 100%"
        };
        cy.add({
            group: "edges",
            data: edge,
            classes: edgeType
        });
    });
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(addEdges, "addEdges");
function getAlignments(db2, spatialMaps, groupAlignments) {
    const flattenAlignments = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((alignmentObj, alignmentDir)=>{
        return Object.entries(alignmentObj).reduce((prev, [dir, alignments2])=>{
            let cnt = 0;
            const arr = Object.entries(alignments2);
            if (arr.length === 1) {
                prev[dir] = arr[0][1];
                return prev;
            }
            for(let i = 0; i < arr.length - 1; i++){
                for(let j = i + 1; j < arr.length; j++){
                    const [aGroupId, aNodeIds] = arr[i];
                    const [bGroupId, bNodeIds] = arr[j];
                    const alignment = groupAlignments[aGroupId]?.[bGroupId];
                    if (alignment === alignmentDir) {
                        prev[dir] ??= [];
                        prev[dir] = [
                            ...prev[dir],
                            ...aNodeIds,
                            ...bNodeIds
                        ];
                    } else if (aGroupId === "default" || bGroupId === "default") {
                        prev[dir] ??= [];
                        prev[dir] = [
                            ...prev[dir],
                            ...aNodeIds,
                            ...bNodeIds
                        ];
                    } else {
                        const keyA = `${dir}-${cnt++}`;
                        prev[keyA] = aNodeIds;
                        const keyB = `${dir}-${cnt++}`;
                        prev[keyB] = bNodeIds;
                    }
                }
            }
            return prev;
        }, {});
    }, "flattenAlignments");
    const alignments = spatialMaps.map((spatialMap)=>{
        const horizontalAlignments = {};
        const verticalAlignments = {};
        Object.entries(spatialMap).forEach(([id, [x, y]])=>{
            const nodeGroup = db2.getNode(id)?.in ?? "default";
            horizontalAlignments[y] ??= {};
            horizontalAlignments[y][nodeGroup] ??= [];
            horizontalAlignments[y][nodeGroup].push(id);
            verticalAlignments[x] ??= {};
            verticalAlignments[x][nodeGroup] ??= [];
            verticalAlignments[x][nodeGroup].push(id);
        });
        return {
            horiz: Object.values(flattenAlignments(horizontalAlignments, "horizontal")).filter((arr)=>arr.length > 1),
            vert: Object.values(flattenAlignments(verticalAlignments, "vertical")).filter((arr)=>arr.length > 1)
        };
    });
    const [horizontal, vertical] = alignments.reduce(([prevHoriz, prevVert], { horiz, vert })=>{
        return [
            [
                ...prevHoriz,
                ...horiz
            ],
            [
                ...prevVert,
                ...vert
            ]
        ];
    }, [
        [],
        []
    ]);
    return {
        horizontal,
        vertical
    };
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(getAlignments, "getAlignments");
function getRelativeConstraints(spatialMaps) {
    const relativeConstraints = [];
    const posToStr = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((pos)=>`${pos[0]},${pos[1]}`, "posToStr");
    const strToPos = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])((pos)=>pos.split(",").map((p)=>parseInt(p)), "strToPos");
    spatialMaps.forEach((spatialMap)=>{
        const invSpatialMap = Object.fromEntries(Object.entries(spatialMap).map(([id, pos])=>[
                posToStr(pos),
                id
            ]));
        const queue = [
            posToStr([
                0,
                0
            ])
        ];
        const visited = {};
        const directions = {
            L: [
                -1,
                0
            ],
            R: [
                1,
                0
            ],
            T: [
                0,
                1
            ],
            B: [
                0,
                -1
            ]
        };
        while(queue.length > 0){
            const curr = queue.shift();
            if (curr) {
                visited[curr] = 1;
                const currId = invSpatialMap[curr];
                if (currId) {
                    const currPos = strToPos(curr);
                    Object.entries(directions).forEach(([dir, shift])=>{
                        const newPos = posToStr([
                            currPos[0] + shift[0],
                            currPos[1] + shift[1]
                        ]);
                        const newId = invSpatialMap[newPos];
                        if (newId && !visited[newPos]) {
                            queue.push(newPos);
                            relativeConstraints.push({
                                [ArchitectureDirectionName[dir]]: newId,
                                [ArchitectureDirectionName[getOppositeArchitectureDirection(dir)]]: currId,
                                gap: 1.5 * getConfigField("iconSize")
                            });
                        }
                    });
                }
            }
        }
    });
    return relativeConstraints;
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(getRelativeConstraints, "getRelativeConstraints");
function layoutArchitecture(services, junctions, groups, edges, db2, { spatialMaps, groupAlignments }) {
    return new Promise((resolve)=>{
        const renderEl = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$d3$2d$selection$2f$src$2f$select$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__select$3e$__["select"])("body").append("div").attr("id", "cy").attr("style", "display:none");
        const cy = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$cytoscape$2f$dist$2f$cytoscape$2e$esm$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])({
            container: document.getElementById("cy"),
            style: [
                {
                    selector: "edge",
                    style: {
                        "curve-style": "straight",
                        label: "data(label)",
                        "source-endpoint": "data(sourceEndpoint)",
                        "target-endpoint": "data(targetEndpoint)"
                    }
                },
                {
                    selector: "edge.segments",
                    style: {
                        "curve-style": "segments",
                        "segment-weights": "0",
                        "segment-distances": [
                            0.5
                        ],
                        // @ts-ignore Incorrect library types
                        "edge-distances": "endpoints",
                        "source-endpoint": "data(sourceEndpoint)",
                        "target-endpoint": "data(targetEndpoint)"
                    }
                },
                {
                    selector: "node",
                    style: {
                        // @ts-ignore Incorrect library types
                        "compound-sizing-wrt-labels": "include"
                    }
                },
                {
                    selector: "node[label]",
                    style: {
                        "text-valign": "bottom",
                        "text-halign": "center",
                        "font-size": `${getConfigField("fontSize")}px`
                    }
                },
                {
                    selector: ".node-service",
                    style: {
                        label: "data(label)",
                        width: "data(width)",
                        height: "data(height)"
                    }
                },
                {
                    selector: ".node-junction",
                    style: {
                        width: "data(width)",
                        height: "data(height)"
                    }
                },
                {
                    selector: ".node-group",
                    style: {
                        // @ts-ignore Incorrect library types
                        padding: `${getConfigField("padding")}px`
                    }
                }
            ]
        });
        renderEl.remove();
        addGroups(groups, cy);
        addServices(services, cy);
        addJunctions(junctions, cy);
        addEdges(edges, cy);
        const alignmentConstraint = getAlignments(db2, spatialMaps, groupAlignments);
        const relativePlacementConstraint = getRelativeConstraints(spatialMaps);
        const layout = cy.layout({
            name: "fcose",
            quality: "proof",
            styleEnabled: false,
            animate: false,
            nodeDimensionsIncludeLabels: false,
            // Adjust the edge parameters if it passes through the border of a group
            // Hacky fix for: https://github.com/iVis-at-Bilkent/cytoscape.js-fcose/issues/67
            idealEdgeLength (edge) {
                const [nodeA, nodeB] = edge.connectedNodes();
                const { parent: parentA } = nodeData(nodeA);
                const { parent: parentB } = nodeData(nodeB);
                const elasticity = parentA === parentB ? 1.5 * getConfigField("iconSize") : 0.5 * getConfigField("iconSize");
                return elasticity;
            },
            edgeElasticity (edge) {
                const [nodeA, nodeB] = edge.connectedNodes();
                const { parent: parentA } = nodeData(nodeA);
                const { parent: parentB } = nodeData(nodeB);
                const elasticity = parentA === parentB ? 0.45 : 1e-3;
                return elasticity;
            },
            alignmentConstraint,
            relativePlacementConstraint
        });
        layout.one("layoutstop", ()=>{
            function getSegmentWeights(source, target, pointX, pointY) {
                let W, D;
                const { x: sX, y: sY } = source;
                const { x: tX, y: tY } = target;
                D = (pointY - sY + (sX - pointX) * (sY - tY) / (sX - tX)) / Math.sqrt(1 + Math.pow((sY - tY) / (sX - tX), 2));
                W = Math.sqrt(Math.pow(pointY - sY, 2) + Math.pow(pointX - sX, 2) - Math.pow(D, 2));
                const distAB = Math.sqrt(Math.pow(tX - sX, 2) + Math.pow(tY - sY, 2));
                W = W / distAB;
                let delta1 = (tX - sX) * (pointY - sY) - (tY - sY) * (pointX - sX);
                switch(true){
                    case delta1 >= 0:
                        delta1 = 1;
                        break;
                    case delta1 < 0:
                        delta1 = -1;
                        break;
                }
                let delta2 = (tX - sX) * (pointX - sX) + (tY - sY) * (pointY - sY);
                switch(true){
                    case delta2 >= 0:
                        delta2 = 1;
                        break;
                    case delta2 < 0:
                        delta2 = -1;
                        break;
                }
                D = Math.abs(D) * delta1;
                W = W * delta2;
                return {
                    distances: D,
                    weights: W
                };
            }
            (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(getSegmentWeights, "getSegmentWeights");
            cy.startBatch();
            for (const edge of Object.values(cy.edges())){
                if (edge.data?.()) {
                    const { x: sX, y: sY } = edge.source().position();
                    const { x: tX, y: tY } = edge.target().position();
                    if (sX !== tX && sY !== tY) {
                        const sEP = edge.sourceEndpoint();
                        const tEP = edge.targetEndpoint();
                        const { sourceDir } = edgeData(edge);
                        const [pointX, pointY] = isArchitectureDirectionY(sourceDir) ? [
                            sEP.x,
                            tEP.y
                        ] : [
                            tEP.x,
                            sEP.y
                        ];
                        const { weights, distances } = getSegmentWeights(sEP, tEP, pointX, pointY);
                        edge.style("segment-distances", distances);
                        edge.style("segment-weights", weights);
                    }
                }
            }
            cy.endBatch();
            layout.run();
        });
        layout.run();
        cy.ready((e)=>{
            __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["log"].info("Ready", e);
            resolve(cy);
        });
    });
}
(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(layoutArchitecture, "layoutArchitecture");
var draw = /* @__PURE__ */ (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["__name"])(async (text, id, _version, diagObj)=>{
    const db2 = diagObj.db;
    const services = db2.getServices();
    const junctions = db2.getJunctions();
    const groups = db2.getGroups();
    const edges = db2.getEdges();
    const ds = db2.getDataStructures();
    const svg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$P3VETL53$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["selectSvgElement"])(id);
    const edgesElem = svg.append("g");
    edgesElem.attr("class", "architecture-edges");
    const servicesElem = svg.append("g");
    servicesElem.attr("class", "architecture-services");
    const groupElem = svg.append("g");
    groupElem.attr("class", "architecture-groups");
    await drawServices(db2, servicesElem, services);
    drawJunctions(db2, servicesElem, junctions);
    const cy = await layoutArchitecture(services, junctions, groups, edges, db2, ds);
    await drawEdges(edgesElem, cy);
    await drawGroups(groupElem, cy);
    positionNodes(db2, cy);
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$mermaid$2f$dist$2f$chunks$2f$mermaid$2e$core$2f$chunk$2d$3XYRH5AP$2e$mjs__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["setupGraphViewbox"])(void 0, svg, getConfigField("padding"), getConfigField("useMaxWidth"));
}, "draw");
var renderer = {
    draw
};
// src/diagrams/architecture/architectureDiagram.ts
var diagram = {
    parser,
    db,
    renderer,
    styles: architectureStyles_default
};
;
}}),
"[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "ASSERT_EXISTS": (()=>ASSERT_EXISTS),
    "ASSERT_NEVER_REACH_HERE": (()=>ASSERT_NEVER_REACH_HERE),
    "addFlag": (()=>addFlag),
    "cc": (()=>cc),
    "insertToSet": (()=>insertToSet),
    "isCharacter": (()=>isCharacter)
});
function cc(char) {
    return char.charCodeAt(0);
}
function insertToSet(item, set) {
    if (Array.isArray(item)) {
        item.forEach(function(subItem) {
            set.push(subItem);
        });
    } else {
        set.push(item);
    }
}
function addFlag(flagObj, flagKey) {
    if (flagObj[flagKey] === true) {
        throw "duplicate flag " + flagKey;
    }
    const x = flagObj[flagKey];
    flagObj[flagKey] = true;
}
function ASSERT_EXISTS(obj) {
    // istanbul ignore next
    if (obj === undefined) {
        throw Error("Internal Error - Should never get here!");
    }
    return true;
}
function ASSERT_NEVER_REACH_HERE() {
    throw Error("Internal Error - Should never get here!");
}
function isCharacter(obj) {
    return obj["type"] === "Character";
} //# sourceMappingURL=utils.js.map
}}),
"[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "digitsCharCodes": (()=>digitsCharCodes),
    "whitespaceCodes": (()=>whitespaceCodes),
    "wordCharCodes": (()=>wordCharCodes)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js [app-ssr] (ecmascript)");
;
const digitsCharCodes = [];
for(let i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("0"); i <= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("9"); i++){
    digitsCharCodes.push(i);
}
const wordCharCodes = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("_")
].concat(digitsCharCodes);
for(let i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("a"); i <= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("z"); i++){
    wordCharCodes.push(i);
}
for(let i = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("A"); i <= (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("Z"); i++){
    wordCharCodes.push(i);
}
const whitespaceCodes = [
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])(" "),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\f"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\n"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\r"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\t"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\v"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\t"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u00a0"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u1680"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2000"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2001"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2002"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2003"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2004"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2005"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2006"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2007"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2008"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2009"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u200a"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2028"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2029"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u202f"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u205f"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u3000"),
    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\ufeff")
]; //# sourceMappingURL=character-classes.js.map
}}),
"[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "RegExpParser": (()=>RegExpParser)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/utils.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$character$2d$classes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/character-classes.js [app-ssr] (ecmascript)");
;
;
// consts and utilities
const hexDigitPattern = /[0-9a-fA-F]/;
const decimalPattern = /[0-9]/;
const decimalPatternNoZero = /[1-9]/;
class RegExpParser {
    constructor(){
        this.idx = 0;
        this.input = "";
        this.groupIdx = 0;
    }
    saveState() {
        return {
            idx: this.idx,
            input: this.input,
            groupIdx: this.groupIdx
        };
    }
    restoreState(newState) {
        this.idx = newState.idx;
        this.input = newState.input;
        this.groupIdx = newState.groupIdx;
    }
    pattern(input) {
        // parser state
        this.idx = 0;
        this.input = input;
        this.groupIdx = 0;
        this.consumeChar("/");
        const value = this.disjunction();
        this.consumeChar("/");
        const flags = {
            type: "Flags",
            loc: {
                begin: this.idx,
                end: input.length
            },
            global: false,
            ignoreCase: false,
            multiLine: false,
            unicode: false,
            sticky: false
        };
        while(this.isRegExpFlag()){
            switch(this.popChar()){
                case "g":
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addFlag"])(flags, "global");
                    break;
                case "i":
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addFlag"])(flags, "ignoreCase");
                    break;
                case "m":
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addFlag"])(flags, "multiLine");
                    break;
                case "u":
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addFlag"])(flags, "unicode");
                    break;
                case "y":
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["addFlag"])(flags, "sticky");
                    break;
            }
        }
        if (this.idx !== this.input.length) {
            throw Error("Redundant input: " + this.input.substring(this.idx));
        }
        return {
            type: "Pattern",
            flags: flags,
            value: value,
            loc: this.loc(0)
        };
    }
    disjunction() {
        const alts = [];
        const begin = this.idx;
        alts.push(this.alternative());
        while(this.peekChar() === "|"){
            this.consumeChar("|");
            alts.push(this.alternative());
        }
        return {
            type: "Disjunction",
            value: alts,
            loc: this.loc(begin)
        };
    }
    alternative() {
        const terms = [];
        const begin = this.idx;
        while(this.isTerm()){
            terms.push(this.term());
        }
        return {
            type: "Alternative",
            value: terms,
            loc: this.loc(begin)
        };
    }
    term() {
        if (this.isAssertion()) {
            return this.assertion();
        } else {
            return this.atom();
        }
    }
    assertion() {
        const begin = this.idx;
        switch(this.popChar()){
            case "^":
                return {
                    type: "StartAnchor",
                    loc: this.loc(begin)
                };
            case "$":
                return {
                    type: "EndAnchor",
                    loc: this.loc(begin)
                };
            // '\b' or '\B'
            case "\\":
                switch(this.popChar()){
                    case "b":
                        return {
                            type: "WordBoundary",
                            loc: this.loc(begin)
                        };
                    case "B":
                        return {
                            type: "NonWordBoundary",
                            loc: this.loc(begin)
                        };
                }
                // istanbul ignore next
                throw Error("Invalid Assertion Escape");
            // '(?=' or '(?!'
            case "(":
                this.consumeChar("?");
                let type;
                switch(this.popChar()){
                    case "=":
                        type = "Lookahead";
                        break;
                    case "!":
                        type = "NegativeLookahead";
                        break;
                }
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_EXISTS"])(type);
                const disjunction = this.disjunction();
                this.consumeChar(")");
                return {
                    type: type,
                    value: disjunction,
                    loc: this.loc(begin)
                };
        }
        // istanbul ignore next
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_NEVER_REACH_HERE"])();
    }
    quantifier(isBacktracking = false) {
        let range = undefined;
        const begin = this.idx;
        switch(this.popChar()){
            case "*":
                range = {
                    atLeast: 0,
                    atMost: Infinity
                };
                break;
            case "+":
                range = {
                    atLeast: 1,
                    atMost: Infinity
                };
                break;
            case "?":
                range = {
                    atLeast: 0,
                    atMost: 1
                };
                break;
            case "{":
                const atLeast = this.integerIncludingZero();
                switch(this.popChar()){
                    case "}":
                        range = {
                            atLeast: atLeast,
                            atMost: atLeast
                        };
                        break;
                    case ",":
                        let atMost;
                        if (this.isDigit()) {
                            atMost = this.integerIncludingZero();
                            range = {
                                atLeast: atLeast,
                                atMost: atMost
                            };
                        } else {
                            range = {
                                atLeast: atLeast,
                                atMost: Infinity
                            };
                        }
                        this.consumeChar("}");
                        break;
                }
                // throwing exceptions from "ASSERT_EXISTS" during backtracking
                // causes severe performance degradations
                if (isBacktracking === true && range === undefined) {
                    return undefined;
                }
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_EXISTS"])(range);
                break;
        }
        // throwing exceptions from "ASSERT_EXISTS" during backtracking
        // causes severe performance degradations
        if (isBacktracking === true && range === undefined) {
            return undefined;
        }
        // istanbul ignore else
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_EXISTS"])(range)) {
            if (this.peekChar(0) === "?") {
                this.consumeChar("?");
                range.greedy = false;
            } else {
                range.greedy = true;
            }
            range.type = "Quantifier";
            range.loc = this.loc(begin);
            return range;
        }
    }
    atom() {
        let atom;
        const begin = this.idx;
        switch(this.peekChar()){
            case ".":
                atom = this.dotAll();
                break;
            case "\\":
                atom = this.atomEscape();
                break;
            case "[":
                atom = this.characterClass();
                break;
            case "(":
                atom = this.group();
                break;
        }
        if (atom === undefined && this.isPatternCharacter()) {
            atom = this.patternCharacter();
        }
        // istanbul ignore else
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_EXISTS"])(atom)) {
            atom.loc = this.loc(begin);
            if (this.isQuantifier()) {
                atom.quantifier = this.quantifier();
            }
            return atom;
        }
        // istanbul ignore next
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_NEVER_REACH_HERE"])();
    }
    dotAll() {
        this.consumeChar(".");
        return {
            type: "Set",
            complement: true,
            value: [
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\n"),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\r"),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2028"),
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u2029")
            ]
        };
    }
    atomEscape() {
        this.consumeChar("\\");
        switch(this.peekChar()){
            case "1":
            case "2":
            case "3":
            case "4":
            case "5":
            case "6":
            case "7":
            case "8":
            case "9":
                return this.decimalEscapeAtom();
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
                return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
                return this.controlEscapeAtom();
            case "c":
                return this.controlLetterEscapeAtom();
            case "0":
                return this.nulCharacterAtom();
            case "x":
                return this.hexEscapeSequenceAtom();
            case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
            default:
                return this.identityEscapeAtom();
        }
    }
    decimalEscapeAtom() {
        const value = this.positiveInteger();
        return {
            type: "GroupBackReference",
            value: value
        };
    }
    characterClassEscape() {
        let set;
        let complement = false;
        switch(this.popChar()){
            case "d":
                set = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$character$2d$classes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["digitsCharCodes"];
                break;
            case "D":
                set = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$character$2d$classes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["digitsCharCodes"];
                complement = true;
                break;
            case "s":
                set = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$character$2d$classes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["whitespaceCodes"];
                break;
            case "S":
                set = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$character$2d$classes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["whitespaceCodes"];
                complement = true;
                break;
            case "w":
                set = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$character$2d$classes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wordCharCodes"];
                break;
            case "W":
                set = __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$character$2d$classes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["wordCharCodes"];
                complement = true;
                break;
        }
        // istanbul ignore else
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_EXISTS"])(set)) {
            return {
                type: "Set",
                value: set,
                complement: complement
            };
        }
        // istanbul ignore next
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_NEVER_REACH_HERE"])();
    }
    controlEscapeAtom() {
        let escapeCode;
        switch(this.popChar()){
            case "f":
                escapeCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\f");
                break;
            case "n":
                escapeCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\n");
                break;
            case "r":
                escapeCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\r");
                break;
            case "t":
                escapeCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\t");
                break;
            case "v":
                escapeCode = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\v");
                break;
        }
        // istanbul ignore else
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_EXISTS"])(escapeCode)) {
            return {
                type: "Character",
                value: escapeCode
            };
        }
        // istanbul ignore next
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ASSERT_NEVER_REACH_HERE"])();
    }
    controlLetterEscapeAtom() {
        this.consumeChar("c");
        const letter = this.popChar();
        if (/[a-zA-Z]/.test(letter) === false) {
            throw Error("Invalid ");
        }
        const letterCode = letter.toUpperCase().charCodeAt(0) - 64;
        return {
            type: "Character",
            value: letterCode
        };
    }
    nulCharacterAtom() {
        // TODO implement '[lookahead  DecimalDigit]'
        // TODO: for the deprecated octal escape sequence
        this.consumeChar("0");
        return {
            type: "Character",
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\0")
        };
    }
    hexEscapeSequenceAtom() {
        this.consumeChar("x");
        return this.parseHexDigits(2);
    }
    regExpUnicodeEscapeSequenceAtom() {
        this.consumeChar("u");
        return this.parseHexDigits(4);
    }
    identityEscapeAtom() {
        // TODO: implement "SourceCharacter but not UnicodeIDContinue"
        // // http://unicode.org/reports/tr31/#Specific_Character_Adjustments
        const escapedChar = this.popChar();
        return {
            type: "Character",
            value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])(escapedChar)
        };
    }
    classPatternCharacterAtom() {
        switch(this.peekChar()){
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
            // istanbul ignore next
            case "\\":
            // istanbul ignore next
            case "]":
                throw Error("TBD");
            default:
                const nextChar = this.popChar();
                return {
                    type: "Character",
                    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])(nextChar)
                };
        }
    }
    characterClass() {
        const set = [];
        let complement = false;
        this.consumeChar("[");
        if (this.peekChar(0) === "^") {
            this.consumeChar("^");
            complement = true;
        }
        while(this.isClassAtom()){
            const from = this.classAtom();
            const isFromSingleChar = from.type === "Character";
            if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isCharacter"])(from) && this.isRangeDash()) {
                this.consumeChar("-");
                const to = this.classAtom();
                const isToSingleChar = to.type === "Character";
                // a range can only be used when both sides are single characters
                if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["isCharacter"])(to)) {
                    if (to.value < from.value) {
                        throw Error("Range out of order in character class");
                    }
                    set.push({
                        from: from.value,
                        to: to.value
                    });
                } else {
                    // literal dash
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insertToSet"])(from.value, set);
                    set.push((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("-"));
                    (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insertToSet"])(to.value, set);
                }
            } else {
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["insertToSet"])(from.value, set);
            }
        }
        this.consumeChar("]");
        return {
            type: "Set",
            complement: complement,
            value: set
        };
    }
    classAtom() {
        switch(this.peekChar()){
            // istanbul ignore next
            case "]":
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
                throw Error("TBD");
            case "\\":
                return this.classEscape();
            default:
                return this.classPatternCharacterAtom();
        }
    }
    classEscape() {
        this.consumeChar("\\");
        switch(this.peekChar()){
            // Matches a backspace.
            // (Not to be confused with \b word boundary outside characterClass)
            case "b":
                this.consumeChar("b");
                return {
                    type: "Character",
                    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])("\u0008")
                };
            case "d":
            case "D":
            case "s":
            case "S":
            case "w":
            case "W":
                return this.characterClassEscape();
            case "f":
            case "n":
            case "r":
            case "t":
            case "v":
                return this.controlEscapeAtom();
            case "c":
                return this.controlLetterEscapeAtom();
            case "0":
                return this.nulCharacterAtom();
            case "x":
                return this.hexEscapeSequenceAtom();
            case "u":
                return this.regExpUnicodeEscapeSequenceAtom();
            default:
                return this.identityEscapeAtom();
        }
    }
    group() {
        let capturing = true;
        this.consumeChar("(");
        switch(this.peekChar(0)){
            case "?":
                this.consumeChar("?");
                this.consumeChar(":");
                capturing = false;
                break;
            default:
                this.groupIdx++;
                break;
        }
        const value = this.disjunction();
        this.consumeChar(")");
        const groupAst = {
            type: "Group",
            capturing: capturing,
            value: value
        };
        if (capturing) {
            groupAst["idx"] = this.groupIdx;
        }
        return groupAst;
    }
    positiveInteger() {
        let number = this.popChar();
        // istanbul ignore next - can't ever get here due to previous lookahead checks
        // still implementing this error checking in case this ever changes.
        if (decimalPatternNoZero.test(number) === false) {
            throw Error("Expecting a positive integer");
        }
        while(decimalPattern.test(this.peekChar(0))){
            number += this.popChar();
        }
        return parseInt(number, 10);
    }
    integerIncludingZero() {
        let number = this.popChar();
        if (decimalPattern.test(number) === false) {
            throw Error("Expecting an integer");
        }
        while(decimalPattern.test(this.peekChar(0))){
            number += this.popChar();
        }
        return parseInt(number, 10);
    }
    patternCharacter() {
        const nextChar = this.popChar();
        switch(nextChar){
            // istanbul ignore next
            case "\n":
            // istanbul ignore next
            case "\r":
            // istanbul ignore next
            case "\u2028":
            // istanbul ignore next
            case "\u2029":
            // istanbul ignore next
            case "^":
            // istanbul ignore next
            case "$":
            // istanbul ignore next
            case "\\":
            // istanbul ignore next
            case ".":
            // istanbul ignore next
            case "*":
            // istanbul ignore next
            case "+":
            // istanbul ignore next
            case "?":
            // istanbul ignore next
            case "(":
            // istanbul ignore next
            case ")":
            // istanbul ignore next
            case "[":
            // istanbul ignore next
            case "|":
                // istanbul ignore next
                throw Error("TBD");
            default:
                return {
                    type: "Character",
                    value: (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$utils$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["cc"])(nextChar)
                };
        }
    }
    isRegExpFlag() {
        switch(this.peekChar(0)){
            case "g":
            case "i":
            case "m":
            case "u":
            case "y":
                return true;
            default:
                return false;
        }
    }
    isRangeDash() {
        return this.peekChar() === "-" && this.isClassAtom(1);
    }
    isDigit() {
        return decimalPattern.test(this.peekChar(0));
    }
    isClassAtom(howMuch = 0) {
        switch(this.peekChar(howMuch)){
            case "]":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
                return false;
            default:
                return true;
        }
    }
    isTerm() {
        return this.isAtom() || this.isAssertion();
    }
    isAtom() {
        if (this.isPatternCharacter()) {
            return true;
        }
        switch(this.peekChar(0)){
            case ".":
            case "\\":
            case "[":
            // TODO: isAtom must be called before isAssertion - disambiguate
            case "(":
                return true;
            default:
                return false;
        }
    }
    isAssertion() {
        switch(this.peekChar(0)){
            case "^":
            case "$":
                return true;
            // '\b' or '\B'
            case "\\":
                switch(this.peekChar(1)){
                    case "b":
                    case "B":
                        return true;
                    default:
                        return false;
                }
            // '(?=' or '(?!'
            case "(":
                return this.peekChar(1) === "?" && (this.peekChar(2) === "=" || this.peekChar(2) === "!");
            default:
                return false;
        }
    }
    isQuantifier() {
        const prevState = this.saveState();
        try {
            return this.quantifier(true) !== undefined;
        } catch (e) {
            return false;
        } finally{
            this.restoreState(prevState);
        }
    }
    isPatternCharacter() {
        switch(this.peekChar()){
            case "^":
            case "$":
            case "\\":
            case ".":
            case "*":
            case "+":
            case "?":
            case "(":
            case ")":
            case "[":
            case "|":
            case "/":
            case "\n":
            case "\r":
            case "\u2028":
            case "\u2029":
                return false;
            default:
                return true;
        }
    }
    parseHexDigits(howMany) {
        let hexString = "";
        for(let i = 0; i < howMany; i++){
            const hexChar = this.popChar();
            if (hexDigitPattern.test(hexChar) === false) {
                throw Error("Expecting a HexDecimal digits");
            }
            hexString += hexChar;
        }
        const charCode = parseInt(hexString, 16);
        return {
            type: "Character",
            value: charCode
        };
    }
    peekChar(howMuch = 0) {
        return this.input[this.idx + howMuch];
    }
    popChar() {
        const nextChar = this.peekChar(0);
        this.consumeChar(undefined);
        return nextChar;
    }
    consumeChar(char) {
        if (char !== undefined && this.input[this.idx] !== char) {
            throw Error("Expected: '" + char + "' but found: '" + this.input[this.idx] + "' at offset: " + this.idx);
        }
        if (this.idx >= this.input.length) {
            throw Error("Unexpected end of input");
        }
        this.idx++;
    }
    loc(begin) {
        return {
            begin: begin,
            end: this.idx
        };
    }
} //# sourceMappingURL=regexp-parser.js.map
}}),
"[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "BaseRegExpVisitor": (()=>BaseRegExpVisitor)
});
class BaseRegExpVisitor {
    visitChildren(node) {
        for(const key in node){
            const child = node[key];
            /* istanbul ignore else */ if (node.hasOwnProperty(key)) {
                if (child.type !== undefined) {
                    this.visit(child);
                } else if (Array.isArray(child)) {
                    child.forEach((subChild)=>{
                        this.visit(subChild);
                    }, this);
                }
            }
        }
    }
    visit(node) {
        switch(node.type){
            case "Pattern":
                this.visitPattern(node);
                break;
            case "Flags":
                this.visitFlags(node);
                break;
            case "Disjunction":
                this.visitDisjunction(node);
                break;
            case "Alternative":
                this.visitAlternative(node);
                break;
            case "StartAnchor":
                this.visitStartAnchor(node);
                break;
            case "EndAnchor":
                this.visitEndAnchor(node);
                break;
            case "WordBoundary":
                this.visitWordBoundary(node);
                break;
            case "NonWordBoundary":
                this.visitNonWordBoundary(node);
                break;
            case "Lookahead":
                this.visitLookahead(node);
                break;
            case "NegativeLookahead":
                this.visitNegativeLookahead(node);
                break;
            case "Character":
                this.visitCharacter(node);
                break;
            case "Set":
                this.visitSet(node);
                break;
            case "Group":
                this.visitGroup(node);
                break;
            case "GroupBackReference":
                this.visitGroupBackReference(node);
                break;
            case "Quantifier":
                this.visitQuantifier(node);
                break;
        }
        this.visitChildren(node);
    }
    visitPattern(node) {}
    visitFlags(node) {}
    visitDisjunction(node) {}
    visitAlternative(node) {}
    // Assertion
    visitStartAnchor(node) {}
    visitEndAnchor(node) {}
    visitWordBoundary(node) {}
    visitNonWordBoundary(node) {}
    visitLookahead(node) {}
    visitNegativeLookahead(node) {}
    // atoms
    visitCharacter(node) {}
    visitSet(node) {}
    visitGroup(node) {}
    visitGroupBackReference(node) {}
    visitQuantifier(node) {}
} //# sourceMappingURL=base-regexp-visitor.js.map
}}),
"[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/api.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$regexp$2d$parser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$base$2d$regexp$2d$visitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js [app-ssr] (ecmascript)"); //# sourceMappingURL=api.js.map
;
;
}}),
"[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/api.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$regexp$2d$parser$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/regexp-parser.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$base$2d$regexp$2d$visitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/base-regexp-visitor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$regexp$2d$to$2d$ast$2f$lib$2f$src$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/regexp-to-ast/lib/src/api.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@chevrotain/utils/lib/src/print.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "PRINT_ERROR": (()=>PRINT_ERROR),
    "PRINT_WARNING": (()=>PRINT_WARNING)
});
function PRINT_ERROR(msg) {
    /* istanbul ignore else - can't override global.console in node.js */ if (console && console.error) {
        console.error(`Error: ${msg}`);
    }
}
function PRINT_WARNING(msg) {
    /* istanbul ignore else - can't override global.console in node.js*/ if (console && console.warn) {
        // TODO: modify docs accordingly
        console.warn(`Warning: ${msg}`);
    }
} //# sourceMappingURL=print.js.map
}}),
"[project]/node_modules/@chevrotain/utils/lib/src/timer.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "timer": (()=>timer)
});
function timer(func) {
    const start = new Date().getTime();
    const val = func();
    const end = new Date().getTime();
    const total = end - start;
    return {
        time: total,
        value: val
    };
} //# sourceMappingURL=timer.js.map
}}),
"[project]/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
// based on: https://github.com/petkaantonov/bluebird/blob/b97c0d2d487e8c5076e8bd897e0dcd4622d31846/src/util.js#L201-L216
__turbopack_context__.s({
    "toFastProperties": (()=>toFastProperties)
});
function toFastProperties(toBecomeFast) {
    function FakeConstructor() {}
    // If our object is used as a constructor, it would receive
    FakeConstructor.prototype = toBecomeFast;
    const fakeInstance = new FakeConstructor();
    function fakeAccess() {
        return typeof fakeInstance.bar;
    }
    // help V8 understand this is a "real" prototype by actually using
    // the fake instance.
    fakeAccess();
    fakeAccess();
    // Always true condition to suppress the Firefox warning of unreachable
    // code after a return statement.
    if ("TURBOPACK compile-time truthy", 1) return toBecomeFast;
    "TURBOPACK unreachable";
} //# sourceMappingURL=to-fast-properties.js.map
}}),
"[project]/node_modules/@chevrotain/utils/lib/src/api.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$utils$2f$lib$2f$src$2f$print$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/utils/lib/src/print.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$utils$2f$lib$2f$src$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/utils/lib/src/timer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$utils$2f$lib$2f$src$2f$to$2d$fast$2d$properties$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js [app-ssr] (ecmascript)"); //# sourceMappingURL=api.js.map
;
;
;
}}),
"[project]/node_modules/@chevrotain/utils/lib/src/api.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$utils$2f$lib$2f$src$2f$print$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/utils/lib/src/print.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$utils$2f$lib$2f$src$2f$timer$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/utils/lib/src/timer.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$utils$2f$lib$2f$src$2f$to$2d$fast$2d$properties$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/utils/lib/src/to-fast-properties.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$utils$2f$lib$2f$src$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/utils/lib/src/api.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@chevrotain/gast/lib/src/model.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "AbstractProduction": (()=>AbstractProduction),
    "Alternation": (()=>Alternation),
    "Alternative": (()=>Alternative),
    "NonTerminal": (()=>NonTerminal),
    "Option": (()=>Option),
    "Repetition": (()=>Repetition),
    "RepetitionMandatory": (()=>RepetitionMandatory),
    "RepetitionMandatoryWithSeparator": (()=>RepetitionMandatoryWithSeparator),
    "RepetitionWithSeparator": (()=>RepetitionWithSeparator),
    "Rule": (()=>Rule),
    "Terminal": (()=>Terminal),
    "serializeGrammar": (()=>serializeGrammar),
    "serializeProduction": (()=>serializeProduction)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/assign.js [app-ssr] (ecmascript) <export default as assign>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$forEach$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__forEach$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/forEach.js [app-ssr] (ecmascript) <export default as forEach>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isRegExp$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isRegExp$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/isRegExp.js [app-ssr] (ecmascript) <export default as isRegExp>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isString$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isString$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/isString.js [app-ssr] (ecmascript) <export default as isString>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/map.js [app-ssr] (ecmascript) <export default as map>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/pickBy.js [app-ssr] (ecmascript) <export default as pickBy>");
;
// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?
function tokenLabel(tokType) {
    if (hasTokenLabel(tokType)) {
        return tokType.LABEL;
    } else {
        return tokType.name;
    }
}
// TODO: duplicated code to avoid extracting another sub-package -- how to avoid?
function hasTokenLabel(obj) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isString$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isString$3e$__["isString"])(obj.LABEL) && obj.LABEL !== "";
}
class AbstractProduction {
    get definition() {
        return this._definition;
    }
    set definition(value) {
        this._definition = value;
    }
    constructor(_definition){
        this._definition = _definition;
    }
    accept(visitor) {
        visitor.visit(this);
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$forEach$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__forEach$3e$__["forEach"])(this.definition, (prod)=>{
            prod.accept(visitor);
        });
    }
}
class NonTerminal extends AbstractProduction {
    constructor(options){
        super([]);
        this.idx = 1;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
    set definition(definition) {
    // immutable
    }
    get definition() {
        if (this.referencedRule !== undefined) {
            return this.referencedRule.definition;
        }
        return [];
    }
    accept(visitor) {
        visitor.visit(this);
    // don't visit children of a reference, we will get cyclic infinite loops if we do so
    }
}
class Rule extends AbstractProduction {
    constructor(options){
        super(options.definition);
        this.orgText = "";
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
}
class Alternative extends AbstractProduction {
    constructor(options){
        super(options.definition);
        this.ignoreAmbiguities = false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
}
class Option extends AbstractProduction {
    constructor(options){
        super(options.definition);
        this.idx = 1;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
}
class RepetitionMandatory extends AbstractProduction {
    constructor(options){
        super(options.definition);
        this.idx = 1;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
}
class RepetitionMandatoryWithSeparator extends AbstractProduction {
    constructor(options){
        super(options.definition);
        this.idx = 1;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
}
class Repetition extends AbstractProduction {
    constructor(options){
        super(options.definition);
        this.idx = 1;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
}
class RepetitionWithSeparator extends AbstractProduction {
    constructor(options){
        super(options.definition);
        this.idx = 1;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
}
class Alternation extends AbstractProduction {
    get definition() {
        return this._definition;
    }
    set definition(value) {
        this._definition = value;
    }
    constructor(options){
        super(options.definition);
        this.idx = 1;
        this.ignoreAmbiguities = false;
        this.hasPredicates = false;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
}
class Terminal {
    constructor(options){
        this.idx = 1;
        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])(this, (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$pickBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__pickBy$3e$__["pickBy"])(options, (v)=>v !== undefined));
    }
    accept(visitor) {
        visitor.visit(this);
    }
}
function serializeGrammar(topRules) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(topRules, serializeProduction);
}
function serializeProduction(node) {
    function convertDefinition(definition) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(definition, serializeProduction);
    }
    /* istanbul ignore else */ if (node instanceof NonTerminal) {
        const serializedNonTerminal = {
            type: "NonTerminal",
            name: node.nonTerminalName,
            idx: node.idx
        };
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isString$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isString$3e$__["isString"])(node.label)) {
            serializedNonTerminal.label = node.label;
        }
        return serializedNonTerminal;
    } else if (node instanceof Alternative) {
        return {
            type: "Alternative",
            definition: convertDefinition(node.definition)
        };
    } else if (node instanceof Option) {
        return {
            type: "Option",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    } else if (node instanceof RepetitionMandatory) {
        return {
            type: "RepetitionMandatory",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    } else if (node instanceof RepetitionMandatoryWithSeparator) {
        return {
            type: "RepetitionMandatoryWithSeparator",
            idx: node.idx,
            separator: serializeProduction(new Terminal({
                terminalType: node.separator
            })),
            definition: convertDefinition(node.definition)
        };
    } else if (node instanceof RepetitionWithSeparator) {
        return {
            type: "RepetitionWithSeparator",
            idx: node.idx,
            separator: serializeProduction(new Terminal({
                terminalType: node.separator
            })),
            definition: convertDefinition(node.definition)
        };
    } else if (node instanceof Repetition) {
        return {
            type: "Repetition",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    } else if (node instanceof Alternation) {
        return {
            type: "Alternation",
            idx: node.idx,
            definition: convertDefinition(node.definition)
        };
    } else if (node instanceof Terminal) {
        const serializedTerminal = {
            type: "Terminal",
            name: node.terminalType.name,
            label: tokenLabel(node.terminalType),
            idx: node.idx
        };
        if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isString$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isString$3e$__["isString"])(node.label)) {
            serializedTerminal.terminalLabel = node.label;
        }
        const pattern = node.terminalType.PATTERN;
        if (node.terminalType.PATTERN) {
            serializedTerminal.pattern = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isRegExp$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isRegExp$3e$__["isRegExp"])(pattern) ? pattern.source : pattern;
        }
        return serializedTerminal;
    } else if (node instanceof Rule) {
        return {
            type: "Rule",
            name: node.name,
            orgText: node.orgText,
            definition: convertDefinition(node.definition)
        };
    /* c8 ignore next 3 */ } else {
        throw Error("non exhaustive match");
    }
} //# sourceMappingURL=model.js.map
}}),
"[project]/node_modules/@chevrotain/gast/lib/src/visitor.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "GAstVisitor": (()=>GAstVisitor)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/model.js [app-ssr] (ecmascript)");
;
class GAstVisitor {
    visit(node) {
        const nodeAny = node;
        switch(nodeAny.constructor){
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NonTerminal"]:
                return this.visitNonTerminal(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternative"]:
                return this.visitAlternative(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"]:
                return this.visitOption(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatory"]:
                return this.visitRepetitionMandatory(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatoryWithSeparator"]:
                return this.visitRepetitionMandatoryWithSeparator(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionWithSeparator"]:
                return this.visitRepetitionWithSeparator(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Repetition"]:
                return this.visitRepetition(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternation"]:
                return this.visitAlternation(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Terminal"]:
                return this.visitTerminal(nodeAny);
            case __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rule"]:
                return this.visitRule(nodeAny);
            /* c8 ignore next 2 */ default:
                throw Error("non exhaustive match");
        }
    }
    /* c8 ignore next */ visitNonTerminal(node) {}
    /* c8 ignore next */ visitAlternative(node) {}
    /* c8 ignore next */ visitOption(node) {}
    /* c8 ignore next */ visitRepetition(node) {}
    /* c8 ignore next */ visitRepetitionMandatory(node) {}
    /* c8 ignore next 3 */ visitRepetitionMandatoryWithSeparator(node) {}
    /* c8 ignore next */ visitRepetitionWithSeparator(node) {}
    /* c8 ignore next */ visitAlternation(node) {}
    /* c8 ignore next */ visitTerminal(node) {}
    /* c8 ignore next */ visitRule(node) {}
} //# sourceMappingURL=visitor.js.map
}}),
"[project]/node_modules/@chevrotain/gast/lib/src/helpers.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "getProductionDslName": (()=>getProductionDslName),
    "isBranchingProd": (()=>isBranchingProd),
    "isOptionalProd": (()=>isOptionalProd),
    "isSequenceProd": (()=>isSequenceProd)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$every$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__every$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/every.js [app-ssr] (ecmascript) <export default as every>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$includes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__includes$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/includes.js [app-ssr] (ecmascript) <export default as includes>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$some$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__some$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/some.js [app-ssr] (ecmascript) <export default as some>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/model.js [app-ssr] (ecmascript)");
;
;
function isSequenceProd(prod) {
    return prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternative"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Repetition"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatory"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatoryWithSeparator"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionWithSeparator"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Terminal"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Rule"];
}
function isOptionalProd(prod, alreadyVisited = []) {
    const isDirectlyOptional = prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Repetition"] || prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionWithSeparator"];
    if (isDirectlyOptional) {
        return true;
    }
    // note that this can cause infinite loop if one optional empty TOP production has a cyclic dependency with another
    // empty optional top rule
    // may be indirectly optional ((A?B?C?) | (D?E?F?))
    if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternation"]) {
        // for OR its enough for just one of the alternatives to be optional
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$some$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__some$3e$__["some"])(prod.definition, (subProd)=>{
            return isOptionalProd(subProd, alreadyVisited);
        });
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NonTerminal"] && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$includes$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__includes$3e$__["includes"])(alreadyVisited, prod)) {
        // avoiding stack overflow due to infinite recursion
        return false;
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AbstractProduction"]) {
        if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NonTerminal"]) {
            alreadyVisited.push(prod);
        }
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$every$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__every$3e$__["every"])(prod.definition, (subProd)=>{
            return isOptionalProd(subProd, alreadyVisited);
        });
    } else {
        return false;
    }
}
function isBranchingProd(prod) {
    return prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternation"];
}
function getProductionDslName(prod) {
    /* istanbul ignore else */ if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NonTerminal"]) {
        return "SUBRULE";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"]) {
        return "OPTION";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternation"]) {
        return "OR";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatory"]) {
        return "AT_LEAST_ONE";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatoryWithSeparator"]) {
        return "AT_LEAST_ONE_SEP";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionWithSeparator"]) {
        return "MANY_SEP";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Repetition"]) {
        return "MANY";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Terminal"]) {
        return "CONSUME";
    /* c8 ignore next 3 */ } else {
        throw Error("non exhaustive match");
    }
} //# sourceMappingURL=helpers.js.map
}}),
"[project]/node_modules/@chevrotain/gast/lib/src/api.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$visitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/visitor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/helpers.js [app-ssr] (ecmascript)"); //# sourceMappingURL=api.js.map
;
;
;
}}),
"[project]/node_modules/@chevrotain/gast/lib/src/api.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$visitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/visitor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$helpers$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/helpers.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/api.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "buildModel": (()=>buildModel)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/api.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$visitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/visitor.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/assign.js [app-ssr] (ecmascript) <export default as assign>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__flatten$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/flatten.js [app-ssr] (ecmascript) <export default as flatten>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$groupBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__groupBy$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/groupBy.js [app-ssr] (ecmascript) <export default as groupBy>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/map.js [app-ssr] (ecmascript) <export default as map>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$some$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__some$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/some.js [app-ssr] (ecmascript) <export default as some>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__values$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/values.js [app-ssr] (ecmascript) <export default as values>");
;
;
function buildModel(productions) {
    const generator = new CstNodeDefinitionGenerator();
    const allRules = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$values$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__values$3e$__["values"])(productions);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(allRules, (rule)=>generator.visitRule(rule));
}
class CstNodeDefinitionGenerator extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$visitor$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["GAstVisitor"] {
    visitRule(node) {
        const rawElements = this.visitEach(node.definition);
        const grouped = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$groupBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__groupBy$3e$__["groupBy"])(rawElements, (el)=>el.propertyName);
        const properties = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(grouped, (group, propertyName)=>{
            const allNullable = !(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$some$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__some$3e$__["some"])(group, (el)=>!el.canBeNull);
            // In an alternation with a label a property name can have
            // multiple types.
            let propertyType = group[0].type;
            if (group.length > 1) {
                propertyType = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(group, (g)=>g.type);
            }
            return {
                name: propertyName,
                type: propertyType,
                optional: allNullable
            };
        });
        return {
            name: node.name,
            properties: properties
        };
    }
    visitAlternative(node) {
        return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
        });
    }
    visitOption(node) {
        return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
        });
    }
    visitRepetition(node) {
        return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
        });
    }
    visitRepetitionMandatory(node) {
        return this.visitEach(node.definition);
    }
    visitRepetitionMandatoryWithSeparator(node) {
        return this.visitEach(node.definition).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
        });
    }
    visitRepetitionWithSeparator(node) {
        return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
        }).concat({
            propertyName: node.separator.name,
            canBeNull: true,
            type: getType(node.separator)
        });
    }
    visitAlternation(node) {
        return this.visitEachAndOverrideWith(node.definition, {
            canBeNull: true
        });
    }
    visitTerminal(node) {
        return [
            {
                propertyName: node.label || node.terminalType.name,
                canBeNull: false,
                type: getType(node)
            }
        ];
    }
    visitNonTerminal(node) {
        return [
            {
                propertyName: node.label || node.nonTerminalName,
                canBeNull: false,
                type: getType(node)
            }
        ];
    }
    visitEachAndOverrideWith(definition, override) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(this.visitEach(definition), (definition)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$assign$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__assign$3e$__["assign"])({}, definition, override));
    }
    visitEach(definition) {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__flatten$3e$__["flatten"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(definition, (definition)=>this.visit(definition)));
    }
}
function getType(production) {
    if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NonTerminal"]) {
        return {
            kind: "rule",
            name: production.referencedRule.name
        };
    }
    return {
        kind: "token"
    };
} //# sourceMappingURL=model.js.map
}}),
"[project]/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "genDts": (()=>genDts)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__flatten$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/flatten.js [app-ssr] (ecmascript) <export default as flatten>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isArray$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/isArray.js [app-ssr] (ecmascript) <export default as isArray>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/map.js [app-ssr] (ecmascript) <export default as map>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$reduce$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__reduce$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/reduce.js [app-ssr] (ecmascript) <export default as reduce>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$uniq$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__uniq$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/uniq.js [app-ssr] (ecmascript) <export default as uniq>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$upperFirst$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/upperFirst.js [app-ssr] (ecmascript) <export default as upperFirst>");
;
function genDts(model, options) {
    let contentParts = [];
    contentParts = contentParts.concat(`import type { CstNode, ICstVisitor, IToken } from "chevrotain";`);
    contentParts = contentParts.concat((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__flatten$3e$__["flatten"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(model, (node)=>genCstNodeTypes(node))));
    if (options.includeVisitorInterface) {
        contentParts = contentParts.concat(genVisitor(options.visitorInterfaceName, model));
    }
    return contentParts.join("\n\n") + "\n";
}
function genCstNodeTypes(node) {
    const nodeCstInterface = genNodeInterface(node);
    const nodeChildrenInterface = genNodeChildrenType(node);
    return [
        nodeCstInterface,
        nodeChildrenInterface
    ];
}
function genNodeInterface(node) {
    const nodeInterfaceName = getNodeInterfaceName(node.name);
    const childrenTypeName = getNodeChildrenTypeName(node.name);
    return `export interface ${nodeInterfaceName} extends CstNode {
  name: "${node.name}";
  children: ${childrenTypeName};
}`;
}
function genNodeChildrenType(node) {
    const typeName = getNodeChildrenTypeName(node.name);
    return `export type ${typeName} = {
  ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(node.properties, (property)=>genChildProperty(property)).join("\n  ")}
};`;
}
function genChildProperty(prop) {
    const typeName = buildTypeString(prop.type);
    return `${prop.name}${prop.optional ? "?" : ""}: ${typeName}[];`;
}
function genVisitor(name, nodes) {
    return `export interface ${name}<IN, OUT> extends ICstVisitor<IN, OUT> {
  ${(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(nodes, (node)=>genVisitorFunction(node)).join("\n  ")}
}`;
}
function genVisitorFunction(node) {
    const childrenTypeName = getNodeChildrenTypeName(node.name);
    return `${node.name}(children: ${childrenTypeName}, param?: IN): OUT;`;
}
function buildTypeString(type) {
    if ((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isArray$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__isArray$3e$__["isArray"])(type)) {
        const typeNames = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$uniq$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__uniq$3e$__["uniq"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__map$3e$__["map"])(type, (t)=>getTypeString(t)));
        const typeString = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$reduce$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__reduce$3e$__["reduce"])(typeNames, (sum, t)=>sum + " | " + t);
        return "(" + typeString + ")";
    } else {
        return getTypeString(type);
    }
}
function getTypeString(type) {
    if (type.kind === "token") {
        return "IToken";
    }
    return getNodeInterfaceName(type.name);
}
function getNodeInterfaceName(ruleName) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$upperFirst$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(ruleName) + "CstNode";
}
function getNodeChildrenTypeName(ruleName) {
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$upperFirst$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$export__default__as__upperFirst$3e$__["upperFirst"])(ruleName) + "CstChildren";
} //# sourceMappingURL=generate.js.map
}}),
"[project]/node_modules/@chevrotain/cst-dts-gen/lib/src/api.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "generateCstDts": (()=>generateCstDts)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$cst$2d$dts$2d$gen$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/cst-dts-gen/lib/src/model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$cst$2d$dts$2d$gen$2f$lib$2f$src$2f$generate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/cst-dts-gen/lib/src/generate.js [app-ssr] (ecmascript)");
;
;
const defaultOptions = {
    includeVisitorInterface: true,
    visitorInterfaceName: "ICstNodeVisitor"
};
function generateCstDts(productions, options) {
    const effectiveOptions = Object.assign(Object.assign({}, defaultOptions), options);
    const model = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$cst$2d$dts$2d$gen$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildModel"])(productions);
    return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$cst$2d$dts$2d$gen$2f$lib$2f$src$2f$generate$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["genDts"])(model, effectiveOptions);
} //# sourceMappingURL=api.js.map
}}),
"[project]/node_modules/chevrotain-allstar/lib/atn.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/ __turbopack_context__.s({
    "ATN_BASIC": (()=>ATN_BASIC),
    "ATN_BLOCK_END": (()=>ATN_BLOCK_END),
    "ATN_INVALID_TYPE": (()=>ATN_INVALID_TYPE),
    "ATN_LOOP_END": (()=>ATN_LOOP_END),
    "ATN_PLUS_BLOCK_START": (()=>ATN_PLUS_BLOCK_START),
    "ATN_PLUS_LOOP_BACK": (()=>ATN_PLUS_LOOP_BACK),
    "ATN_RULE_START": (()=>ATN_RULE_START),
    "ATN_RULE_STOP": (()=>ATN_RULE_STOP),
    "ATN_STAR_BLOCK_START": (()=>ATN_STAR_BLOCK_START),
    "ATN_STAR_LOOP_BACK": (()=>ATN_STAR_LOOP_BACK),
    "ATN_STAR_LOOP_ENTRY": (()=>ATN_STAR_LOOP_ENTRY),
    "ATN_TOKEN_START": (()=>ATN_TOKEN_START),
    "AbstractTransition": (()=>AbstractTransition),
    "AtomTransition": (()=>AtomTransition),
    "EpsilonTransition": (()=>EpsilonTransition),
    "RuleTransition": (()=>RuleTransition),
    "buildATNKey": (()=>buildATNKey),
    "createATN": (()=>createATN)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/map.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$filter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/filter.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/chevrotain/lib/src/api.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/model.js [app-ssr] (ecmascript)");
;
;
;
function buildATNKey(rule, type, occurrence) {
    return `${rule.name}_${type}_${occurrence}`;
}
const ATN_INVALID_TYPE = 0;
const ATN_BASIC = 1;
const ATN_RULE_START = 2;
const ATN_PLUS_BLOCK_START = 4;
const ATN_STAR_BLOCK_START = 5;
const ATN_TOKEN_START = 6;
const ATN_RULE_STOP = 7;
const ATN_BLOCK_END = 8;
const ATN_STAR_LOOP_BACK = 9;
const ATN_STAR_LOOP_ENTRY = 10;
const ATN_PLUS_LOOP_BACK = 11;
const ATN_LOOP_END = 12;
class AbstractTransition {
    constructor(target){
        this.target = target;
    }
    isEpsilon() {
        return false;
    }
}
class AtomTransition extends AbstractTransition {
    constructor(target, tokenType){
        super(target);
        this.tokenType = tokenType;
    }
}
class EpsilonTransition extends AbstractTransition {
    constructor(target){
        super(target);
    }
    isEpsilon() {
        return true;
    }
}
class RuleTransition extends AbstractTransition {
    constructor(ruleStart, rule, followState){
        super(ruleStart);
        this.rule = rule;
        this.followState = followState;
    }
    isEpsilon() {
        return true;
    }
}
function createATN(rules) {
    const atn = {
        decisionMap: {},
        decisionStates: [],
        ruleToStartState: new Map(),
        ruleToStopState: new Map(),
        states: []
    };
    createRuleStartAndStopATNStates(atn, rules);
    const ruleLength = rules.length;
    for(let i = 0; i < ruleLength; i++){
        const rule = rules[i];
        const ruleBlock = block(atn, rule, rule);
        if (ruleBlock === undefined) {
            continue;
        }
        buildRuleHandle(atn, rule, ruleBlock);
    }
    return atn;
}
function createRuleStartAndStopATNStates(atn, rules) {
    const ruleLength = rules.length;
    for(let i = 0; i < ruleLength; i++){
        const rule = rules[i];
        const start = newState(atn, rule, undefined, {
            type: ATN_RULE_START
        });
        const stop = newState(atn, rule, undefined, {
            type: ATN_RULE_STOP
        });
        start.stop = stop;
        atn.ruleToStartState.set(rule, start);
        atn.ruleToStopState.set(rule, stop);
    }
}
function atom(atn, rule, production) {
    if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Terminal"]) {
        return tokenRef(atn, rule, production.terminalType, production);
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NonTerminal"]) {
        return ruleRef(atn, rule, production);
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternation"]) {
        return alternation(atn, rule, production);
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"]) {
        return option(atn, rule, production);
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Repetition"]) {
        return repetition(atn, rule, production);
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionWithSeparator"]) {
        return repetitionSep(atn, rule, production);
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatory"]) {
        return repetitionMandatory(atn, rule, production);
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatoryWithSeparator"]) {
        return repetitionMandatorySep(atn, rule, production);
    } else {
        return block(atn, rule, production);
    }
}
function repetition(atn, rule, repetition) {
    const starState = newState(atn, rule, repetition, {
        type: ATN_STAR_BLOCK_START
    });
    defineDecisionState(atn, starState);
    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));
    return star(atn, rule, repetition, handle);
}
function repetitionSep(atn, rule, repetition) {
    const starState = newState(atn, rule, repetition, {
        type: ATN_STAR_BLOCK_START
    });
    defineDecisionState(atn, starState);
    const handle = makeAlts(atn, rule, starState, repetition, block(atn, rule, repetition));
    const sep = tokenRef(atn, rule, repetition.separator, repetition);
    return star(atn, rule, repetition, handle, sep);
}
function repetitionMandatory(atn, rule, repetition) {
    const plusState = newState(atn, rule, repetition, {
        type: ATN_PLUS_BLOCK_START
    });
    defineDecisionState(atn, plusState);
    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));
    return plus(atn, rule, repetition, handle);
}
function repetitionMandatorySep(atn, rule, repetition) {
    const plusState = newState(atn, rule, repetition, {
        type: ATN_PLUS_BLOCK_START
    });
    defineDecisionState(atn, plusState);
    const handle = makeAlts(atn, rule, plusState, repetition, block(atn, rule, repetition));
    const sep = tokenRef(atn, rule, repetition.separator, repetition);
    return plus(atn, rule, repetition, handle, sep);
}
function alternation(atn, rule, alternation) {
    const start = newState(atn, rule, alternation, {
        type: ATN_BASIC
    });
    defineDecisionState(atn, start);
    const alts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(alternation.definition, (e)=>atom(atn, rule, e));
    const handle = makeAlts(atn, rule, start, alternation, ...alts);
    return handle;
}
function option(atn, rule, option) {
    const start = newState(atn, rule, option, {
        type: ATN_BASIC
    });
    defineDecisionState(atn, start);
    const handle = makeAlts(atn, rule, start, option, block(atn, rule, option));
    return optional(atn, rule, option, handle);
}
function block(atn, rule, block) {
    const handles = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$filter$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(block.definition, (e)=>atom(atn, rule, e)), (e)=>e !== undefined);
    if (handles.length === 1) {
        return handles[0];
    } else if (handles.length === 0) {
        return undefined;
    } else {
        return makeBlock(atn, handles);
    }
}
function plus(atn, rule, plus, handle, sep) {
    const blkStart = handle.left;
    const blkEnd = handle.right;
    const loop = newState(atn, rule, plus, {
        type: ATN_PLUS_LOOP_BACK
    });
    defineDecisionState(atn, loop);
    const end = newState(atn, rule, plus, {
        type: ATN_LOOP_END
    });
    blkStart.loopback = loop;
    end.loopback = loop;
    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionMandatoryWithSeparator' : 'RepetitionMandatory', plus.idx)] = loop;
    epsilon(blkEnd, loop); // block can see loop back
    // Depending on whether we have a separator we put the exit transition at index 1 or 0
    // This influences the chosen option in the lookahead DFA
    if (sep === undefined) {
        epsilon(loop, blkStart); // loop back to start
        epsilon(loop, end); // exit
    } else {
        epsilon(loop, end); // exit
        // loop back to start with separator
        epsilon(loop, sep.left);
        epsilon(sep.right, blkStart);
    }
    return {
        left: blkStart,
        right: end
    };
}
function star(atn, rule, star, handle, sep) {
    const start = handle.left;
    const end = handle.right;
    const entry = newState(atn, rule, star, {
        type: ATN_STAR_LOOP_ENTRY
    });
    defineDecisionState(atn, entry);
    const loopEnd = newState(atn, rule, star, {
        type: ATN_LOOP_END
    });
    const loop = newState(atn, rule, star, {
        type: ATN_STAR_LOOP_BACK
    });
    entry.loopback = loop;
    loopEnd.loopback = loop;
    epsilon(entry, start); // loop enter edge (alt 2)
    epsilon(entry, loopEnd); // bypass loop edge (alt 1)
    epsilon(end, loop); // block end hits loop back
    if (sep !== undefined) {
        epsilon(loop, loopEnd); // end loop
        // loop back to start of handle using separator
        epsilon(loop, sep.left);
        epsilon(sep.right, start);
    } else {
        epsilon(loop, entry); // loop back to entry/exit decision
    }
    atn.decisionMap[buildATNKey(rule, sep ? 'RepetitionWithSeparator' : 'Repetition', star.idx)] = entry;
    return {
        left: entry,
        right: loopEnd
    };
}
function optional(atn, rule, optional, handle) {
    const start = handle.left;
    const end = handle.right;
    epsilon(start, end);
    atn.decisionMap[buildATNKey(rule, 'Option', optional.idx)] = start;
    return handle;
}
function defineDecisionState(atn, state) {
    atn.decisionStates.push(state);
    state.decision = atn.decisionStates.length - 1;
    return state.decision;
}
function makeAlts(atn, rule, start, production, ...alts) {
    const end = newState(atn, rule, production, {
        type: ATN_BLOCK_END,
        start
    });
    start.end = end;
    for (const alt of alts){
        if (alt !== undefined) {
            // hook alts up to decision block
            epsilon(start, alt.left);
            epsilon(alt.right, end);
        } else {
            epsilon(start, end);
        }
    }
    const handle = {
        left: start,
        right: end
    };
    atn.decisionMap[buildATNKey(rule, getProdType(production), production.idx)] = start;
    return handle;
}
function getProdType(production) {
    if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternation"]) {
        return 'Alternation';
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"]) {
        return 'Option';
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Repetition"]) {
        return 'Repetition';
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionWithSeparator"]) {
        return 'RepetitionWithSeparator';
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatory"]) {
        return 'RepetitionMandatory';
    } else if (production instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatoryWithSeparator"]) {
        return 'RepetitionMandatoryWithSeparator';
    } else {
        throw new Error('Invalid production type encountered');
    }
}
function makeBlock(atn, alts) {
    const altsLength = alts.length;
    for(let i = 0; i < altsLength - 1; i++){
        const handle = alts[i];
        let transition;
        if (handle.left.transitions.length === 1) {
            transition = handle.left.transitions[0];
        }
        const isRuleTransition = transition instanceof RuleTransition;
        const ruleTransition = transition;
        const next = alts[i + 1].left;
        if (handle.left.type === ATN_BASIC && handle.right.type === ATN_BASIC && transition !== undefined && (isRuleTransition && ruleTransition.followState === handle.right || transition.target === handle.right)) {
            // we can avoid epsilon edge to next element
            if (isRuleTransition) {
                ruleTransition.followState = next;
            } else {
                transition.target = next;
            }
            removeState(atn, handle.right); // we skipped over this state
        } else {
            // need epsilon if previous block's right end node is complex
            epsilon(handle.right, next);
        }
    }
    const first = alts[0];
    const last = alts[altsLength - 1];
    return {
        left: first.left,
        right: last.right
    };
}
function tokenRef(atn, rule, tokenType, production) {
    const left = newState(atn, rule, production, {
        type: ATN_BASIC
    });
    const right = newState(atn, rule, production, {
        type: ATN_BASIC
    });
    addTransition(left, new AtomTransition(right, tokenType));
    return {
        left,
        right
    };
}
function ruleRef(atn, currentRule, nonTerminal) {
    const rule = nonTerminal.referencedRule;
    const start = atn.ruleToStartState.get(rule);
    const left = newState(atn, currentRule, nonTerminal, {
        type: ATN_BASIC
    });
    const right = newState(atn, currentRule, nonTerminal, {
        type: ATN_BASIC
    });
    const call = new RuleTransition(start, rule, right);
    addTransition(left, call);
    return {
        left,
        right
    };
}
function buildRuleHandle(atn, rule, block) {
    const start = atn.ruleToStartState.get(rule);
    epsilon(start, block.left);
    const stop = atn.ruleToStopState.get(rule);
    epsilon(block.right, stop);
    const handle = {
        left: start,
        right: stop
    };
    return handle;
}
function epsilon(a, b) {
    const transition = new EpsilonTransition(b);
    addTransition(a, transition);
}
function newState(atn, rule, production, partial) {
    const t = Object.assign({
        atn,
        production,
        epsilonOnlyTransitions: false,
        rule,
        transitions: [],
        nextTokenWithinRule: [],
        stateNumber: atn.states.length
    }, partial);
    atn.states.push(t);
    return t;
}
function addTransition(state, transition) {
    // A single ATN state can only contain epsilon transitions or non-epsilon transitions
    // Because they are never mixed, only setting the property for the first transition is fine
    if (state.transitions.length === 0) {
        state.epsilonOnlyTransitions = transition.isEpsilon();
    }
    state.transitions.push(transition);
}
function removeState(atn, state) {
    atn.states.splice(atn.states.indexOf(state), 1);
} //# sourceMappingURL=atn.js.map
}}),
"[project]/node_modules/chevrotain-allstar/lib/dfa.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/ __turbopack_context__.s({
    "ATNConfigSet": (()=>ATNConfigSet),
    "DFA_ERROR": (()=>DFA_ERROR),
    "getATNConfigKey": (()=>getATNConfigKey)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/map.js [app-ssr] (ecmascript)");
;
const DFA_ERROR = {};
class ATNConfigSet {
    constructor(){
        this.map = {};
        this.configs = [];
    }
    get size() {
        return this.configs.length;
    }
    finalize() {
        // Empties the map to free up memory
        this.map = {};
    }
    add(config) {
        const key = getATNConfigKey(config);
        // Only add configs which don't exist in our map already
        // While this does not influence the actual algorithm, adding them anyway would massively increase memory consumption
        if (!(key in this.map)) {
            this.map[key] = this.configs.length;
            this.configs.push(config);
        }
    }
    get elements() {
        return this.configs;
    }
    get alts() {
        return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(this.configs, (e)=>e.alt);
    }
    get key() {
        let value = "";
        for(const k in this.map){
            value += k + ":";
        }
        return value;
    }
}
function getATNConfigKey(config, alt = true) {
    return `${alt ? `a${config.alt}` : ""}s${config.state.stateNumber}:${config.stack.map((e)=>e.stateNumber.toString()).join("_")}`;
} //# sourceMappingURL=dfa.js.map
}}),
"[project]/node_modules/chevrotain-allstar/lib/all-star-lookahead.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/ __turbopack_context__.s({
    "LLStarLookaheadStrategy": (()=>LLStarLookaheadStrategy)
});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$api$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$module__evaluation$3e$__ = __turbopack_context__.i("[project]/node_modules/chevrotain/lib/src/api.js [app-ssr] (ecmascript) <module evaluation>");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$scan$2f$tokens_public$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chevrotain/lib/src/scan/tokens_public.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/@chevrotain/gast/lib/src/model.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$parse$2f$grammar$2f$llk_lookahead$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chevrotain/lib/src/parse/grammar/llk_lookahead.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$parse$2f$grammar$2f$lookahead$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chevrotain/lib/src/parse/grammar/lookahead.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chevrotain-allstar/lib/atn.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chevrotain-allstar/lib/dfa.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/min.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$flatMap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/flatMap.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$uniqBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/uniqBy.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/map.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/flatten.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$forEach$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/forEach.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isEmpty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/isEmpty.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$reduce$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/lodash-es/reduce.js [app-ssr] (ecmascript)");
;
;
;
;
;
;
;
;
;
;
;
function createDFACache(startState, decision) {
    const map = {};
    return (predicateSet)=>{
        const key = predicateSet.toString();
        let existing = map[key];
        if (existing !== undefined) {
            return existing;
        } else {
            existing = {
                atnStartState: startState,
                decision,
                states: {}
            };
            map[key] = existing;
            return existing;
        }
    };
}
class PredicateSet {
    constructor(){
        this.predicates = [];
    }
    is(index) {
        return index >= this.predicates.length || this.predicates[index];
    }
    set(index, value) {
        this.predicates[index] = value;
    }
    toString() {
        let value = "";
        const size = this.predicates.length;
        for(let i = 0; i < size; i++){
            value += this.predicates[i] === true ? "1" : "0";
        }
        return value;
    }
}
const EMPTY_PREDICATES = new PredicateSet();
class LLStarLookaheadStrategy extends __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$parse$2f$grammar$2f$llk_lookahead$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["LLkLookaheadStrategy"] {
    constructor(options){
        var _a;
        super();
        this.logging = (_a = options === null || options === void 0 ? void 0 : options.logging) !== null && _a !== void 0 ? _a : (message)=>console.log(message);
    }
    initialize(options) {
        this.atn = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["createATN"])(options.rules);
        this.dfas = initATNSimulator(this.atn);
    }
    validateAmbiguousAlternationAlternatives() {
        return [];
    }
    validateEmptyOrAlternatives() {
        return [];
    }
    buildLookaheadForAlternation(options) {
        const { prodOccurrence, rule, hasPredicates, dynamicTokensEnabled } = options;
        const dfas = this.dfas;
        const logging = this.logging;
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildATNKey"])(rule, 'Alternation', prodOccurrence);
        const decisionState = this.atn.decisionMap[key];
        const decisionIndex = decisionState.decision;
        const partialAlts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$parse$2f$grammar$2f$lookahead$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLookaheadPaths"])({
            maxLookahead: 1,
            occurrence: prodOccurrence,
            prodType: "Alternation",
            rule: rule
        }), (currAlt)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(currAlt, (path)=>path[0]));
        if (isLL1Sequence(partialAlts, false) && !dynamicTokensEnabled) {
            const choiceToAlt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$reduce$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(partialAlts, (result, currAlt, idx)=>{
                (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$forEach$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(currAlt, (currTokType)=>{
                    if (currTokType) {
                        result[currTokType.tokenTypeIdx] = idx;
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$forEach$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(currTokType.categoryMatches, (currExtendingType)=>{
                            result[currExtendingType] = idx;
                        });
                    }
                });
                return result;
            }, {});
            if (hasPredicates) {
                return function(orAlts) {
                    var _a;
                    const nextToken = this.LA(1);
                    const prediction = choiceToAlt[nextToken.tokenTypeIdx];
                    if (orAlts !== undefined && prediction !== undefined) {
                        const gate = (_a = orAlts[prediction]) === null || _a === void 0 ? void 0 : _a.GATE;
                        if (gate !== undefined && gate.call(this) === false) {
                            return undefined;
                        }
                    }
                    return prediction;
                };
            } else {
                return function() {
                    const nextToken = this.LA(1);
                    return choiceToAlt[nextToken.tokenTypeIdx];
                };
            }
        } else if (hasPredicates) {
            return function(orAlts) {
                const predicates = new PredicateSet();
                const length = orAlts === undefined ? 0 : orAlts.length;
                for(let i = 0; i < length; i++){
                    const gate = orAlts === null || orAlts === void 0 ? void 0 : orAlts[i].GATE;
                    predicates.set(i, gate === undefined || gate.call(this));
                }
                const result = adaptivePredict.call(this, dfas, decisionIndex, predicates, logging);
                return typeof result === 'number' ? result : undefined;
            };
        } else {
            return function() {
                const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
                return typeof result === 'number' ? result : undefined;
            };
        }
    }
    buildLookaheadForOptional(options) {
        const { prodOccurrence, rule, prodType, dynamicTokensEnabled } = options;
        const dfas = this.dfas;
        const logging = this.logging;
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["buildATNKey"])(rule, prodType, prodOccurrence);
        const decisionState = this.atn.decisionMap[key];
        const decisionIndex = decisionState.decision;
        const alts = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])((0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$parse$2f$grammar$2f$lookahead$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getLookaheadPaths"])({
            maxLookahead: 1,
            occurrence: prodOccurrence,
            prodType,
            rule
        }), (e)=>{
            return (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(e, (g)=>g[0]);
        });
        if (isLL1Sequence(alts) && alts[0][0] && !dynamicTokensEnabled) {
            const alt = alts[0];
            const singleTokensTypes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$flatten$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(alt);
            if (singleTokensTypes.length === 1 && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$isEmpty$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(singleTokensTypes[0].categoryMatches)) {
                const expectedTokenType = singleTokensTypes[0];
                const expectedTokenUniqueKey = expectedTokenType.tokenTypeIdx;
                return function() {
                    return this.LA(1).tokenTypeIdx === expectedTokenUniqueKey;
                };
            } else {
                const choiceToAlt = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$reduce$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(singleTokensTypes, (result, currTokType)=>{
                    if (currTokType !== undefined) {
                        result[currTokType.tokenTypeIdx] = true;
                        (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$forEach$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(currTokType.categoryMatches, (currExtendingType)=>{
                            result[currExtendingType] = true;
                        });
                    }
                    return result;
                }, {});
                return function() {
                    const nextToken = this.LA(1);
                    return choiceToAlt[nextToken.tokenTypeIdx] === true;
                };
            }
        }
        return function() {
            const result = adaptivePredict.call(this, dfas, decisionIndex, EMPTY_PREDICATES, logging);
            return typeof result === "object" ? false : result === 0;
        };
    }
}
function isLL1Sequence(sequences, allowEmpty = true) {
    const fullSet = new Set();
    for (const alt of sequences){
        const altSet = new Set();
        for (const tokType of alt){
            if (tokType === undefined) {
                if (allowEmpty) {
                    break;
                } else {
                    return false;
                }
            }
            const indices = [
                tokType.tokenTypeIdx
            ].concat(tokType.categoryMatches);
            for (const index of indices){
                if (fullSet.has(index)) {
                    if (!altSet.has(index)) {
                        return false;
                    }
                } else {
                    fullSet.add(index);
                    altSet.add(index);
                }
            }
        }
    }
    return true;
}
function initATNSimulator(atn) {
    const decisionLength = atn.decisionStates.length;
    const decisionToDFA = Array(decisionLength);
    for(let i = 0; i < decisionLength; i++){
        decisionToDFA[i] = createDFACache(atn.decisionStates[i], i);
    }
    return decisionToDFA;
}
function adaptivePredict(dfaCaches, decision, predicateSet, logging) {
    const dfa = dfaCaches[decision](predicateSet);
    let start = dfa.start;
    if (start === undefined) {
        const closure = computeStartState(dfa.atnStartState);
        start = addDFAState(dfa, newDFAState(closure));
        dfa.start = start;
    }
    const alt = performLookahead.apply(this, [
        dfa,
        start,
        predicateSet,
        logging
    ]);
    return alt;
}
function performLookahead(dfa, s0, predicateSet, logging) {
    let previousD = s0;
    let i = 1;
    const path = [];
    let t = this.LA(i++);
    while(true){
        let d = getExistingTargetState(previousD, t);
        if (d === undefined) {
            d = computeLookaheadTarget.apply(this, [
                dfa,
                previousD,
                t,
                i,
                predicateSet,
                logging
            ]);
        }
        if (d === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DFA_ERROR"]) {
            return buildAdaptivePredictError(path, previousD, t);
        }
        if (d.isAcceptState === true) {
            return d.prediction;
        }
        previousD = d;
        path.push(t);
        t = this.LA(i++);
    }
}
function computeLookaheadTarget(dfa, previousD, token, lookahead, predicateSet, logging) {
    const reach = computeReachSet(previousD.configs, token, predicateSet);
    if (reach.size === 0) {
        addDFAEdge(dfa, previousD, token, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DFA_ERROR"]);
        return __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DFA_ERROR"];
    }
    let newState = newDFAState(reach);
    const predictedAlt = getUniqueAlt(reach, predicateSet);
    if (predictedAlt !== undefined) {
        newState.isAcceptState = true;
        newState.prediction = predictedAlt;
        newState.configs.uniqueAlt = predictedAlt;
    } else if (hasConflictTerminatingPrediction(reach)) {
        const prediction = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$min$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(reach.alts);
        newState.isAcceptState = true;
        newState.prediction = prediction;
        newState.configs.uniqueAlt = prediction;
        reportLookaheadAmbiguity.apply(this, [
            dfa,
            lookahead,
            reach.alts,
            logging
        ]);
    }
    newState = addDFAEdge(dfa, previousD, token, newState);
    return newState;
}
function reportLookaheadAmbiguity(dfa, lookahead, ambiguityIndices, logging) {
    const prefixPath = [];
    for(let i = 1; i <= lookahead; i++){
        prefixPath.push(this.LA(i).tokenType);
    }
    const atnState = dfa.atnStartState;
    const topLevelRule = atnState.rule;
    const production = atnState.production;
    const message = buildAmbiguityError({
        topLevelRule,
        ambiguityIndices,
        production,
        prefixPath
    });
    logging(message);
}
function buildAmbiguityError(options) {
    const pathMsg = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$map$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(options.prefixPath, (currtok)=>(0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$scan$2f$tokens_public$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tokenLabel"])(currtok)).join(", ");
    const occurrence = options.production.idx === 0 ? "" : options.production.idx;
    let currMessage = `Ambiguous Alternatives Detected: <${options.ambiguityIndices.join(", ")}> in <${getProductionDslName(options.production)}${occurrence}>` + ` inside <${options.topLevelRule.name}> Rule,\n` + `<${pathMsg}> may appears as a prefix path in all these alternatives.\n`;
    currMessage = currMessage + `See: https://chevrotain.io/docs/guide/resolving_grammar_errors.html#AMBIGUOUS_ALTERNATIVES\n` + `For Further details.`;
    return currMessage;
}
function getProductionDslName(prod) {
    if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["NonTerminal"]) {
        return "SUBRULE";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Option"]) {
        return "OPTION";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Alternation"]) {
        return "OR";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatory"]) {
        return "AT_LEAST_ONE";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionMandatoryWithSeparator"]) {
        return "AT_LEAST_ONE_SEP";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RepetitionWithSeparator"]) {
        return "MANY_SEP";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Repetition"]) {
        return "MANY";
    } else if (prod instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f40$chevrotain$2f$gast$2f$lib$2f$src$2f$model$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["Terminal"]) {
        return "CONSUME";
    } else {
        throw Error("non exhaustive match");
    }
}
function buildAdaptivePredictError(path, previous, current) {
    const nextTransitions = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$flatMap$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(previous.configs.elements, (e)=>e.state.transitions);
    const nextTokenTypes = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$lodash$2d$es$2f$uniqBy$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["default"])(nextTransitions.filter((e)=>e instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AtomTransition"]).map((e)=>e.tokenType), (e)=>e.tokenTypeIdx);
    return {
        actualToken: current,
        possibleTokenTypes: nextTokenTypes,
        tokenPath: path
    };
}
function getExistingTargetState(state, token) {
    return state.edges[token.tokenTypeIdx];
}
function computeReachSet(configs, token, predicateSet) {
    const intermediate = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ATNConfigSet"]();
    const skippedStopStates = [];
    for (const c of configs.elements){
        if (predicateSet.is(c.alt) === false) {
            continue;
        }
        if (c.state.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ATN_RULE_STOP"]) {
            skippedStopStates.push(c);
            continue;
        }
        const transitionLength = c.state.transitions.length;
        for(let i = 0; i < transitionLength; i++){
            const transition = c.state.transitions[i];
            const target = getReachableTarget(transition, token);
            if (target !== undefined) {
                intermediate.add({
                    state: target,
                    alt: c.alt,
                    stack: c.stack
                });
            }
        }
    }
    let reach;
    if (skippedStopStates.length === 0 && intermediate.size === 1) {
        reach = intermediate;
    }
    if (reach === undefined) {
        reach = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ATNConfigSet"]();
        for (const c of intermediate.elements){
            closure(c, reach);
        }
    }
    if (skippedStopStates.length > 0 && !hasConfigInRuleStopState(reach)) {
        for (const c of skippedStopStates){
            reach.add(c);
        }
    }
    return reach;
}
function getReachableTarget(transition, token) {
    if (transition instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["AtomTransition"] && (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2f$lib$2f$src$2f$scan$2f$tokens_public$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["tokenMatcher"])(token, transition.tokenType)) {
        return transition.target;
    }
    return undefined;
}
function getUniqueAlt(configs, predicateSet) {
    let alt;
    for (const c of configs.elements){
        if (predicateSet.is(c.alt) === true) {
            if (alt === undefined) {
                alt = c.alt;
            } else if (alt !== c.alt) {
                return undefined;
            }
        }
    }
    return alt;
}
function newDFAState(closure) {
    return {
        configs: closure,
        edges: {},
        isAcceptState: false,
        prediction: -1
    };
}
function addDFAEdge(dfa, from, token, to) {
    to = addDFAState(dfa, to);
    from.edges[token.tokenTypeIdx] = to;
    return to;
}
function addDFAState(dfa, state) {
    if (state === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["DFA_ERROR"]) {
        return state;
    }
    // Repetitions have the same config set
    // Therefore, storing the key of the config in a map allows us to create a loop in our DFA
    const mapKey = state.configs.key;
    const existing = dfa.states[mapKey];
    if (existing !== undefined) {
        return existing;
    }
    state.configs.finalize();
    dfa.states[mapKey] = state;
    return state;
}
function computeStartState(atnState) {
    const configs = new __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ATNConfigSet"]();
    const numberOfTransitions = atnState.transitions.length;
    for(let i = 0; i < numberOfTransitions; i++){
        const target = atnState.transitions[i].target;
        const config = {
            state: target,
            alt: i,
            stack: []
        };
        closure(config, configs);
    }
    return configs;
}
function closure(config, configs) {
    const p = config.state;
    if (p.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ATN_RULE_STOP"]) {
        if (config.stack.length > 0) {
            const atnStack = [
                ...config.stack
            ];
            const followState = atnStack.pop();
            const followConfig = {
                state: followState,
                alt: config.alt,
                stack: atnStack
            };
            closure(followConfig, configs);
        } else {
            // Dipping into outer context, simply add the config
            // This will stop computation once every config is at the rule stop state
            configs.add(config);
        }
        return;
    }
    if (!p.epsilonOnlyTransitions) {
        configs.add(config);
    }
    const transitionLength = p.transitions.length;
    for(let i = 0; i < transitionLength; i++){
        const transition = p.transitions[i];
        const c = getEpsilonTarget(config, transition);
        if (c !== undefined) {
            closure(c, configs);
        }
    }
}
function getEpsilonTarget(config, transition) {
    if (transition instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["EpsilonTransition"]) {
        return {
            state: transition.target,
            alt: config.alt,
            stack: config.stack
        };
    } else if (transition instanceof __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["RuleTransition"]) {
        const stack = [
            ...config.stack,
            transition.followState
        ];
        return {
            state: transition.target,
            alt: config.alt,
            stack
        };
    }
    return undefined;
}
function hasConfigInRuleStopState(configs) {
    for (const c of configs.elements){
        if (c.state.type === __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ATN_RULE_STOP"]) {
            return true;
        }
    }
    return false;
}
function allConfigsInRuleStopStates(configs) {
    for (const c of configs.elements){
        if (c.state.type !== __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$atn$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["ATN_RULE_STOP"]) {
            return false;
        }
    }
    return true;
}
function hasConflictTerminatingPrediction(configs) {
    if (allConfigsInRuleStopStates(configs)) {
        return true;
    }
    const altSets = getConflictingAltSets(configs.elements);
    const heuristic = hasConflictingAltSet(altSets) && !hasStateAssociatedWithOneAlt(altSets);
    return heuristic;
}
function getConflictingAltSets(configs) {
    const configToAlts = new Map();
    for (const c of configs){
        const key = (0, __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$dfa$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__["getATNConfigKey"])(c, false);
        let alts = configToAlts.get(key);
        if (alts === undefined) {
            alts = {};
            configToAlts.set(key, alts);
        }
        alts[c.alt] = true;
    }
    return configToAlts;
}
function hasConflictingAltSet(altSets) {
    for (const value of Array.from(altSets.values())){
        if (Object.keys(value).length > 1) {
            return true;
        }
    }
    return false;
}
function hasStateAssociatedWithOneAlt(altSets) {
    for (const value of Array.from(altSets.values())){
        if (Object.keys(value).length === 1) {
            return true;
        }
    }
    return false;
} //# sourceMappingURL=all-star-lookahead.js.map
}}),
"[project]/node_modules/chevrotain-allstar/lib/index.js [app-ssr] (ecmascript) <locals>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/******************************************************************************
 * Copyright 2022 TypeFox GmbH
 * This program and the accompanying materials are made available under the
 * terms of the MIT License, which is available in the project root.
 ******************************************************************************/ __turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$all$2d$star$2d$lookahead$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chevrotain-allstar/lib/all-star-lookahead.js [app-ssr] (ecmascript)"); //# sourceMappingURL=index.js.map
;
}}),
"[project]/node_modules/chevrotain-allstar/lib/index.js [app-ssr] (ecmascript) <module evaluation>": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({});
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$all$2d$star$2d$lookahead$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__ = __turbopack_context__.i("[project]/node_modules/chevrotain-allstar/lib/all-star-lookahead.js [app-ssr] (ecmascript)");
var __TURBOPACK__imported__module__$5b$project$5d2f$node_modules$2f$chevrotain$2d$allstar$2f$lib$2f$index$2e$js__$5b$app$2d$ssr$5d$__$28$ecmascript$29$__$3c$locals$3e$__ = __turbopack_context__.i("[project]/node_modules/chevrotain-allstar/lib/index.js [app-ssr] (ecmascript) <locals>");
}}),
"[project]/node_modules/vscode-languageserver-types/lib/esm/main.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ __turbopack_context__.s({
    "AnnotatedTextEdit": (()=>AnnotatedTextEdit),
    "ChangeAnnotation": (()=>ChangeAnnotation),
    "ChangeAnnotationIdentifier": (()=>ChangeAnnotationIdentifier),
    "CodeAction": (()=>CodeAction),
    "CodeActionContext": (()=>CodeActionContext),
    "CodeActionKind": (()=>CodeActionKind),
    "CodeActionTriggerKind": (()=>CodeActionTriggerKind),
    "CodeDescription": (()=>CodeDescription),
    "CodeLens": (()=>CodeLens),
    "Color": (()=>Color),
    "ColorInformation": (()=>ColorInformation),
    "ColorPresentation": (()=>ColorPresentation),
    "Command": (()=>Command),
    "CompletionItem": (()=>CompletionItem),
    "CompletionItemKind": (()=>CompletionItemKind),
    "CompletionItemLabelDetails": (()=>CompletionItemLabelDetails),
    "CompletionItemTag": (()=>CompletionItemTag),
    "CompletionList": (()=>CompletionList),
    "CreateFile": (()=>CreateFile),
    "DeleteFile": (()=>DeleteFile),
    "Diagnostic": (()=>Diagnostic),
    "DiagnosticRelatedInformation": (()=>DiagnosticRelatedInformation),
    "DiagnosticSeverity": (()=>DiagnosticSeverity),
    "DiagnosticTag": (()=>DiagnosticTag),
    "DocumentHighlight": (()=>DocumentHighlight),
    "DocumentHighlightKind": (()=>DocumentHighlightKind),
    "DocumentLink": (()=>DocumentLink),
    "DocumentSymbol": (()=>DocumentSymbol),
    "DocumentUri": (()=>DocumentUri),
    "EOL": (()=>EOL),
    "FoldingRange": (()=>FoldingRange),
    "FoldingRangeKind": (()=>FoldingRangeKind),
    "FormattingOptions": (()=>FormattingOptions),
    "Hover": (()=>Hover),
    "InlayHint": (()=>InlayHint),
    "InlayHintKind": (()=>InlayHintKind),
    "InlayHintLabelPart": (()=>InlayHintLabelPart),
    "InlineCompletionContext": (()=>InlineCompletionContext),
    "InlineCompletionItem": (()=>InlineCompletionItem),
    "InlineCompletionList": (()=>InlineCompletionList),
    "InlineCompletionTriggerKind": (()=>InlineCompletionTriggerKind),
    "InlineValueContext": (()=>InlineValueContext),
    "InlineValueEvaluatableExpression": (()=>InlineValueEvaluatableExpression),
    "InlineValueText": (()=>InlineValueText),
    "InlineValueVariableLookup": (()=>InlineValueVariableLookup),
    "InsertReplaceEdit": (()=>InsertReplaceEdit),
    "InsertTextFormat": (()=>InsertTextFormat),
    "InsertTextMode": (()=>InsertTextMode),
    "Location": (()=>Location),
    "LocationLink": (()=>LocationLink),
    "MarkedString": (()=>MarkedString),
    "MarkupContent": (()=>MarkupContent),
    "MarkupKind": (()=>MarkupKind),
    "OptionalVersionedTextDocumentIdentifier": (()=>OptionalVersionedTextDocumentIdentifier),
    "ParameterInformation": (()=>ParameterInformation),
    "Position": (()=>Position),
    "Range": (()=>Range),
    "RenameFile": (()=>RenameFile),
    "SelectedCompletionInfo": (()=>SelectedCompletionInfo),
    "SelectionRange": (()=>SelectionRange),
    "SemanticTokenModifiers": (()=>SemanticTokenModifiers),
    "SemanticTokenTypes": (()=>SemanticTokenTypes),
    "SemanticTokens": (()=>SemanticTokens),
    "SignatureInformation": (()=>SignatureInformation),
    "StringValue": (()=>StringValue),
    "SymbolInformation": (()=>SymbolInformation),
    "SymbolKind": (()=>SymbolKind),
    "SymbolTag": (()=>SymbolTag),
    "TextDocument": (()=>TextDocument),
    "TextDocumentEdit": (()=>TextDocumentEdit),
    "TextDocumentIdentifier": (()=>TextDocumentIdentifier),
    "TextDocumentItem": (()=>TextDocumentItem),
    "TextEdit": (()=>TextEdit),
    "URI": (()=>URI),
    "VersionedTextDocumentIdentifier": (()=>VersionedTextDocumentIdentifier),
    "WorkspaceChange": (()=>WorkspaceChange),
    "WorkspaceEdit": (()=>WorkspaceEdit),
    "WorkspaceFolder": (()=>WorkspaceFolder),
    "WorkspaceSymbol": (()=>WorkspaceSymbol),
    "integer": (()=>integer),
    "uinteger": (()=>uinteger)
});
'use strict';
var DocumentUri;
(function(DocumentUri) {
    function is(value) {
        return typeof value === 'string';
    }
    DocumentUri.is = is;
})(DocumentUri || (DocumentUri = {}));
var URI;
(function(URI) {
    function is(value) {
        return typeof value === 'string';
    }
    URI.is = is;
})(URI || (URI = {}));
var integer;
(function(integer) {
    integer.MIN_VALUE = -2147483648;
    integer.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && integer.MIN_VALUE <= value && value <= integer.MAX_VALUE;
    }
    integer.is = is;
})(integer || (integer = {}));
var uinteger;
(function(uinteger) {
    uinteger.MIN_VALUE = 0;
    uinteger.MAX_VALUE = 2147483647;
    function is(value) {
        return typeof value === 'number' && uinteger.MIN_VALUE <= value && value <= uinteger.MAX_VALUE;
    }
    uinteger.is = is;
})(uinteger || (uinteger = {}));
var Position;
(function(Position) {
    /**
     * Creates a new Position literal from the given line and character.
     * @param line The position's line.
     * @param character The position's character.
     */ function create(line, character) {
        if (line === Number.MAX_VALUE) {
            line = uinteger.MAX_VALUE;
        }
        if (character === Number.MAX_VALUE) {
            character = uinteger.MAX_VALUE;
        }
        return {
            line,
            character
        };
    }
    Position.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Position} interface.
     */ function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.line) && Is.uinteger(candidate.character);
    }
    Position.is = is;
})(Position || (Position = {}));
var Range;
(function(Range) {
    function create(one, two, three, four) {
        if (Is.uinteger(one) && Is.uinteger(two) && Is.uinteger(three) && Is.uinteger(four)) {
            return {
                start: Position.create(one, two),
                end: Position.create(three, four)
            };
        } else if (Position.is(one) && Position.is(two)) {
            return {
                start: one,
                end: two
            };
        } else {
            throw new Error(`Range#create called with invalid arguments[${one}, ${two}, ${three}, ${four}]`);
        }
    }
    Range.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Range} interface.
     */ function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.start) && Position.is(candidate.end);
    }
    Range.is = is;
})(Range || (Range = {}));
var Location;
(function(Location) {
    /**
     * Creates a Location literal.
     * @param uri The location's uri.
     * @param range The location's range.
     */ function create(uri, range) {
        return {
            uri,
            range
        };
    }
    Location.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Location} interface.
     */ function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (Is.string(candidate.uri) || Is.undefined(candidate.uri));
    }
    Location.is = is;
})(Location || (Location = {}));
var LocationLink;
(function(LocationLink) {
    /**
     * Creates a LocationLink literal.
     * @param targetUri The definition's uri.
     * @param targetRange The full range of the definition.
     * @param targetSelectionRange The span of the symbol definition at the target.
     * @param originSelectionRange The span of the symbol being defined in the originating source file.
     */ function create(targetUri, targetRange, targetSelectionRange, originSelectionRange) {
        return {
            targetUri,
            targetRange,
            targetSelectionRange,
            originSelectionRange
        };
    }
    LocationLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link LocationLink} interface.
     */ function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.targetRange) && Is.string(candidate.targetUri) && Range.is(candidate.targetSelectionRange) && (Range.is(candidate.originSelectionRange) || Is.undefined(candidate.originSelectionRange));
    }
    LocationLink.is = is;
})(LocationLink || (LocationLink = {}));
var Color;
(function(Color) {
    /**
     * Creates a new Color literal.
     */ function create(red, green, blue, alpha) {
        return {
            red,
            green,
            blue,
            alpha
        };
    }
    Color.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Color} interface.
     */ function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.numberRange(candidate.red, 0, 1) && Is.numberRange(candidate.green, 0, 1) && Is.numberRange(candidate.blue, 0, 1) && Is.numberRange(candidate.alpha, 0, 1);
    }
    Color.is = is;
})(Color || (Color = {}));
var ColorInformation;
(function(ColorInformation) {
    /**
     * Creates a new ColorInformation literal.
     */ function create(range, color) {
        return {
            range,
            color
        };
    }
    ColorInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && Color.is(candidate.color);
    }
    ColorInformation.is = is;
})(ColorInformation || (ColorInformation = {}));
var ColorPresentation;
(function(ColorPresentation) {
    /**
     * Creates a new ColorInformation literal.
     */ function create(label, textEdit, additionalTextEdits) {
        return {
            label,
            textEdit,
            additionalTextEdits
        };
    }
    ColorPresentation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ColorInformation} interface.
     */ function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.undefined(candidate.textEdit) || TextEdit.is(candidate)) && (Is.undefined(candidate.additionalTextEdits) || Is.typedArray(candidate.additionalTextEdits, TextEdit.is));
    }
    ColorPresentation.is = is;
})(ColorPresentation || (ColorPresentation = {}));
var FoldingRangeKind;
(function(FoldingRangeKind) {
    /**
     * Folding range for a comment
     */ FoldingRangeKind.Comment = 'comment';
    /**
     * Folding range for an import or include
     */ FoldingRangeKind.Imports = 'imports';
    /**
     * Folding range for a region (e.g. `#region`)
     */ FoldingRangeKind.Region = 'region';
})(FoldingRangeKind || (FoldingRangeKind = {}));
var FoldingRange;
(function(FoldingRange) {
    /**
     * Creates a new FoldingRange literal.
     */ function create(startLine, endLine, startCharacter, endCharacter, kind, collapsedText) {
        const result = {
            startLine,
            endLine
        };
        if (Is.defined(startCharacter)) {
            result.startCharacter = startCharacter;
        }
        if (Is.defined(endCharacter)) {
            result.endCharacter = endCharacter;
        }
        if (Is.defined(kind)) {
            result.kind = kind;
        }
        if (Is.defined(collapsedText)) {
            result.collapsedText = collapsedText;
        }
        return result;
    }
    FoldingRange.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FoldingRange} interface.
     */ function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.uinteger(candidate.startLine) && Is.uinteger(candidate.startLine) && (Is.undefined(candidate.startCharacter) || Is.uinteger(candidate.startCharacter)) && (Is.undefined(candidate.endCharacter) || Is.uinteger(candidate.endCharacter)) && (Is.undefined(candidate.kind) || Is.string(candidate.kind));
    }
    FoldingRange.is = is;
})(FoldingRange || (FoldingRange = {}));
var DiagnosticRelatedInformation;
(function(DiagnosticRelatedInformation) {
    /**
     * Creates a new DiagnosticRelatedInformation literal.
     */ function create(location, message) {
        return {
            location,
            message
        };
    }
    DiagnosticRelatedInformation.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DiagnosticRelatedInformation} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Location.is(candidate.location) && Is.string(candidate.message);
    }
    DiagnosticRelatedInformation.is = is;
})(DiagnosticRelatedInformation || (DiagnosticRelatedInformation = {}));
var DiagnosticSeverity;
(function(DiagnosticSeverity) {
    /**
     * Reports an error.
     */ DiagnosticSeverity.Error = 1;
    /**
     * Reports a warning.
     */ DiagnosticSeverity.Warning = 2;
    /**
     * Reports an information.
     */ DiagnosticSeverity.Information = 3;
    /**
     * Reports a hint.
     */ DiagnosticSeverity.Hint = 4;
})(DiagnosticSeverity || (DiagnosticSeverity = {}));
var DiagnosticTag;
(function(DiagnosticTag) {
    /**
     * Unused or unnecessary code.
     *
     * Clients are allowed to render diagnostics with this tag faded out instead of having
     * an error squiggle.
     */ DiagnosticTag.Unnecessary = 1;
    /**
     * Deprecated or obsolete code.
     *
     * Clients are allowed to rendered diagnostics with this tag strike through.
     */ DiagnosticTag.Deprecated = 2;
})(DiagnosticTag || (DiagnosticTag = {}));
var CodeDescription;
(function(CodeDescription) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.href);
    }
    CodeDescription.is = is;
})(CodeDescription || (CodeDescription = {}));
var Diagnostic;
(function(Diagnostic) {
    /**
     * Creates a new Diagnostic literal.
     */ function create(range, message, severity, code, source, relatedInformation) {
        let result = {
            range,
            message
        };
        if (Is.defined(severity)) {
            result.severity = severity;
        }
        if (Is.defined(code)) {
            result.code = code;
        }
        if (Is.defined(source)) {
            result.source = source;
        }
        if (Is.defined(relatedInformation)) {
            result.relatedInformation = relatedInformation;
        }
        return result;
    }
    Diagnostic.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Diagnostic} interface.
     */ function is(value) {
        var _a;
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && Is.string(candidate.message) && (Is.number(candidate.severity) || Is.undefined(candidate.severity)) && (Is.integer(candidate.code) || Is.string(candidate.code) || Is.undefined(candidate.code)) && (Is.undefined(candidate.codeDescription) || Is.string((_a = candidate.codeDescription) === null || _a === void 0 ? void 0 : _a.href)) && (Is.string(candidate.source) || Is.undefined(candidate.source)) && (Is.undefined(candidate.relatedInformation) || Is.typedArray(candidate.relatedInformation, DiagnosticRelatedInformation.is));
    }
    Diagnostic.is = is;
})(Diagnostic || (Diagnostic = {}));
var Command;
(function(Command) {
    /**
     * Creates a new Command literal.
     */ function create(title, command, ...args) {
        let result = {
            title,
            command
        };
        if (Is.defined(args) && args.length > 0) {
            result.arguments = args;
        }
        return result;
    }
    Command.create = create;
    /**
     * Checks whether the given literal conforms to the {@link Command} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.title) && Is.string(candidate.command);
    }
    Command.is = is;
})(Command || (Command = {}));
var TextEdit;
(function(TextEdit) {
    /**
     * Creates a replace text edit.
     * @param range The range of text to be replaced.
     * @param newText The new text.
     */ function replace(range, newText) {
        return {
            range,
            newText
        };
    }
    TextEdit.replace = replace;
    /**
     * Creates an insert text edit.
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     */ function insert(position, newText) {
        return {
            range: {
                start: position,
                end: position
            },
            newText
        };
    }
    TextEdit.insert = insert;
    /**
     * Creates a delete text edit.
     * @param range The range of text to be deleted.
     */ function del(range) {
        return {
            range,
            newText: ''
        };
    }
    TextEdit.del = del;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.newText) && Range.is(candidate.range);
    }
    TextEdit.is = is;
})(TextEdit || (TextEdit = {}));
var ChangeAnnotation;
(function(ChangeAnnotation) {
    function create(label, needsConfirmation, description) {
        const result = {
            label
        };
        if (needsConfirmation !== undefined) {
            result.needsConfirmation = needsConfirmation;
        }
        if (description !== undefined) {
            result.description = description;
        }
        return result;
    }
    ChangeAnnotation.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Is.string(candidate.label) && (Is.boolean(candidate.needsConfirmation) || candidate.needsConfirmation === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
    }
    ChangeAnnotation.is = is;
})(ChangeAnnotation || (ChangeAnnotation = {}));
var ChangeAnnotationIdentifier;
(function(ChangeAnnotationIdentifier) {
    function is(value) {
        const candidate = value;
        return Is.string(candidate);
    }
    ChangeAnnotationIdentifier.is = is;
})(ChangeAnnotationIdentifier || (ChangeAnnotationIdentifier = {}));
var AnnotatedTextEdit;
(function(AnnotatedTextEdit) {
    /**
     * Creates an annotated replace text edit.
     *
     * @param range The range of text to be replaced.
     * @param newText The new text.
     * @param annotation The annotation.
     */ function replace(range, newText, annotation) {
        return {
            range,
            newText,
            annotationId: annotation
        };
    }
    AnnotatedTextEdit.replace = replace;
    /**
     * Creates an annotated insert text edit.
     *
     * @param position The position to insert the text at.
     * @param newText The text to be inserted.
     * @param annotation The annotation.
     */ function insert(position, newText, annotation) {
        return {
            range: {
                start: position,
                end: position
            },
            newText,
            annotationId: annotation
        };
    }
    AnnotatedTextEdit.insert = insert;
    /**
     * Creates an annotated delete text edit.
     *
     * @param range The range of text to be deleted.
     * @param annotation The annotation.
     */ function del(range, annotation) {
        return {
            range,
            newText: '',
            annotationId: annotation
        };
    }
    AnnotatedTextEdit.del = del;
    function is(value) {
        const candidate = value;
        return TextEdit.is(candidate) && (ChangeAnnotation.is(candidate.annotationId) || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    AnnotatedTextEdit.is = is;
})(AnnotatedTextEdit || (AnnotatedTextEdit = {}));
var TextDocumentEdit;
(function(TextDocumentEdit) {
    /**
     * Creates a new `TextDocumentEdit`
     */ function create(textDocument, edits) {
        return {
            textDocument,
            edits
        };
    }
    TextDocumentEdit.create = create;
    function is(value) {
        let candidate = value;
        return Is.defined(candidate) && OptionalVersionedTextDocumentIdentifier.is(candidate.textDocument) && Array.isArray(candidate.edits);
    }
    TextDocumentEdit.is = is;
})(TextDocumentEdit || (TextDocumentEdit = {}));
var CreateFile;
(function(CreateFile) {
    function create(uri, options, annotation) {
        let result = {
            kind: 'create',
            uri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    CreateFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'create' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    CreateFile.is = is;
})(CreateFile || (CreateFile = {}));
var RenameFile;
(function(RenameFile) {
    function create(oldUri, newUri, options, annotation) {
        let result = {
            kind: 'rename',
            oldUri,
            newUri
        };
        if (options !== undefined && (options.overwrite !== undefined || options.ignoreIfExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    RenameFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'rename' && Is.string(candidate.oldUri) && Is.string(candidate.newUri) && (candidate.options === undefined || (candidate.options.overwrite === undefined || Is.boolean(candidate.options.overwrite)) && (candidate.options.ignoreIfExists === undefined || Is.boolean(candidate.options.ignoreIfExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    RenameFile.is = is;
})(RenameFile || (RenameFile = {}));
var DeleteFile;
(function(DeleteFile) {
    function create(uri, options, annotation) {
        let result = {
            kind: 'delete',
            uri
        };
        if (options !== undefined && (options.recursive !== undefined || options.ignoreIfNotExists !== undefined)) {
            result.options = options;
        }
        if (annotation !== undefined) {
            result.annotationId = annotation;
        }
        return result;
    }
    DeleteFile.create = create;
    function is(value) {
        let candidate = value;
        return candidate && candidate.kind === 'delete' && Is.string(candidate.uri) && (candidate.options === undefined || (candidate.options.recursive === undefined || Is.boolean(candidate.options.recursive)) && (candidate.options.ignoreIfNotExists === undefined || Is.boolean(candidate.options.ignoreIfNotExists))) && (candidate.annotationId === undefined || ChangeAnnotationIdentifier.is(candidate.annotationId));
    }
    DeleteFile.is = is;
})(DeleteFile || (DeleteFile = {}));
var WorkspaceEdit;
(function(WorkspaceEdit) {
    function is(value) {
        let candidate = value;
        return candidate && (candidate.changes !== undefined || candidate.documentChanges !== undefined) && (candidate.documentChanges === undefined || candidate.documentChanges.every((change)=>{
            if (Is.string(change.kind)) {
                return CreateFile.is(change) || RenameFile.is(change) || DeleteFile.is(change);
            } else {
                return TextDocumentEdit.is(change);
            }
        }));
    }
    WorkspaceEdit.is = is;
})(WorkspaceEdit || (WorkspaceEdit = {}));
class TextEditChangeImpl {
    constructor(edits, changeAnnotations){
        this.edits = edits;
        this.changeAnnotations = changeAnnotations;
    }
    insert(position, newText, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.insert(position, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.insert(position, newText, annotation);
        } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.insert(position, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    replace(range, newText, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.replace(range, newText);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.replace(range, newText, annotation);
        } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.replace(range, newText, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    delete(range, annotation) {
        let edit;
        let id;
        if (annotation === undefined) {
            edit = TextEdit.del(range);
        } else if (ChangeAnnotationIdentifier.is(annotation)) {
            id = annotation;
            edit = AnnotatedTextEdit.del(range, annotation);
        } else {
            this.assertChangeAnnotations(this.changeAnnotations);
            id = this.changeAnnotations.manage(annotation);
            edit = AnnotatedTextEdit.del(range, id);
        }
        this.edits.push(edit);
        if (id !== undefined) {
            return id;
        }
    }
    add(edit) {
        this.edits.push(edit);
    }
    all() {
        return this.edits;
    }
    clear() {
        this.edits.splice(0, this.edits.length);
    }
    assertChangeAnnotations(value) {
        if (value === undefined) {
            throw new Error(`Text edit change is not configured to manage change annotations.`);
        }
    }
}
/**
 * A helper class
 */ class ChangeAnnotations {
    constructor(annotations){
        this._annotations = annotations === undefined ? Object.create(null) : annotations;
        this._counter = 0;
        this._size = 0;
    }
    all() {
        return this._annotations;
    }
    get size() {
        return this._size;
    }
    manage(idOrAnnotation, annotation) {
        let id;
        if (ChangeAnnotationIdentifier.is(idOrAnnotation)) {
            id = idOrAnnotation;
        } else {
            id = this.nextId();
            annotation = idOrAnnotation;
        }
        if (this._annotations[id] !== undefined) {
            throw new Error(`Id ${id} is already in use.`);
        }
        if (annotation === undefined) {
            throw new Error(`No annotation provided for id ${id}`);
        }
        this._annotations[id] = annotation;
        this._size++;
        return id;
    }
    nextId() {
        this._counter++;
        return this._counter.toString();
    }
}
class WorkspaceChange {
    constructor(workspaceEdit){
        this._textEditChanges = Object.create(null);
        if (workspaceEdit !== undefined) {
            this._workspaceEdit = workspaceEdit;
            if (workspaceEdit.documentChanges) {
                this._changeAnnotations = new ChangeAnnotations(workspaceEdit.changeAnnotations);
                workspaceEdit.changeAnnotations = this._changeAnnotations.all();
                workspaceEdit.documentChanges.forEach((change)=>{
                    if (TextDocumentEdit.is(change)) {
                        const textEditChange = new TextEditChangeImpl(change.edits, this._changeAnnotations);
                        this._textEditChanges[change.textDocument.uri] = textEditChange;
                    }
                });
            } else if (workspaceEdit.changes) {
                Object.keys(workspaceEdit.changes).forEach((key)=>{
                    const textEditChange = new TextEditChangeImpl(workspaceEdit.changes[key]);
                    this._textEditChanges[key] = textEditChange;
                });
            }
        } else {
            this._workspaceEdit = {};
        }
    }
    /**
     * Returns the underlying {@link WorkspaceEdit} literal
     * use to be returned from a workspace edit operation like rename.
     */ get edit() {
        this.initDocumentChanges();
        if (this._changeAnnotations !== undefined) {
            if (this._changeAnnotations.size === 0) {
                this._workspaceEdit.changeAnnotations = undefined;
            } else {
                this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
            }
        }
        return this._workspaceEdit;
    }
    getTextEditChange(key) {
        if (OptionalVersionedTextDocumentIdentifier.is(key)) {
            this.initDocumentChanges();
            if (this._workspaceEdit.documentChanges === undefined) {
                throw new Error('Workspace edit is not configured for document changes.');
            }
            const textDocument = {
                uri: key.uri,
                version: key.version
            };
            let result = this._textEditChanges[textDocument.uri];
            if (!result) {
                const edits = [];
                const textDocumentEdit = {
                    textDocument,
                    edits
                };
                this._workspaceEdit.documentChanges.push(textDocumentEdit);
                result = new TextEditChangeImpl(edits, this._changeAnnotations);
                this._textEditChanges[textDocument.uri] = result;
            }
            return result;
        } else {
            this.initChanges();
            if (this._workspaceEdit.changes === undefined) {
                throw new Error('Workspace edit is not configured for normal text edit changes.');
            }
            let result = this._textEditChanges[key];
            if (!result) {
                let edits = [];
                this._workspaceEdit.changes[key] = edits;
                result = new TextEditChangeImpl(edits);
                this._textEditChanges[key] = result;
            }
            return result;
        }
    }
    initDocumentChanges() {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._changeAnnotations = new ChangeAnnotations();
            this._workspaceEdit.documentChanges = [];
            this._workspaceEdit.changeAnnotations = this._changeAnnotations.all();
        }
    }
    initChanges() {
        if (this._workspaceEdit.documentChanges === undefined && this._workspaceEdit.changes === undefined) {
            this._workspaceEdit.changes = Object.create(null);
        }
    }
    createFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        } else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = CreateFile.create(uri, options);
        } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = CreateFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
    renameFile(oldUri, newUri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        } else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = RenameFile.create(oldUri, newUri, options);
        } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = RenameFile.create(oldUri, newUri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
    deleteFile(uri, optionsOrAnnotation, options) {
        this.initDocumentChanges();
        if (this._workspaceEdit.documentChanges === undefined) {
            throw new Error('Workspace edit is not configured for document changes.');
        }
        let annotation;
        if (ChangeAnnotation.is(optionsOrAnnotation) || ChangeAnnotationIdentifier.is(optionsOrAnnotation)) {
            annotation = optionsOrAnnotation;
        } else {
            options = optionsOrAnnotation;
        }
        let operation;
        let id;
        if (annotation === undefined) {
            operation = DeleteFile.create(uri, options);
        } else {
            id = ChangeAnnotationIdentifier.is(annotation) ? annotation : this._changeAnnotations.manage(annotation);
            operation = DeleteFile.create(uri, options, id);
        }
        this._workspaceEdit.documentChanges.push(operation);
        if (id !== undefined) {
            return id;
        }
    }
}
var TextDocumentIdentifier;
(function(TextDocumentIdentifier) {
    /**
     * Creates a new TextDocumentIdentifier literal.
     * @param uri The document's uri.
     */ function create(uri) {
        return {
            uri
        };
    }
    TextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentIdentifier} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri);
    }
    TextDocumentIdentifier.is = is;
})(TextDocumentIdentifier || (TextDocumentIdentifier = {}));
var VersionedTextDocumentIdentifier;
(function(VersionedTextDocumentIdentifier) {
    /**
     * Creates a new VersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
        return {
            uri,
            version
        };
    }
    VersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link VersionedTextDocumentIdentifier} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.integer(candidate.version);
    }
    VersionedTextDocumentIdentifier.is = is;
})(VersionedTextDocumentIdentifier || (VersionedTextDocumentIdentifier = {}));
var OptionalVersionedTextDocumentIdentifier;
(function(OptionalVersionedTextDocumentIdentifier) {
    /**
     * Creates a new OptionalVersionedTextDocumentIdentifier literal.
     * @param uri The document's uri.
     * @param version The document's version.
     */ function create(uri, version) {
        return {
            uri,
            version
        };
    }
    OptionalVersionedTextDocumentIdentifier.create = create;
    /**
     * Checks whether the given literal conforms to the {@link OptionalVersionedTextDocumentIdentifier} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (candidate.version === null || Is.integer(candidate.version));
    }
    OptionalVersionedTextDocumentIdentifier.is = is;
})(OptionalVersionedTextDocumentIdentifier || (OptionalVersionedTextDocumentIdentifier = {}));
var TextDocumentItem;
(function(TextDocumentItem) {
    /**
     * Creates a new TextDocumentItem literal.
     * @param uri The document's uri.
     * @param languageId The document's language identifier.
     * @param version The document's version number.
     * @param text The document's text.
     */ function create(uri, languageId, version, text) {
        return {
            uri,
            languageId,
            version,
            text
        };
    }
    TextDocumentItem.create = create;
    /**
     * Checks whether the given literal conforms to the {@link TextDocumentItem} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && Is.string(candidate.languageId) && Is.integer(candidate.version) && Is.string(candidate.text);
    }
    TextDocumentItem.is = is;
})(TextDocumentItem || (TextDocumentItem = {}));
var MarkupKind;
(function(MarkupKind) {
    /**
     * Plain text is supported as a content format
     */ MarkupKind.PlainText = 'plaintext';
    /**
     * Markdown is supported as a content format
     */ MarkupKind.Markdown = 'markdown';
    /**
     * Checks whether the given value is a value of the {@link MarkupKind} type.
     */ function is(value) {
        const candidate = value;
        return candidate === MarkupKind.PlainText || candidate === MarkupKind.Markdown;
    }
    MarkupKind.is = is;
})(MarkupKind || (MarkupKind = {}));
var MarkupContent;
(function(MarkupContent) {
    /**
     * Checks whether the given value conforms to the {@link MarkupContent} interface.
     */ function is(value) {
        const candidate = value;
        return Is.objectLiteral(value) && MarkupKind.is(candidate.kind) && Is.string(candidate.value);
    }
    MarkupContent.is = is;
})(MarkupContent || (MarkupContent = {}));
var CompletionItemKind;
(function(CompletionItemKind) {
    CompletionItemKind.Text = 1;
    CompletionItemKind.Method = 2;
    CompletionItemKind.Function = 3;
    CompletionItemKind.Constructor = 4;
    CompletionItemKind.Field = 5;
    CompletionItemKind.Variable = 6;
    CompletionItemKind.Class = 7;
    CompletionItemKind.Interface = 8;
    CompletionItemKind.Module = 9;
    CompletionItemKind.Property = 10;
    CompletionItemKind.Unit = 11;
    CompletionItemKind.Value = 12;
    CompletionItemKind.Enum = 13;
    CompletionItemKind.Keyword = 14;
    CompletionItemKind.Snippet = 15;
    CompletionItemKind.Color = 16;
    CompletionItemKind.File = 17;
    CompletionItemKind.Reference = 18;
    CompletionItemKind.Folder = 19;
    CompletionItemKind.EnumMember = 20;
    CompletionItemKind.Constant = 21;
    CompletionItemKind.Struct = 22;
    CompletionItemKind.Event = 23;
    CompletionItemKind.Operator = 24;
    CompletionItemKind.TypeParameter = 25;
})(CompletionItemKind || (CompletionItemKind = {}));
var InsertTextFormat;
(function(InsertTextFormat) {
    /**
     * The primary text to be inserted is treated as a plain string.
     */ InsertTextFormat.PlainText = 1;
    /**
     * The primary text to be inserted is treated as a snippet.
     *
     * A snippet can define tab stops and placeholders with `$1`, `$2`
     * and `${3:foo}`. `$0` defines the final tab stop, it defaults to
     * the end of the snippet. Placeholders with equal identifiers are linked,
     * that is typing in one will update others too.
     *
     * See also: https://microsoft.github.io/language-server-protocol/specifications/specification-current/#snippet_syntax
     */ InsertTextFormat.Snippet = 2;
})(InsertTextFormat || (InsertTextFormat = {}));
var CompletionItemTag;
(function(CompletionItemTag) {
    /**
     * Render a completion as obsolete, usually using a strike-out.
     */ CompletionItemTag.Deprecated = 1;
})(CompletionItemTag || (CompletionItemTag = {}));
var InsertReplaceEdit;
(function(InsertReplaceEdit) {
    /**
     * Creates a new insert / replace edit
     */ function create(newText, insert, replace) {
        return {
            newText,
            insert,
            replace
        };
    }
    InsertReplaceEdit.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InsertReplaceEdit} interface.
     */ function is(value) {
        const candidate = value;
        return candidate && Is.string(candidate.newText) && Range.is(candidate.insert) && Range.is(candidate.replace);
    }
    InsertReplaceEdit.is = is;
})(InsertReplaceEdit || (InsertReplaceEdit = {}));
var InsertTextMode;
(function(InsertTextMode) {
    /**
     * The insertion or replace strings is taken as it is. If the
     * value is multi line the lines below the cursor will be
     * inserted using the indentation defined in the string value.
     * The client will not apply any kind of adjustments to the
     * string.
     */ InsertTextMode.asIs = 1;
    /**
     * The editor adjusts leading whitespace of new lines so that
     * they match the indentation up to the cursor of the line for
     * which the item is accepted.
     *
     * Consider a line like this: <2tabs><cursor><3tabs>foo. Accepting a
     * multi line completion item is indented using 2 tabs and all
     * following lines inserted will be indented using 2 tabs as well.
     */ InsertTextMode.adjustIndentation = 2;
})(InsertTextMode || (InsertTextMode = {}));
var CompletionItemLabelDetails;
(function(CompletionItemLabelDetails) {
    function is(value) {
        const candidate = value;
        return candidate && (Is.string(candidate.detail) || candidate.detail === undefined) && (Is.string(candidate.description) || candidate.description === undefined);
    }
    CompletionItemLabelDetails.is = is;
})(CompletionItemLabelDetails || (CompletionItemLabelDetails = {}));
var CompletionItem;
(function(CompletionItem) {
    /**
     * Create a completion item and seed it with a label.
     * @param label The completion item's label
     */ function create(label) {
        return {
            label
        };
    }
    CompletionItem.create = create;
})(CompletionItem || (CompletionItem = {}));
var CompletionList;
(function(CompletionList) {
    /**
     * Creates a new completion list.
     *
     * @param items The completion items.
     * @param isIncomplete The list is not complete.
     */ function create(items, isIncomplete) {
        return {
            items: items ? items : [],
            isIncomplete: !!isIncomplete
        };
    }
    CompletionList.create = create;
})(CompletionList || (CompletionList = {}));
var MarkedString;
(function(MarkedString) {
    /**
     * Creates a marked string from plain text.
     *
     * @param plainText The plain text.
     */ function fromPlainText(plainText) {
        return plainText.replace(/[\\`*_{}[\]()#+\-.!]/g, '\\$&'); // escape markdown syntax tokens: http://daringfireball.net/projects/markdown/syntax#backslash
    }
    MarkedString.fromPlainText = fromPlainText;
    /**
     * Checks whether the given value conforms to the {@link MarkedString} type.
     */ function is(value) {
        const candidate = value;
        return Is.string(candidate) || Is.objectLiteral(candidate) && Is.string(candidate.language) && Is.string(candidate.value);
    }
    MarkedString.is = is;
})(MarkedString || (MarkedString = {}));
var Hover;
(function(Hover) {
    /**
     * Checks whether the given value conforms to the {@link Hover} interface.
     */ function is(value) {
        let candidate = value;
        return !!candidate && Is.objectLiteral(candidate) && (MarkupContent.is(candidate.contents) || MarkedString.is(candidate.contents) || Is.typedArray(candidate.contents, MarkedString.is)) && (value.range === undefined || Range.is(value.range));
    }
    Hover.is = is;
})(Hover || (Hover = {}));
var ParameterInformation;
(function(ParameterInformation) {
    /**
     * Creates a new parameter information literal.
     *
     * @param label A label string.
     * @param documentation A doc string.
     */ function create(label, documentation) {
        return documentation ? {
            label,
            documentation
        } : {
            label
        };
    }
    ParameterInformation.create = create;
})(ParameterInformation || (ParameterInformation = {}));
var SignatureInformation;
(function(SignatureInformation) {
    function create(label, documentation, ...parameters) {
        let result = {
            label
        };
        if (Is.defined(documentation)) {
            result.documentation = documentation;
        }
        if (Is.defined(parameters)) {
            result.parameters = parameters;
        } else {
            result.parameters = [];
        }
        return result;
    }
    SignatureInformation.create = create;
})(SignatureInformation || (SignatureInformation = {}));
var DocumentHighlightKind;
(function(DocumentHighlightKind) {
    /**
     * A textual occurrence.
     */ DocumentHighlightKind.Text = 1;
    /**
     * Read-access of a symbol, like reading a variable.
     */ DocumentHighlightKind.Read = 2;
    /**
     * Write-access of a symbol, like writing to a variable.
     */ DocumentHighlightKind.Write = 3;
})(DocumentHighlightKind || (DocumentHighlightKind = {}));
var DocumentHighlight;
(function(DocumentHighlight) {
    /**
     * Create a DocumentHighlight object.
     * @param range The range the highlight applies to.
     * @param kind The highlight kind
     */ function create(range, kind) {
        let result = {
            range
        };
        if (Is.number(kind)) {
            result.kind = kind;
        }
        return result;
    }
    DocumentHighlight.create = create;
})(DocumentHighlight || (DocumentHighlight = {}));
var SymbolKind;
(function(SymbolKind) {
    SymbolKind.File = 1;
    SymbolKind.Module = 2;
    SymbolKind.Namespace = 3;
    SymbolKind.Package = 4;
    SymbolKind.Class = 5;
    SymbolKind.Method = 6;
    SymbolKind.Property = 7;
    SymbolKind.Field = 8;
    SymbolKind.Constructor = 9;
    SymbolKind.Enum = 10;
    SymbolKind.Interface = 11;
    SymbolKind.Function = 12;
    SymbolKind.Variable = 13;
    SymbolKind.Constant = 14;
    SymbolKind.String = 15;
    SymbolKind.Number = 16;
    SymbolKind.Boolean = 17;
    SymbolKind.Array = 18;
    SymbolKind.Object = 19;
    SymbolKind.Key = 20;
    SymbolKind.Null = 21;
    SymbolKind.EnumMember = 22;
    SymbolKind.Struct = 23;
    SymbolKind.Event = 24;
    SymbolKind.Operator = 25;
    SymbolKind.TypeParameter = 26;
})(SymbolKind || (SymbolKind = {}));
var SymbolTag;
(function(SymbolTag) {
    /**
     * Render a symbol as obsolete, usually using a strike-out.
     */ SymbolTag.Deprecated = 1;
})(SymbolTag || (SymbolTag = {}));
var SymbolInformation;
(function(SymbolInformation) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the location of the symbol.
     * @param uri The resource of the location of symbol.
     * @param containerName The name of the symbol containing the symbol.
     */ function create(name, kind, range, uri, containerName) {
        let result = {
            name,
            kind,
            location: {
                uri,
                range
            }
        };
        if (containerName) {
            result.containerName = containerName;
        }
        return result;
    }
    SymbolInformation.create = create;
})(SymbolInformation || (SymbolInformation = {}));
var WorkspaceSymbol;
(function(WorkspaceSymbol) {
    /**
     * Create a new workspace symbol.
     *
     * @param name The name of the symbol.
     * @param kind The kind of the symbol.
     * @param uri The resource of the location of the symbol.
     * @param range An options range of the location.
     * @returns A WorkspaceSymbol.
     */ function create(name, kind, uri, range) {
        return range !== undefined ? {
            name,
            kind,
            location: {
                uri,
                range
            }
        } : {
            name,
            kind,
            location: {
                uri
            }
        };
    }
    WorkspaceSymbol.create = create;
})(WorkspaceSymbol || (WorkspaceSymbol = {}));
var DocumentSymbol;
(function(DocumentSymbol) {
    /**
     * Creates a new symbol information literal.
     *
     * @param name The name of the symbol.
     * @param detail The detail of the symbol.
     * @param kind The kind of the symbol.
     * @param range The range of the symbol.
     * @param selectionRange The selectionRange of the symbol.
     * @param children Children of the symbol.
     */ function create(name, detail, kind, range, selectionRange, children) {
        let result = {
            name,
            detail,
            kind,
            range,
            selectionRange
        };
        if (children !== undefined) {
            result.children = children;
        }
        return result;
    }
    DocumentSymbol.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentSymbol} interface.
     */ function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.name) && Is.number(candidate.kind) && Range.is(candidate.range) && Range.is(candidate.selectionRange) && (candidate.detail === undefined || Is.string(candidate.detail)) && (candidate.deprecated === undefined || Is.boolean(candidate.deprecated)) && (candidate.children === undefined || Array.isArray(candidate.children)) && (candidate.tags === undefined || Array.isArray(candidate.tags));
    }
    DocumentSymbol.is = is;
})(DocumentSymbol || (DocumentSymbol = {}));
var CodeActionKind;
(function(CodeActionKind) {
    /**
     * Empty kind.
     */ CodeActionKind.Empty = '';
    /**
     * Base kind for quickfix actions: 'quickfix'
     */ CodeActionKind.QuickFix = 'quickfix';
    /**
     * Base kind for refactoring actions: 'refactor'
     */ CodeActionKind.Refactor = 'refactor';
    /**
     * Base kind for refactoring extraction actions: 'refactor.extract'
     *
     * Example extract actions:
     *
     * - Extract method
     * - Extract function
     * - Extract variable
     * - Extract interface from class
     * - ...
     */ CodeActionKind.RefactorExtract = 'refactor.extract';
    /**
     * Base kind for refactoring inline actions: 'refactor.inline'
     *
     * Example inline actions:
     *
     * - Inline function
     * - Inline variable
     * - Inline constant
     * - ...
     */ CodeActionKind.RefactorInline = 'refactor.inline';
    /**
     * Base kind for refactoring rewrite actions: 'refactor.rewrite'
     *
     * Example rewrite actions:
     *
     * - Convert JavaScript function to class
     * - Add or remove parameter
     * - Encapsulate field
     * - Make method static
     * - Move method to base class
     * - ...
     */ CodeActionKind.RefactorRewrite = 'refactor.rewrite';
    /**
     * Base kind for source actions: `source`
     *
     * Source code actions apply to the entire file.
     */ CodeActionKind.Source = 'source';
    /**
     * Base kind for an organize imports source action: `source.organizeImports`
     */ CodeActionKind.SourceOrganizeImports = 'source.organizeImports';
    /**
     * Base kind for auto-fix source actions: `source.fixAll`.
     *
     * Fix all actions automatically fix errors that have a clear fix that do not require user input.
     * They should not suppress errors or perform unsafe fixes such as generating new types or classes.
     *
     * @since 3.15.0
     */ CodeActionKind.SourceFixAll = 'source.fixAll';
})(CodeActionKind || (CodeActionKind = {}));
var CodeActionTriggerKind;
(function(CodeActionTriggerKind) {
    /**
     * Code actions were explicitly requested by the user or by an extension.
     */ CodeActionTriggerKind.Invoked = 1;
    /**
     * Code actions were requested automatically.
     *
     * This typically happens when current selection in a file changes, but can
     * also be triggered when file content changes.
     */ CodeActionTriggerKind.Automatic = 2;
})(CodeActionTriggerKind || (CodeActionTriggerKind = {}));
var CodeActionContext;
(function(CodeActionContext) {
    /**
     * Creates a new CodeActionContext literal.
     */ function create(diagnostics, only, triggerKind) {
        let result = {
            diagnostics
        };
        if (only !== undefined && only !== null) {
            result.only = only;
        }
        if (triggerKind !== undefined && triggerKind !== null) {
            result.triggerKind = triggerKind;
        }
        return result;
    }
    CodeActionContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeActionContext} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.typedArray(candidate.diagnostics, Diagnostic.is) && (candidate.only === undefined || Is.typedArray(candidate.only, Is.string)) && (candidate.triggerKind === undefined || candidate.triggerKind === CodeActionTriggerKind.Invoked || candidate.triggerKind === CodeActionTriggerKind.Automatic);
    }
    CodeActionContext.is = is;
})(CodeActionContext || (CodeActionContext = {}));
var CodeAction;
(function(CodeAction) {
    function create(title, kindOrCommandOrEdit, kind) {
        let result = {
            title
        };
        let checkKind = true;
        if (typeof kindOrCommandOrEdit === 'string') {
            checkKind = false;
            result.kind = kindOrCommandOrEdit;
        } else if (Command.is(kindOrCommandOrEdit)) {
            result.command = kindOrCommandOrEdit;
        } else {
            result.edit = kindOrCommandOrEdit;
        }
        if (checkKind && kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    CodeAction.create = create;
    function is(value) {
        let candidate = value;
        return candidate && Is.string(candidate.title) && (candidate.diagnostics === undefined || Is.typedArray(candidate.diagnostics, Diagnostic.is)) && (candidate.kind === undefined || Is.string(candidate.kind)) && (candidate.edit !== undefined || candidate.command !== undefined) && (candidate.command === undefined || Command.is(candidate.command)) && (candidate.isPreferred === undefined || Is.boolean(candidate.isPreferred)) && (candidate.edit === undefined || WorkspaceEdit.is(candidate.edit));
    }
    CodeAction.is = is;
})(CodeAction || (CodeAction = {}));
var CodeLens;
(function(CodeLens) {
    /**
     * Creates a new CodeLens literal.
     */ function create(range, data) {
        let result = {
            range
        };
        if (Is.defined(data)) {
            result.data = data;
        }
        return result;
    }
    CodeLens.create = create;
    /**
     * Checks whether the given literal conforms to the {@link CodeLens} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.command) || Command.is(candidate.command));
    }
    CodeLens.is = is;
})(CodeLens || (CodeLens = {}));
var FormattingOptions;
(function(FormattingOptions) {
    /**
     * Creates a new FormattingOptions literal.
     */ function create(tabSize, insertSpaces) {
        return {
            tabSize,
            insertSpaces
        };
    }
    FormattingOptions.create = create;
    /**
     * Checks whether the given literal conforms to the {@link FormattingOptions} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.uinteger(candidate.tabSize) && Is.boolean(candidate.insertSpaces);
    }
    FormattingOptions.is = is;
})(FormattingOptions || (FormattingOptions = {}));
var DocumentLink;
(function(DocumentLink) {
    /**
     * Creates a new DocumentLink literal.
     */ function create(range, target, data) {
        return {
            range,
            target,
            data
        };
    }
    DocumentLink.create = create;
    /**
     * Checks whether the given literal conforms to the {@link DocumentLink} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Range.is(candidate.range) && (Is.undefined(candidate.target) || Is.string(candidate.target));
    }
    DocumentLink.is = is;
})(DocumentLink || (DocumentLink = {}));
var SelectionRange;
(function(SelectionRange) {
    /**
     * Creates a new SelectionRange
     * @param range the range.
     * @param parent an optional parent.
     */ function create(range, parent) {
        return {
            range,
            parent
        };
    }
    SelectionRange.create = create;
    function is(value) {
        let candidate = value;
        return Is.objectLiteral(candidate) && Range.is(candidate.range) && (candidate.parent === undefined || SelectionRange.is(candidate.parent));
    }
    SelectionRange.is = is;
})(SelectionRange || (SelectionRange = {}));
var SemanticTokenTypes;
(function(SemanticTokenTypes) {
    SemanticTokenTypes["namespace"] = "namespace";
    /**
     * Represents a generic type. Acts as a fallback for types which can't be mapped to
     * a specific type like class or enum.
     */ SemanticTokenTypes["type"] = "type";
    SemanticTokenTypes["class"] = "class";
    SemanticTokenTypes["enum"] = "enum";
    SemanticTokenTypes["interface"] = "interface";
    SemanticTokenTypes["struct"] = "struct";
    SemanticTokenTypes["typeParameter"] = "typeParameter";
    SemanticTokenTypes["parameter"] = "parameter";
    SemanticTokenTypes["variable"] = "variable";
    SemanticTokenTypes["property"] = "property";
    SemanticTokenTypes["enumMember"] = "enumMember";
    SemanticTokenTypes["event"] = "event";
    SemanticTokenTypes["function"] = "function";
    SemanticTokenTypes["method"] = "method";
    SemanticTokenTypes["macro"] = "macro";
    SemanticTokenTypes["keyword"] = "keyword";
    SemanticTokenTypes["modifier"] = "modifier";
    SemanticTokenTypes["comment"] = "comment";
    SemanticTokenTypes["string"] = "string";
    SemanticTokenTypes["number"] = "number";
    SemanticTokenTypes["regexp"] = "regexp";
    SemanticTokenTypes["operator"] = "operator";
    /**
     * @since 3.17.0
     */ SemanticTokenTypes["decorator"] = "decorator";
})(SemanticTokenTypes || (SemanticTokenTypes = {}));
var SemanticTokenModifiers;
(function(SemanticTokenModifiers) {
    SemanticTokenModifiers["declaration"] = "declaration";
    SemanticTokenModifiers["definition"] = "definition";
    SemanticTokenModifiers["readonly"] = "readonly";
    SemanticTokenModifiers["static"] = "static";
    SemanticTokenModifiers["deprecated"] = "deprecated";
    SemanticTokenModifiers["abstract"] = "abstract";
    SemanticTokenModifiers["async"] = "async";
    SemanticTokenModifiers["modification"] = "modification";
    SemanticTokenModifiers["documentation"] = "documentation";
    SemanticTokenModifiers["defaultLibrary"] = "defaultLibrary";
})(SemanticTokenModifiers || (SemanticTokenModifiers = {}));
var SemanticTokens;
(function(SemanticTokens) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.resultId === undefined || typeof candidate.resultId === 'string') && Array.isArray(candidate.data) && (candidate.data.length === 0 || typeof candidate.data[0] === 'number');
    }
    SemanticTokens.is = is;
})(SemanticTokens || (SemanticTokens = {}));
var InlineValueText;
(function(InlineValueText) {
    /**
     * Creates a new InlineValueText literal.
     */ function create(range, text) {
        return {
            range,
            text
        };
    }
    InlineValueText.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.string(candidate.text);
    }
    InlineValueText.is = is;
})(InlineValueText || (InlineValueText = {}));
var InlineValueVariableLookup;
(function(InlineValueVariableLookup) {
    /**
     * Creates a new InlineValueText literal.
     */ function create(range, variableName, caseSensitiveLookup) {
        return {
            range,
            variableName,
            caseSensitiveLookup
        };
    }
    InlineValueVariableLookup.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && Is.boolean(candidate.caseSensitiveLookup) && (Is.string(candidate.variableName) || candidate.variableName === undefined);
    }
    InlineValueVariableLookup.is = is;
})(InlineValueVariableLookup || (InlineValueVariableLookup = {}));
var InlineValueEvaluatableExpression;
(function(InlineValueEvaluatableExpression) {
    /**
     * Creates a new InlineValueEvaluatableExpression literal.
     */ function create(range, expression) {
        return {
            range,
            expression
        };
    }
    InlineValueEvaluatableExpression.create = create;
    function is(value) {
        const candidate = value;
        return candidate !== undefined && candidate !== null && Range.is(candidate.range) && (Is.string(candidate.expression) || candidate.expression === undefined);
    }
    InlineValueEvaluatableExpression.is = is;
})(InlineValueEvaluatableExpression || (InlineValueEvaluatableExpression = {}));
var InlineValueContext;
(function(InlineValueContext) {
    /**
     * Creates a new InlineValueContext literal.
     */ function create(frameId, stoppedLocation) {
        return {
            frameId,
            stoppedLocation
        };
    }
    InlineValueContext.create = create;
    /**
     * Checks whether the given literal conforms to the {@link InlineValueContext} interface.
     */ function is(value) {
        const candidate = value;
        return Is.defined(candidate) && Range.is(value.stoppedLocation);
    }
    InlineValueContext.is = is;
})(InlineValueContext || (InlineValueContext = {}));
var InlayHintKind;
(function(InlayHintKind) {
    /**
     * An inlay hint that for a type annotation.
     */ InlayHintKind.Type = 1;
    /**
     * An inlay hint that is for a parameter.
     */ InlayHintKind.Parameter = 2;
    function is(value) {
        return value === 1 || value === 2;
    }
    InlayHintKind.is = is;
})(InlayHintKind || (InlayHintKind = {}));
var InlayHintLabelPart;
(function(InlayHintLabelPart) {
    function create(value) {
        return {
            value
        };
    }
    InlayHintLabelPart.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.location === undefined || Location.is(candidate.location)) && (candidate.command === undefined || Command.is(candidate.command));
    }
    InlayHintLabelPart.is = is;
})(InlayHintLabelPart || (InlayHintLabelPart = {}));
var InlayHint;
(function(InlayHint) {
    function create(position, label, kind) {
        const result = {
            position,
            label
        };
        if (kind !== undefined) {
            result.kind = kind;
        }
        return result;
    }
    InlayHint.create = create;
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && Position.is(candidate.position) && (Is.string(candidate.label) || Is.typedArray(candidate.label, InlayHintLabelPart.is)) && (candidate.kind === undefined || InlayHintKind.is(candidate.kind)) && candidate.textEdits === undefined || Is.typedArray(candidate.textEdits, TextEdit.is) && (candidate.tooltip === undefined || Is.string(candidate.tooltip) || MarkupContent.is(candidate.tooltip)) && (candidate.paddingLeft === undefined || Is.boolean(candidate.paddingLeft)) && (candidate.paddingRight === undefined || Is.boolean(candidate.paddingRight));
    }
    InlayHint.is = is;
})(InlayHint || (InlayHint = {}));
var StringValue;
(function(StringValue) {
    function createSnippet(value) {
        return {
            kind: 'snippet',
            value
        };
    }
    StringValue.createSnippet = createSnippet;
})(StringValue || (StringValue = {}));
var InlineCompletionItem;
(function(InlineCompletionItem) {
    function create(insertText, filterText, range, command) {
        return {
            insertText,
            filterText,
            range,
            command
        };
    }
    InlineCompletionItem.create = create;
})(InlineCompletionItem || (InlineCompletionItem = {}));
var InlineCompletionList;
(function(InlineCompletionList) {
    function create(items) {
        return {
            items
        };
    }
    InlineCompletionList.create = create;
})(InlineCompletionList || (InlineCompletionList = {}));
var InlineCompletionTriggerKind;
(function(InlineCompletionTriggerKind) {
    /**
     * Completion was triggered explicitly by a user gesture.
     */ InlineCompletionTriggerKind.Invoked = 0;
    /**
     * Completion was triggered automatically while editing.
     */ InlineCompletionTriggerKind.Automatic = 1;
})(InlineCompletionTriggerKind || (InlineCompletionTriggerKind = {}));
var SelectedCompletionInfo;
(function(SelectedCompletionInfo) {
    function create(range, text) {
        return {
            range,
            text
        };
    }
    SelectedCompletionInfo.create = create;
})(SelectedCompletionInfo || (SelectedCompletionInfo = {}));
var InlineCompletionContext;
(function(InlineCompletionContext) {
    function create(triggerKind, selectedCompletionInfo) {
        return {
            triggerKind,
            selectedCompletionInfo
        };
    }
    InlineCompletionContext.create = create;
})(InlineCompletionContext || (InlineCompletionContext = {}));
var WorkspaceFolder;
(function(WorkspaceFolder) {
    function is(value) {
        const candidate = value;
        return Is.objectLiteral(candidate) && URI.is(candidate.uri) && Is.string(candidate.name);
    }
    WorkspaceFolder.is = is;
})(WorkspaceFolder || (WorkspaceFolder = {}));
const EOL = [
    '\n',
    '\r\n',
    '\r'
];
var TextDocument;
(function(TextDocument) {
    /**
     * Creates a new ITextDocument literal from the given uri and content.
     * @param uri The document's uri.
     * @param languageId The document's language Id.
     * @param version The document's version.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Checks whether the given literal conforms to the {@link ITextDocument} interface.
     */ function is(value) {
        let candidate = value;
        return Is.defined(candidate) && Is.string(candidate.uri) && (Is.undefined(candidate.languageId) || Is.string(candidate.languageId)) && Is.uinteger(candidate.lineCount) && Is.func(candidate.getText) && Is.func(candidate.positionAt) && Is.func(candidate.offsetAt) ? true : false;
    }
    TextDocument.is = is;
    function applyEdits(document, edits) {
        let text = document.getText();
        let sortedEdits = mergeSort(edits, (a, b)=>{
            let diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = text.length;
        for(let i = sortedEdits.length - 1; i >= 0; i--){
            let e = sortedEdits[i];
            let startOffset = document.offsetAt(e.range.start);
            let endOffset = document.offsetAt(e.range.end);
            if (endOffset <= lastModifiedOffset) {
                text = text.substring(0, startOffset) + e.newText + text.substring(endOffset, text.length);
            } else {
                throw new Error('Overlapping edit');
            }
            lastModifiedOffset = startOffset;
        }
        return text;
    }
    TextDocument.applyEdits = applyEdits;
    function mergeSort(data, compare) {
        if (data.length <= 1) {
            // sorted
            return data;
        }
        const p = data.length / 2 | 0;
        const left = data.slice(0, p);
        const right = data.slice(p);
        mergeSort(left, compare);
        mergeSort(right, compare);
        let leftIdx = 0;
        let rightIdx = 0;
        let i = 0;
        while(leftIdx < left.length && rightIdx < right.length){
            let ret = compare(left[leftIdx], right[rightIdx]);
            if (ret <= 0) {
                // smaller_equal -> take left to preserve order
                data[i++] = left[leftIdx++];
            } else {
                // greater -> take right
                data[i++] = right[rightIdx++];
            }
        }
        while(leftIdx < left.length){
            data[i++] = left[leftIdx++];
        }
        while(rightIdx < right.length){
            data[i++] = right[rightIdx++];
        }
        return data;
    }
})(TextDocument || (TextDocument = {}));
/**
 * @deprecated Use the text document from the new vscode-languageserver-textdocument package.
 */ class FullTextDocument {
    constructor(uri, languageId, version, content){
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            let start = this.offsetAt(range.start);
            let end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(event, version) {
        this._content = event.text;
        this._version = version;
        this._lineOffsets = undefined;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            let lineOffsets = [];
            let text = this._content;
            let isLineStart = true;
            for(let i = 0; i < text.length; i++){
                if (isLineStart) {
                    lineOffsets.push(i);
                    isLineStart = false;
                }
                let ch = text.charAt(i);
                isLineStart = ch === '\r' || ch === '\n';
                if (ch === '\r' && i + 1 < text.length && text.charAt(i + 1) === '\n') {
                    i++;
                }
            }
            if (isLineStart && text.length > 0) {
                lineOffsets.push(text.length);
            }
            this._lineOffsets = lineOffsets;
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        let lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return Position.create(0, offset);
        }
        while(low < high){
            let mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        let line = low - 1;
        return Position.create(line, offset - lineOffsets[line]);
    }
    offsetAt(position) {
        let lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        } else if (position.line < 0) {
            return 0;
        }
        let lineOffset = lineOffsets[position.line];
        let nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        return Math.max(Math.min(lineOffset + position.character, nextLineOffset), lineOffset);
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
}
var Is;
(function(Is) {
    const toString = Object.prototype.toString;
    function defined(value) {
        return typeof value !== 'undefined';
    }
    Is.defined = defined;
    function undefined1(value) {
        return typeof value === 'undefined';
    }
    Is.undefined = undefined1;
    function boolean(value) {
        return value === true || value === false;
    }
    Is.boolean = boolean;
    function string(value) {
        return toString.call(value) === '[object String]';
    }
    Is.string = string;
    function number(value) {
        return toString.call(value) === '[object Number]';
    }
    Is.number = number;
    function numberRange(value, min, max) {
        return toString.call(value) === '[object Number]' && min <= value && value <= max;
    }
    Is.numberRange = numberRange;
    function integer(value) {
        return toString.call(value) === '[object Number]' && -2147483648 <= value && value <= 2147483647;
    }
    Is.integer = integer;
    function uinteger(value) {
        return toString.call(value) === '[object Number]' && 0 <= value && value <= 2147483647;
    }
    Is.uinteger = uinteger;
    function func(value) {
        return toString.call(value) === '[object Function]';
    }
    Is.func = func;
    function objectLiteral(value) {
        // Strictly speaking class instances pass this check as well. Since the LSP
        // doesn't use classes we ignore this for now. If we do we need to add something
        // like this: `Object.getPrototypeOf(Object.getPrototypeOf(x)) === null`
        return value !== null && typeof value === 'object';
    }
    Is.objectLiteral = objectLiteral;
    function typedArray(value, check) {
        return Array.isArray(value) && value.every(check);
    }
    Is.typedArray = typedArray;
})(Is || (Is = {}));
}}),
"[project]/node_modules/vscode-jsonrpc/lib/common/ral.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports, "__esModule", {
    value: true
});
let _ral;
function RAL() {
    if (_ral === undefined) {
        throw new Error(`No runtime abstraction layer installed`);
    }
    return _ral;
}
(function(RAL) {
    function install(ral) {
        if (ral === undefined) {
            throw new Error(`No runtime abstraction layer provided`);
        }
        _ral = ral;
    }
    RAL.install = install;
})(RAL || (RAL = {}));
exports.default = RAL;
}}),
"[project]/node_modules/vscode-jsonrpc/lib/common/is.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.stringArray = exports.array = exports.func = exports.error = exports.number = exports.string = exports.boolean = void 0;
function boolean(value) {
    return value === true || value === false;
}
exports.boolean = boolean;
function string(value) {
    return typeof value === 'string' || value instanceof String;
}
exports.string = string;
function number(value) {
    return typeof value === 'number' || value instanceof Number;
}
exports.number = number;
function error(value) {
    return value instanceof Error;
}
exports.error = error;
function func(value) {
    return typeof value === 'function';
}
exports.func = func;
function array(value) {
    return Array.isArray(value);
}
exports.array = array;
function stringArray(value) {
    return array(value) && value.every((elem)=>string(elem));
}
exports.stringArray = stringArray;
}}),
"[project]/node_modules/vscode-jsonrpc/lib/common/events.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.Emitter = exports.Event = void 0;
const ral_1 = __turbopack_context__.r("[project]/node_modules/vscode-jsonrpc/lib/common/ral.js [app-ssr] (ecmascript)");
var Event;
(function(Event) {
    const _disposable = {
        dispose () {}
    };
    Event.None = function() {
        return _disposable;
    };
})(Event || (exports.Event = Event = {}));
class CallbackList {
    add(callback, context = null, bucket) {
        if (!this._callbacks) {
            this._callbacks = [];
            this._contexts = [];
        }
        this._callbacks.push(callback);
        this._contexts.push(context);
        if (Array.isArray(bucket)) {
            bucket.push({
                dispose: ()=>this.remove(callback, context)
            });
        }
    }
    remove(callback, context = null) {
        if (!this._callbacks) {
            return;
        }
        let foundCallbackWithDifferentContext = false;
        for(let i = 0, len = this._callbacks.length; i < len; i++){
            if (this._callbacks[i] === callback) {
                if (this._contexts[i] === context) {
                    // callback & context match => remove it
                    this._callbacks.splice(i, 1);
                    this._contexts.splice(i, 1);
                    return;
                } else {
                    foundCallbackWithDifferentContext = true;
                }
            }
        }
        if (foundCallbackWithDifferentContext) {
            throw new Error('When adding a listener with a context, you should remove it with the same context');
        }
    }
    invoke(...args) {
        if (!this._callbacks) {
            return [];
        }
        const ret = [], callbacks = this._callbacks.slice(0), contexts = this._contexts.slice(0);
        for(let i = 0, len = callbacks.length; i < len; i++){
            try {
                ret.push(callbacks[i].apply(contexts[i], args));
            } catch (e) {
                // eslint-disable-next-line no-console
                (0, ral_1.default)().console.error(e);
            }
        }
        return ret;
    }
    isEmpty() {
        return !this._callbacks || this._callbacks.length === 0;
    }
    dispose() {
        this._callbacks = undefined;
        this._contexts = undefined;
    }
}
class Emitter {
    constructor(_options){
        this._options = _options;
    }
    /**
     * For the public to allow to subscribe
     * to events from this Emitter
     */ get event() {
        if (!this._event) {
            this._event = (listener, thisArgs, disposables)=>{
                if (!this._callbacks) {
                    this._callbacks = new CallbackList();
                }
                if (this._options && this._options.onFirstListenerAdd && this._callbacks.isEmpty()) {
                    this._options.onFirstListenerAdd(this);
                }
                this._callbacks.add(listener, thisArgs);
                const result = {
                    dispose: ()=>{
                        if (!this._callbacks) {
                            // disposable is disposed after emitter is disposed.
                            return;
                        }
                        this._callbacks.remove(listener, thisArgs);
                        result.dispose = Emitter._noop;
                        if (this._options && this._options.onLastListenerRemove && this._callbacks.isEmpty()) {
                            this._options.onLastListenerRemove(this);
                        }
                    }
                };
                if (Array.isArray(disposables)) {
                    disposables.push(result);
                }
                return result;
            };
        }
        return this._event;
    }
    /**
     * To be kept private to fire an event to
     * subscribers
     */ fire(event) {
        if (this._callbacks) {
            this._callbacks.invoke.call(this._callbacks, event);
        }
    }
    dispose() {
        if (this._callbacks) {
            this._callbacks.dispose();
            this._callbacks = undefined;
        }
    }
}
exports.Emitter = Emitter;
Emitter._noop = function() {};
}}),
"[project]/node_modules/vscode-jsonrpc/lib/common/cancellation.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
"use strict";
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/ Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.CancellationTokenSource = exports.CancellationToken = void 0;
const ral_1 = __turbopack_context__.r("[project]/node_modules/vscode-jsonrpc/lib/common/ral.js [app-ssr] (ecmascript)");
const Is = __turbopack_context__.r("[project]/node_modules/vscode-jsonrpc/lib/common/is.js [app-ssr] (ecmascript)");
const events_1 = __turbopack_context__.r("[project]/node_modules/vscode-jsonrpc/lib/common/events.js [app-ssr] (ecmascript)");
var CancellationToken;
(function(CancellationToken) {
    CancellationToken.None = Object.freeze({
        isCancellationRequested: false,
        onCancellationRequested: events_1.Event.None
    });
    CancellationToken.Cancelled = Object.freeze({
        isCancellationRequested: true,
        onCancellationRequested: events_1.Event.None
    });
    function is(value) {
        const candidate = value;
        return candidate && (candidate === CancellationToken.None || candidate === CancellationToken.Cancelled || Is.boolean(candidate.isCancellationRequested) && !!candidate.onCancellationRequested);
    }
    CancellationToken.is = is;
})(CancellationToken || (exports.CancellationToken = CancellationToken = {}));
const shortcutEvent = Object.freeze(function(callback, context) {
    const handle = (0, ral_1.default)().timer.setTimeout(callback.bind(context), 0);
    return {
        dispose () {
            handle.dispose();
        }
    };
});
class MutableToken {
    constructor(){
        this._isCancelled = false;
    }
    cancel() {
        if (!this._isCancelled) {
            this._isCancelled = true;
            if (this._emitter) {
                this._emitter.fire(undefined);
                this.dispose();
            }
        }
    }
    get isCancellationRequested() {
        return this._isCancelled;
    }
    get onCancellationRequested() {
        if (this._isCancelled) {
            return shortcutEvent;
        }
        if (!this._emitter) {
            this._emitter = new events_1.Emitter();
        }
        return this._emitter.event;
    }
    dispose() {
        if (this._emitter) {
            this._emitter.dispose();
            this._emitter = undefined;
        }
    }
}
class CancellationTokenSource {
    get token() {
        if (!this._token) {
            // be lazy and create the token only when
            // actually needed
            this._token = new MutableToken();
        }
        return this._token;
    }
    cancel() {
        if (!this._token) {
            // save an object by returning the default
            // cancelled token when cancellation happens
            // before someone asks for the token
            this._token = CancellationToken.Cancelled;
        } else {
            this._token.cancel();
        }
    }
    dispose() {
        if (!this._token) {
            // ensure to initialize with an empty token if we had none
            this._token = CancellationToken.None;
        } else if (this._token instanceof MutableToken) {
            // actually dispose
            this._token.dispose();
        }
    }
}
exports.CancellationTokenSource = CancellationTokenSource;
}}),
"[project]/node_modules/vscode-languageserver-textdocument/lib/esm/main.js [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
/* --------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation. All rights reserved.
 * Licensed under the MIT License. See License.txt in the project root for license information.
 * ------------------------------------------------------------------------------------------ */ __turbopack_context__.s({
    "TextDocument": (()=>TextDocument)
});
'use strict';
class FullTextDocument {
    constructor(uri, languageId, version, content){
        this._uri = uri;
        this._languageId = languageId;
        this._version = version;
        this._content = content;
        this._lineOffsets = undefined;
    }
    get uri() {
        return this._uri;
    }
    get languageId() {
        return this._languageId;
    }
    get version() {
        return this._version;
    }
    getText(range) {
        if (range) {
            const start = this.offsetAt(range.start);
            const end = this.offsetAt(range.end);
            return this._content.substring(start, end);
        }
        return this._content;
    }
    update(changes, version) {
        for (const change of changes){
            if (FullTextDocument.isIncremental(change)) {
                // makes sure start is before end
                const range = getWellformedRange(change.range);
                // update content
                const startOffset = this.offsetAt(range.start);
                const endOffset = this.offsetAt(range.end);
                this._content = this._content.substring(0, startOffset) + change.text + this._content.substring(endOffset, this._content.length);
                // update the offsets
                const startLine = Math.max(range.start.line, 0);
                const endLine = Math.max(range.end.line, 0);
                let lineOffsets = this._lineOffsets;
                const addedLineOffsets = computeLineOffsets(change.text, false, startOffset);
                if (endLine - startLine === addedLineOffsets.length) {
                    for(let i = 0, len = addedLineOffsets.length; i < len; i++){
                        lineOffsets[i + startLine + 1] = addedLineOffsets[i];
                    }
                } else {
                    if (addedLineOffsets.length < 10000) {
                        lineOffsets.splice(startLine + 1, endLine - startLine, ...addedLineOffsets);
                    } else {
                        this._lineOffsets = lineOffsets = lineOffsets.slice(0, startLine + 1).concat(addedLineOffsets, lineOffsets.slice(endLine + 1));
                    }
                }
                const diff = change.text.length - (endOffset - startOffset);
                if (diff !== 0) {
                    for(let i = startLine + 1 + addedLineOffsets.length, len = lineOffsets.length; i < len; i++){
                        lineOffsets[i] = lineOffsets[i] + diff;
                    }
                }
            } else if (FullTextDocument.isFull(change)) {
                this._content = change.text;
                this._lineOffsets = undefined;
            } else {
                throw new Error('Unknown change event received');
            }
        }
        this._version = version;
    }
    getLineOffsets() {
        if (this._lineOffsets === undefined) {
            this._lineOffsets = computeLineOffsets(this._content, true);
        }
        return this._lineOffsets;
    }
    positionAt(offset) {
        offset = Math.max(Math.min(offset, this._content.length), 0);
        const lineOffsets = this.getLineOffsets();
        let low = 0, high = lineOffsets.length;
        if (high === 0) {
            return {
                line: 0,
                character: offset
            };
        }
        while(low < high){
            const mid = Math.floor((low + high) / 2);
            if (lineOffsets[mid] > offset) {
                high = mid;
            } else {
                low = mid + 1;
            }
        }
        // low is the least x for which the line offset is larger than the current offset
        // or array.length if no line offset is larger than the current offset
        const line = low - 1;
        offset = this.ensureBeforeEOL(offset, lineOffsets[line]);
        return {
            line,
            character: offset - lineOffsets[line]
        };
    }
    offsetAt(position) {
        const lineOffsets = this.getLineOffsets();
        if (position.line >= lineOffsets.length) {
            return this._content.length;
        } else if (position.line < 0) {
            return 0;
        }
        const lineOffset = lineOffsets[position.line];
        if (position.character <= 0) {
            return lineOffset;
        }
        const nextLineOffset = position.line + 1 < lineOffsets.length ? lineOffsets[position.line + 1] : this._content.length;
        const offset = Math.min(lineOffset + position.character, nextLineOffset);
        return this.ensureBeforeEOL(offset, lineOffset);
    }
    ensureBeforeEOL(offset, lineOffset) {
        while(offset > lineOffset && isEOL(this._content.charCodeAt(offset - 1))){
            offset--;
        }
        return offset;
    }
    get lineCount() {
        return this.getLineOffsets().length;
    }
    static isIncremental(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range !== undefined && (candidate.rangeLength === undefined || typeof candidate.rangeLength === 'number');
    }
    static isFull(event) {
        const candidate = event;
        return candidate !== undefined && candidate !== null && typeof candidate.text === 'string' && candidate.range === undefined && candidate.rangeLength === undefined;
    }
}
var TextDocument;
(function(TextDocument) {
    /**
     * Creates a new text document.
     *
     * @param uri The document's uri.
     * @param languageId  The document's language Id.
     * @param version The document's initial version number.
     * @param content The document's content.
     */ function create(uri, languageId, version, content) {
        return new FullTextDocument(uri, languageId, version, content);
    }
    TextDocument.create = create;
    /**
     * Updates a TextDocument by modifying its content.
     *
     * @param document the document to update. Only documents created by TextDocument.create are valid inputs.
     * @param changes the changes to apply to the document.
     * @param version the changes version for the document.
     * @returns The updated TextDocument. Note: That's the same document instance passed in as first parameter.
     *
     */ function update(document, changes, version) {
        if (document instanceof FullTextDocument) {
            document.update(changes, version);
            return document;
        } else {
            throw new Error('TextDocument.update: document must be created by TextDocument.create');
        }
    }
    TextDocument.update = update;
    function applyEdits(document, edits) {
        const text = document.getText();
        const sortedEdits = mergeSort(edits.map(getWellformedEdit), (a, b)=>{
            const diff = a.range.start.line - b.range.start.line;
            if (diff === 0) {
                return a.range.start.character - b.range.start.character;
            }
            return diff;
        });
        let lastModifiedOffset = 0;
        const spans = [];
        for (const e of sortedEdits){
            const startOffset = document.offsetAt(e.range.start);
            if (startOffset < lastModifiedOffset) {
                throw new Error('Overlapping edit');
            } else if (startOffset > lastModifiedOffset) {
                spans.push(text.substring(lastModifiedOffset, startOffset));
            }
            if (e.newText.length) {
                spans.push(e.newText);
            }
            lastModifiedOffset = document.offsetAt(e.range.end);
        }
        spans.push(text.substr(lastModifiedOffset));
        return spans.join('');
    }
    TextDocument.applyEdits = applyEdits;
})(TextDocument || (TextDocument = {}));
function mergeSort(data, compare) {
    if (data.length <= 1) {
        // sorted
        return data;
    }
    const p = data.length / 2 | 0;
    const left = data.slice(0, p);
    const right = data.slice(p);
    mergeSort(left, compare);
    mergeSort(right, compare);
    let leftIdx = 0;
    let rightIdx = 0;
    let i = 0;
    while(leftIdx < left.length && rightIdx < right.length){
        const ret = compare(left[leftIdx], right[rightIdx]);
        if (ret <= 0) {
            // smaller_equal -> take left to preserve order
            data[i++] = left[leftIdx++];
        } else {
            // greater -> take right
            data[i++] = right[rightIdx++];
        }
    }
    while(leftIdx < left.length){
        data[i++] = left[leftIdx++];
    }
    while(rightIdx < right.length){
        data[i++] = right[rightIdx++];
    }
    return data;
}
function computeLineOffsets(text, isAtLineStart, textOffset = 0) {
    const result = isAtLineStart ? [
        textOffset
    ] : [];
    for(let i = 0; i < text.length; i++){
        const ch = text.charCodeAt(i);
        if (isEOL(ch)) {
            if (ch === 13 /* CharCode.CarriageReturn */  && i + 1 < text.length && text.charCodeAt(i + 1) === 10 /* CharCode.LineFeed */ ) {
                i++;
            }
            result.push(textOffset + i + 1);
        }
    }
    return result;
}
function isEOL(char) {
    return char === 13 /* CharCode.CarriageReturn */  || char === 10 /* CharCode.LineFeed */ ;
}
function getWellformedRange(range) {
    const start = range.start;
    const end = range.end;
    if (start.line > end.line || start.line === end.line && start.character > end.character) {
        return {
            start: end,
            end: start
        };
    }
    return range;
}
function getWellformedEdit(textEdit) {
    const range = getWellformedRange(textEdit.range);
    if (range !== textEdit.range) {
        return {
            newText: textEdit.newText,
            range
        };
    }
    return textEdit;
}
}}),
"[project]/node_modules/vscode-uri/lib/esm/index.mjs [app-ssr] (ecmascript)": ((__turbopack_context__) => {
"use strict";

var { g: global, __dirname } = __turbopack_context__;
{
__turbopack_context__.s({
    "URI": (()=>URI),
    "Utils": (()=>Utils)
});
var LIB;
(()=>{
    "use strict";
    var t = {
        470: (t)=>{
            function e(t) {
                if ("string" != typeof t) throw new TypeError("Path must be a string. Received " + JSON.stringify(t));
            }
            function r(t, e) {
                for(var r, n = "", i = 0, o = -1, s = 0, h = 0; h <= t.length; ++h){
                    if (h < t.length) r = t.charCodeAt(h);
                    else {
                        if (47 === r) break;
                        r = 47;
                    }
                    if (47 === r) {
                        if (o === h - 1 || 1 === s) ;
                        else if (o !== h - 1 && 2 === s) {
                            if (n.length < 2 || 2 !== i || 46 !== n.charCodeAt(n.length - 1) || 46 !== n.charCodeAt(n.length - 2)) {
                                if (n.length > 2) {
                                    var a = n.lastIndexOf("/");
                                    if (a !== n.length - 1) {
                                        -1 === a ? (n = "", i = 0) : i = (n = n.slice(0, a)).length - 1 - n.lastIndexOf("/"), o = h, s = 0;
                                        continue;
                                    }
                                } else if (2 === n.length || 1 === n.length) {
                                    n = "", i = 0, o = h, s = 0;
                                    continue;
                                }
                            }
                            e && (n.length > 0 ? n += "/.." : n = "..", i = 2);
                        } else n.length > 0 ? n += "/" + t.slice(o + 1, h) : n = t.slice(o + 1, h), i = h - o - 1;
                        o = h, s = 0;
                    } else 46 === r && -1 !== s ? ++s : s = -1;
                }
                return n;
            }
            var n = {
                resolve: function() {
                    for(var t, n = "", i = !1, o = arguments.length - 1; o >= -1 && !i; o--){
                        var s;
                        o >= 0 ? s = arguments[o] : (void 0 === t && (t = process.cwd()), s = t), e(s), 0 !== s.length && (n = s + "/" + n, i = 47 === s.charCodeAt(0));
                    }
                    return n = r(n, !i), i ? n.length > 0 ? "/" + n : "/" : n.length > 0 ? n : ".";
                },
                normalize: function(t) {
                    if (e(t), 0 === t.length) return ".";
                    var n = 47 === t.charCodeAt(0), i = 47 === t.charCodeAt(t.length - 1);
                    return 0 !== (t = r(t, !n)).length || n || (t = "."), t.length > 0 && i && (t += "/"), n ? "/" + t : t;
                },
                isAbsolute: function(t) {
                    return e(t), t.length > 0 && 47 === t.charCodeAt(0);
                },
                join: function() {
                    if (0 === arguments.length) return ".";
                    for(var t, r = 0; r < arguments.length; ++r){
                        var i = arguments[r];
                        e(i), i.length > 0 && (void 0 === t ? t = i : t += "/" + i);
                    }
                    return void 0 === t ? "." : n.normalize(t);
                },
                relative: function(t, r) {
                    if (e(t), e(r), t === r) return "";
                    if ((t = n.resolve(t)) === (r = n.resolve(r))) return "";
                    for(var i = 1; i < t.length && 47 === t.charCodeAt(i); ++i);
                    for(var o = t.length, s = o - i, h = 1; h < r.length && 47 === r.charCodeAt(h); ++h);
                    for(var a = r.length - h, c = s < a ? s : a, f = -1, u = 0; u <= c; ++u){
                        if (u === c) {
                            if (a > c) {
                                if (47 === r.charCodeAt(h + u)) return r.slice(h + u + 1);
                                if (0 === u) return r.slice(h + u);
                            } else s > c && (47 === t.charCodeAt(i + u) ? f = u : 0 === u && (f = 0));
                            break;
                        }
                        var l = t.charCodeAt(i + u);
                        if (l !== r.charCodeAt(h + u)) break;
                        47 === l && (f = u);
                    }
                    var g = "";
                    for(u = i + f + 1; u <= o; ++u)u !== o && 47 !== t.charCodeAt(u) || (0 === g.length ? g += ".." : g += "/..");
                    return g.length > 0 ? g + r.slice(h + f) : (h += f, 47 === r.charCodeAt(h) && ++h, r.slice(h));
                },
                _makeLong: function(t) {
                    return t;
                },
                dirname: function(t) {
                    if (e(t), 0 === t.length) return ".";
                    for(var r = t.charCodeAt(0), n = 47 === r, i = -1, o = !0, s = t.length - 1; s >= 1; --s)if (47 === (r = t.charCodeAt(s))) {
                        if (!o) {
                            i = s;
                            break;
                        }
                    } else o = !1;
                    return -1 === i ? n ? "/" : "." : n && 1 === i ? "//" : t.slice(0, i);
                },
                basename: function(t, r) {
                    if (void 0 !== r && "string" != typeof r) throw new TypeError('"ext" argument must be a string');
                    e(t);
                    var n, i = 0, o = -1, s = !0;
                    if (void 0 !== r && r.length > 0 && r.length <= t.length) {
                        if (r.length === t.length && r === t) return "";
                        var h = r.length - 1, a = -1;
                        for(n = t.length - 1; n >= 0; --n){
                            var c = t.charCodeAt(n);
                            if (47 === c) {
                                if (!s) {
                                    i = n + 1;
                                    break;
                                }
                            } else -1 === a && (s = !1, a = n + 1), h >= 0 && (c === r.charCodeAt(h) ? -1 == --h && (o = n) : (h = -1, o = a));
                        }
                        return i === o ? o = a : -1 === o && (o = t.length), t.slice(i, o);
                    }
                    for(n = t.length - 1; n >= 0; --n)if (47 === t.charCodeAt(n)) {
                        if (!s) {
                            i = n + 1;
                            break;
                        }
                    } else -1 === o && (s = !1, o = n + 1);
                    return -1 === o ? "" : t.slice(i, o);
                },
                extname: function(t) {
                    e(t);
                    for(var r = -1, n = 0, i = -1, o = !0, s = 0, h = t.length - 1; h >= 0; --h){
                        var a = t.charCodeAt(h);
                        if (47 !== a) -1 === i && (o = !1, i = h + 1), 46 === a ? -1 === r ? r = h : 1 !== s && (s = 1) : -1 !== r && (s = -1);
                        else if (!o) {
                            n = h + 1;
                            break;
                        }
                    }
                    return -1 === r || -1 === i || 0 === s || 1 === s && r === i - 1 && r === n + 1 ? "" : t.slice(r, i);
                },
                format: function(t) {
                    if (null === t || "object" != typeof t) throw new TypeError('The "pathObject" argument must be of type Object. Received type ' + typeof t);
                    return function(t, e) {
                        var r = e.dir || e.root, n = e.base || (e.name || "") + (e.ext || "");
                        return r ? r === e.root ? r + n : r + "/" + n : n;
                    }(0, t);
                },
                parse: function(t) {
                    e(t);
                    var r = {
                        root: "",
                        dir: "",
                        base: "",
                        ext: "",
                        name: ""
                    };
                    if (0 === t.length) return r;
                    var n, i = t.charCodeAt(0), o = 47 === i;
                    o ? (r.root = "/", n = 1) : n = 0;
                    for(var s = -1, h = 0, a = -1, c = !0, f = t.length - 1, u = 0; f >= n; --f)if (47 !== (i = t.charCodeAt(f))) -1 === a && (c = !1, a = f + 1), 46 === i ? -1 === s ? s = f : 1 !== u && (u = 1) : -1 !== s && (u = -1);
                    else if (!c) {
                        h = f + 1;
                        break;
                    }
                    return -1 === s || -1 === a || 0 === u || 1 === u && s === a - 1 && s === h + 1 ? -1 !== a && (r.base = r.name = 0 === h && o ? t.slice(1, a) : t.slice(h, a)) : (0 === h && o ? (r.name = t.slice(1, s), r.base = t.slice(1, a)) : (r.name = t.slice(h, s), r.base = t.slice(h, a)), r.ext = t.slice(s, a)), h > 0 ? r.dir = t.slice(0, h - 1) : o && (r.dir = "/"), r;
                },
                sep: "/",
                delimiter: ":",
                win32: null,
                posix: null
            };
            n.posix = n, t.exports = n;
        }
    }, e = {};
    function r(n) {
        var i = e[n];
        if (void 0 !== i) return i.exports;
        var o = e[n] = {
            exports: {}
        };
        return t[n](o, o.exports, r), o.exports;
    }
    r.d = (t, e)=>{
        for(var n in e)r.o(e, n) && !r.o(t, n) && Object.defineProperty(t, n, {
            enumerable: !0,
            get: e[n]
        });
    }, r.o = (t, e)=>Object.prototype.hasOwnProperty.call(t, e), r.r = (t)=>{
        "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, {
            value: "Module"
        }), Object.defineProperty(t, "__esModule", {
            value: !0
        });
    };
    var n = {};
    (()=>{
        let t;
        if (r.r(n), r.d(n, {
            URI: ()=>f,
            Utils: ()=>P
        }), "object" == typeof process) t = "win32" === process.platform;
        else if ("object" == typeof navigator) {
            let e = navigator.userAgent;
            t = e.indexOf("Windows") >= 0;
        }
        const e = /^\w[\w\d+.-]*$/, i = /^\//, o = /^\/\//;
        function s(t, r) {
            if (!t.scheme && r) throw new Error(`[UriError]: Scheme is missing: {scheme: "", authority: "${t.authority}", path: "${t.path}", query: "${t.query}", fragment: "${t.fragment}"}`);
            if (t.scheme && !e.test(t.scheme)) throw new Error("[UriError]: Scheme contains illegal characters.");
            if (t.path) {
                if (t.authority) {
                    if (!i.test(t.path)) throw new Error('[UriError]: If a URI contains an authority component, then the path component must either be empty or begin with a slash ("/") character');
                } else if (o.test(t.path)) throw new Error('[UriError]: If a URI does not contain an authority component, then the path cannot begin with two slash characters ("//")');
            }
        }
        const h = "", a = "/", c = /^(([^:/?#]+?):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?/;
        class f {
            static isUri(t) {
                return t instanceof f || !!t && "string" == typeof t.authority && "string" == typeof t.fragment && "string" == typeof t.path && "string" == typeof t.query && "string" == typeof t.scheme && "string" == typeof t.fsPath && "function" == typeof t.with && "function" == typeof t.toString;
            }
            scheme;
            authority;
            path;
            query;
            fragment;
            constructor(t, e, r, n, i, o = !1){
                "object" == typeof t ? (this.scheme = t.scheme || h, this.authority = t.authority || h, this.path = t.path || h, this.query = t.query || h, this.fragment = t.fragment || h) : (this.scheme = function(t, e) {
                    return t || e ? t : "file";
                }(t, o), this.authority = e || h, this.path = function(t, e) {
                    switch(t){
                        case "https":
                        case "http":
                        case "file":
                            e ? e[0] !== a && (e = a + e) : e = a;
                    }
                    return e;
                }(this.scheme, r || h), this.query = n || h, this.fragment = i || h, s(this, o));
            }
            get fsPath() {
                return m(this, !1);
            }
            with(t) {
                if (!t) return this;
                let { scheme: e, authority: r, path: n, query: i, fragment: o } = t;
                return void 0 === e ? e = this.scheme : null === e && (e = h), void 0 === r ? r = this.authority : null === r && (r = h), void 0 === n ? n = this.path : null === n && (n = h), void 0 === i ? i = this.query : null === i && (i = h), void 0 === o ? o = this.fragment : null === o && (o = h), e === this.scheme && r === this.authority && n === this.path && i === this.query && o === this.fragment ? this : new l(e, r, n, i, o);
            }
            static parse(t, e = !1) {
                const r = c.exec(t);
                return r ? new l(r[2] || h, C(r[4] || h), C(r[5] || h), C(r[7] || h), C(r[9] || h), e) : new l(h, h, h, h, h);
            }
            static file(e) {
                let r = h;
                if (t && (e = e.replace(/\\/g, a)), e[0] === a && e[1] === a) {
                    const t = e.indexOf(a, 2);
                    -1 === t ? (r = e.substring(2), e = a) : (r = e.substring(2, t), e = e.substring(t) || a);
                }
                return new l("file", r, e, h, h);
            }
            static from(t) {
                const e = new l(t.scheme, t.authority, t.path, t.query, t.fragment);
                return s(e, !0), e;
            }
            toString(t = !1) {
                return y(this, t);
            }
            toJSON() {
                return this;
            }
            static revive(t) {
                if (t) {
                    if (t instanceof f) return t;
                    {
                        const e = new l(t);
                        return e._formatted = t.external, e._fsPath = t._sep === u ? t.fsPath : null, e;
                    }
                }
                return t;
            }
        }
        const u = t ? 1 : void 0;
        class l extends f {
            _formatted = null;
            _fsPath = null;
            get fsPath() {
                return this._fsPath || (this._fsPath = m(this, !1)), this._fsPath;
            }
            toString(t = !1) {
                return t ? y(this, !0) : (this._formatted || (this._formatted = y(this, !1)), this._formatted);
            }
            toJSON() {
                const t = {
                    $mid: 1
                };
                return this._fsPath && (t.fsPath = this._fsPath, t._sep = u), this._formatted && (t.external = this._formatted), this.path && (t.path = this.path), this.scheme && (t.scheme = this.scheme), this.authority && (t.authority = this.authority), this.query && (t.query = this.query), this.fragment && (t.fragment = this.fragment), t;
            }
        }
        const g = {
            58: "%3A",
            47: "%2F",
            63: "%3F",
            35: "%23",
            91: "%5B",
            93: "%5D",
            64: "%40",
            33: "%21",
            36: "%24",
            38: "%26",
            39: "%27",
            40: "%28",
            41: "%29",
            42: "%2A",
            43: "%2B",
            44: "%2C",
            59: "%3B",
            61: "%3D",
            32: "%20"
        };
        function d(t, e, r) {
            let n, i = -1;
            for(let o = 0; o < t.length; o++){
                const s = t.charCodeAt(o);
                if (s >= 97 && s <= 122 || s >= 65 && s <= 90 || s >= 48 && s <= 57 || 45 === s || 46 === s || 95 === s || 126 === s || e && 47 === s || r && 91 === s || r && 93 === s || r && 58 === s) -1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), void 0 !== n && (n += t.charAt(o));
                else {
                    void 0 === n && (n = t.substr(0, o));
                    const e = g[s];
                    void 0 !== e ? (-1 !== i && (n += encodeURIComponent(t.substring(i, o)), i = -1), n += e) : -1 === i && (i = o);
                }
            }
            return -1 !== i && (n += encodeURIComponent(t.substring(i))), void 0 !== n ? n : t;
        }
        function p(t) {
            let e;
            for(let r = 0; r < t.length; r++){
                const n = t.charCodeAt(r);
                35 === n || 63 === n ? (void 0 === e && (e = t.substr(0, r)), e += g[n]) : void 0 !== e && (e += t[r]);
            }
            return void 0 !== e ? e : t;
        }
        function m(e, r) {
            let n;
            return n = e.authority && e.path.length > 1 && "file" === e.scheme ? `//${e.authority}${e.path}` : 47 === e.path.charCodeAt(0) && (e.path.charCodeAt(1) >= 65 && e.path.charCodeAt(1) <= 90 || e.path.charCodeAt(1) >= 97 && e.path.charCodeAt(1) <= 122) && 58 === e.path.charCodeAt(2) ? r ? e.path.substr(1) : e.path[1].toLowerCase() + e.path.substr(2) : e.path, t && (n = n.replace(/\//g, "\\")), n;
        }
        function y(t, e) {
            const r = e ? p : d;
            let n = "", { scheme: i, authority: o, path: s, query: h, fragment: c } = t;
            if (i && (n += i, n += ":"), (o || "file" === i) && (n += a, n += a), o) {
                let t = o.indexOf("@");
                if (-1 !== t) {
                    const e = o.substr(0, t);
                    o = o.substr(t + 1), t = e.lastIndexOf(":"), -1 === t ? n += r(e, !1, !1) : (n += r(e.substr(0, t), !1, !1), n += ":", n += r(e.substr(t + 1), !1, !0)), n += "@";
                }
                o = o.toLowerCase(), t = o.lastIndexOf(":"), -1 === t ? n += r(o, !1, !0) : (n += r(o.substr(0, t), !1, !0), n += o.substr(t));
            }
            if (s) {
                if (s.length >= 3 && 47 === s.charCodeAt(0) && 58 === s.charCodeAt(2)) {
                    const t = s.charCodeAt(1);
                    t >= 65 && t <= 90 && (s = `/${String.fromCharCode(t + 32)}:${s.substr(3)}`);
                } else if (s.length >= 2 && 58 === s.charCodeAt(1)) {
                    const t = s.charCodeAt(0);
                    t >= 65 && t <= 90 && (s = `${String.fromCharCode(t + 32)}:${s.substr(2)}`);
                }
                n += r(s, !0, !1);
            }
            return h && (n += "?", n += r(h, !1, !1)), c && (n += "#", n += e ? c : d(c, !1, !1)), n;
        }
        function v(t) {
            try {
                return decodeURIComponent(t);
            } catch  {
                return t.length > 3 ? t.substr(0, 3) + v(t.substr(3)) : t;
            }
        }
        const b = /(%[0-9A-Za-z][0-9A-Za-z])+/g;
        function C(t) {
            return t.match(b) ? t.replace(b, (t)=>v(t)) : t;
        }
        var A = r(470);
        const w = A.posix || A, x = "/";
        var P;
        !function(t) {
            t.joinPath = function(t, ...e) {
                return t.with({
                    path: w.join(t.path, ...e)
                });
            }, t.resolvePath = function(t, ...e) {
                let r = t.path, n = !1;
                r[0] !== x && (r = x + r, n = !0);
                let i = w.resolve(r, ...e);
                return n && i[0] === x && !t.authority && (i = i.substring(1)), t.with({
                    path: i
                });
            }, t.dirname = function(t) {
                if (0 === t.path.length || t.path === x) return t;
                let e = w.dirname(t.path);
                return 1 === e.length && 46 === e.charCodeAt(0) && (e = ""), t.with({
                    path: e
                });
            }, t.basename = function(t) {
                return w.basename(t.path);
            }, t.extname = function(t) {
                return w.extname(t.path);
            };
        }(P || (P = {}));
    })(), LIB = n;
})();
const { URI, Utils } = LIB; //# sourceMappingURL=index.mjs.map
}}),
"[project]/node_modules/cytoscape-fcose/cytoscape-fcose.js [app-ssr] (ecmascript)": (function(__turbopack_context__) {

var { g: global, __dirname, m: module, e: exports } = __turbopack_context__;
{
(function webpackUniversalModuleDefinition(root, factory) {
    if ("TURBOPACK compile-time truthy", 1) module.exports = factory(__turbopack_context__.r("[project]/node_modules/cytoscape-fcose/node_modules/cose-base/cose-base.js [app-ssr] (ecmascript)"));
    else {
        "TURBOPACK unreachable";
    }
})(this, function(__WEBPACK_EXTERNAL_MODULE__140__) {
    return /******/ (()=>{
        /******/ "use strict";
        /******/ var __webpack_modules__ = {
            /***/ 658: (module1)=>{
                // Simple, internal Object.assign() polyfill for options objects etc.
                module1.exports = Object.assign != null ? Object.assign.bind(Object) : function(tgt) {
                    for(var _len = arguments.length, srcs = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++){
                        srcs[_key - 1] = arguments[_key];
                    }
                    srcs.forEach(function(src) {
                        Object.keys(src).forEach(function(k) {
                            return tgt[k] = src[k];
                        });
                    });
                    return tgt;
                };
            /***/ },
            /***/ 548: (module1, __unused_webpack_exports, __webpack_require__)=>{
                var _slicedToArray = function() {
                    function sliceIterator(arr, i) {
                        var _arr = [];
                        var _n = true;
                        var _d = false;
                        var _e = undefined;
                        try {
                            for(var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true){
                                _arr.push(_s.value);
                                if (i && _arr.length === i) break;
                            }
                        } catch (err) {
                            _d = true;
                            _e = err;
                        } finally{
                            try {
                                if (!_n && _i["return"]) _i["return"]();
                            } finally{
                                if (_d) throw _e;
                            }
                        }
                        return _arr;
                    }
                    return function(arr, i) {
                        if (Array.isArray(arr)) {
                            return arr;
                        } else if (Symbol.iterator in Object(arr)) {
                            return sliceIterator(arr, i);
                        } else {
                            throw new TypeError("Invalid attempt to destructure non-iterable instance");
                        }
                    };
                }();
                /*
 * Auxiliary functions
 */ var LinkedList = __webpack_require__(140).layoutBase.LinkedList;
                var auxiliary = {};
                // get the top most nodes
                auxiliary.getTopMostNodes = function(nodes) {
                    var nodesMap = {};
                    for(var i = 0; i < nodes.length; i++){
                        nodesMap[nodes[i].id()] = true;
                    }
                    var roots = nodes.filter(function(ele, i) {
                        if (typeof ele === "number") {
                            ele = i;
                        }
                        var parent = ele.parent()[0];
                        while(parent != null){
                            if (nodesMap[parent.id()]) {
                                return false;
                            }
                            parent = parent.parent()[0];
                        }
                        return true;
                    });
                    return roots;
                };
                // find disconnected components and create dummy nodes that connect them
                auxiliary.connectComponents = function(cy, eles, topMostNodes, dummyNodes) {
                    var queue = new LinkedList();
                    var visited = new Set();
                    var visitedTopMostNodes = [];
                    var currentNeighbor = void 0;
                    var minDegreeNode = void 0;
                    var minDegree = void 0;
                    var isConnected = false;
                    var count = 1;
                    var nodesConnectedToDummy = [];
                    var components = [];
                    var _loop = function _loop() {
                        var cmpt = cy.collection();
                        components.push(cmpt);
                        var currentNode = topMostNodes[0];
                        var childrenOfCurrentNode = cy.collection();
                        childrenOfCurrentNode.merge(currentNode).merge(currentNode.descendants().intersection(eles));
                        visitedTopMostNodes.push(currentNode);
                        childrenOfCurrentNode.forEach(function(node) {
                            queue.push(node);
                            visited.add(node);
                            cmpt.merge(node);
                        });
                        var _loop2 = function _loop2() {
                            currentNode = queue.shift();
                            // Traverse all neighbors of this node
                            var neighborNodes = cy.collection();
                            currentNode.neighborhood().nodes().forEach(function(node) {
                                if (eles.intersection(currentNode.edgesWith(node)).length > 0) {
                                    neighborNodes.merge(node);
                                }
                            });
                            for(var i = 0; i < neighborNodes.length; i++){
                                var neighborNode = neighborNodes[i];
                                currentNeighbor = topMostNodes.intersection(neighborNode.union(neighborNode.ancestors()));
                                if (currentNeighbor != null && !visited.has(currentNeighbor[0])) {
                                    var childrenOfNeighbor = currentNeighbor.union(currentNeighbor.descendants());
                                    childrenOfNeighbor.forEach(function(node) {
                                        queue.push(node);
                                        visited.add(node);
                                        cmpt.merge(node);
                                        if (topMostNodes.has(node)) {
                                            visitedTopMostNodes.push(node);
                                        }
                                    });
                                }
                            }
                        };
                        while(queue.length != 0){
                            _loop2();
                        }
                        cmpt.forEach(function(node) {
                            eles.intersection(node.connectedEdges()).forEach(function(e) {
                                // connectedEdges() usually cached
                                if (cmpt.has(e.source()) && cmpt.has(e.target())) {
                                    // has() is cheap
                                    cmpt.merge(e);
                                }
                            });
                        });
                        if (visitedTopMostNodes.length == topMostNodes.length) {
                            isConnected = true;
                        }
                        if (!isConnected || isConnected && count > 1) {
                            minDegreeNode = visitedTopMostNodes[0];
                            minDegree = minDegreeNode.connectedEdges().length;
                            visitedTopMostNodes.forEach(function(node) {
                                if (node.connectedEdges().length < minDegree) {
                                    minDegree = node.connectedEdges().length;
                                    minDegreeNode = node;
                                }
                            });
                            nodesConnectedToDummy.push(minDegreeNode.id());
                            // TO DO: Check efficiency of this part
                            var temp = cy.collection();
                            temp.merge(visitedTopMostNodes[0]);
                            visitedTopMostNodes.forEach(function(node) {
                                temp.merge(node);
                            });
                            visitedTopMostNodes = [];
                            topMostNodes = topMostNodes.difference(temp);
                            count++;
                        }
                    };
                    do {
                        _loop();
                    }while (!isConnected)
                    if (dummyNodes) {
                        if (nodesConnectedToDummy.length > 0) {
                            dummyNodes.set('dummy' + (dummyNodes.size + 1), nodesConnectedToDummy);
                        }
                    }
                    return components;
                };
                // relocates componentResult to originalCenter if there is no fixedNodeConstraint
                auxiliary.relocateComponent = function(originalCenter, componentResult, options) {
                    if (!options.fixedNodeConstraint) {
                        var minXCoord = Number.POSITIVE_INFINITY;
                        var maxXCoord = Number.NEGATIVE_INFINITY;
                        var minYCoord = Number.POSITIVE_INFINITY;
                        var maxYCoord = Number.NEGATIVE_INFINITY;
                        if (options.quality == "draft") {
                            // calculate current bounding box
                            var _iteratorNormalCompletion = true;
                            var _didIteratorError = false;
                            var _iteratorError = undefined;
                            try {
                                for(var _iterator = componentResult.nodeIndexes[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                                    var _ref = _step.value;
                                    var _ref2 = _slicedToArray(_ref, 2);
                                    var key = _ref2[0];
                                    var value = _ref2[1];
                                    var cyNode = options.cy.getElementById(key);
                                    if (cyNode) {
                                        var nodeBB = cyNode.boundingBox();
                                        var leftX = componentResult.xCoords[value] - nodeBB.w / 2;
                                        var rightX = componentResult.xCoords[value] + nodeBB.w / 2;
                                        var topY = componentResult.yCoords[value] - nodeBB.h / 2;
                                        var bottomY = componentResult.yCoords[value] + nodeBB.h / 2;
                                        if (leftX < minXCoord) minXCoord = leftX;
                                        if (rightX > maxXCoord) maxXCoord = rightX;
                                        if (topY < minYCoord) minYCoord = topY;
                                        if (bottomY > maxYCoord) maxYCoord = bottomY;
                                    }
                                }
                            // find difference between current and original center
                            } catch (err) {
                                _didIteratorError = true;
                                _iteratorError = err;
                            } finally{
                                try {
                                    if (!_iteratorNormalCompletion && _iterator.return) {
                                        _iterator.return();
                                    }
                                } finally{
                                    if (_didIteratorError) {
                                        throw _iteratorError;
                                    }
                                }
                            }
                            var diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;
                            var diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;
                            // move component to original center
                            componentResult.xCoords = componentResult.xCoords.map(function(x) {
                                return x + diffOnX;
                            });
                            componentResult.yCoords = componentResult.yCoords.map(function(y) {
                                return y + diffOnY;
                            });
                        } else {
                            // calculate current bounding box
                            Object.keys(componentResult).forEach(function(item) {
                                var node = componentResult[item];
                                var leftX = node.getRect().x;
                                var rightX = node.getRect().x + node.getRect().width;
                                var topY = node.getRect().y;
                                var bottomY = node.getRect().y + node.getRect().height;
                                if (leftX < minXCoord) minXCoord = leftX;
                                if (rightX > maxXCoord) maxXCoord = rightX;
                                if (topY < minYCoord) minYCoord = topY;
                                if (bottomY > maxYCoord) maxYCoord = bottomY;
                            });
                            // find difference between current and original center
                            var _diffOnX = originalCenter.x - (maxXCoord + minXCoord) / 2;
                            var _diffOnY = originalCenter.y - (maxYCoord + minYCoord) / 2;
                            // move component to original center
                            Object.keys(componentResult).forEach(function(item) {
                                var node = componentResult[item];
                                node.setCenter(node.getCenterX() + _diffOnX, node.getCenterY() + _diffOnY);
                            });
                        }
                    }
                };
                auxiliary.calcBoundingBox = function(parentNode, xCoords, yCoords, nodeIndexes) {
                    // calculate bounds
                    var left = Number.MAX_SAFE_INTEGER;
                    var right = Number.MIN_SAFE_INTEGER;
                    var top = Number.MAX_SAFE_INTEGER;
                    var bottom = Number.MIN_SAFE_INTEGER;
                    var nodeLeft = void 0;
                    var nodeRight = void 0;
                    var nodeTop = void 0;
                    var nodeBottom = void 0;
                    var nodes = parentNode.descendants().not(":parent");
                    var s = nodes.length;
                    for(var i = 0; i < s; i++){
                        var node = nodes[i];
                        nodeLeft = xCoords[nodeIndexes.get(node.id())] - node.width() / 2;
                        nodeRight = xCoords[nodeIndexes.get(node.id())] + node.width() / 2;
                        nodeTop = yCoords[nodeIndexes.get(node.id())] - node.height() / 2;
                        nodeBottom = yCoords[nodeIndexes.get(node.id())] + node.height() / 2;
                        if (left > nodeLeft) {
                            left = nodeLeft;
                        }
                        if (right < nodeRight) {
                            right = nodeRight;
                        }
                        if (top > nodeTop) {
                            top = nodeTop;
                        }
                        if (bottom < nodeBottom) {
                            bottom = nodeBottom;
                        }
                    }
                    var boundingBox = {};
                    boundingBox.topLeftX = left;
                    boundingBox.topLeftY = top;
                    boundingBox.width = right - left;
                    boundingBox.height = bottom - top;
                    return boundingBox;
                };
                // This function finds and returns parent nodes whose all children are hidden
                auxiliary.calcParentsWithoutChildren = function(cy, eles) {
                    var parentsWithoutChildren = cy.collection();
                    eles.nodes(':parent').forEach(function(parent) {
                        var check = false;
                        parent.children().forEach(function(child) {
                            if (child.css('display') != 'none') {
                                check = true;
                            }
                        });
                        if (!check) {
                            parentsWithoutChildren.merge(parent);
                        }
                    });
                    return parentsWithoutChildren;
                };
                module1.exports = auxiliary;
            /***/ },
            /***/ 816: (module1, __unused_webpack_exports, __webpack_require__)=>{
                /**
  The implementation of the postprocessing part that applies CoSE layout over the spectral layout
*/ var aux = __webpack_require__(548);
                var CoSELayout = __webpack_require__(140).CoSELayout;
                var CoSENode = __webpack_require__(140).CoSENode;
                var PointD = __webpack_require__(140).layoutBase.PointD;
                var DimensionD = __webpack_require__(140).layoutBase.DimensionD;
                var LayoutConstants = __webpack_require__(140).layoutBase.LayoutConstants;
                var FDLayoutConstants = __webpack_require__(140).layoutBase.FDLayoutConstants;
                var CoSEConstants = __webpack_require__(140).CoSEConstants;
                // main function that cose layout is processed
                var coseLayout = function coseLayout(options, spectralResult) {
                    var cy = options.cy;
                    var eles = options.eles;
                    var nodes = eles.nodes();
                    var edges = eles.edges();
                    var nodeIndexes = void 0;
                    var xCoords = void 0;
                    var yCoords = void 0;
                    var idToLNode = {};
                    if (options.randomize) {
                        nodeIndexes = spectralResult["nodeIndexes"];
                        xCoords = spectralResult["xCoords"];
                        yCoords = spectralResult["yCoords"];
                    }
                    var isFn = function isFn(fn) {
                        return typeof fn === 'function';
                    };
                    var optFn = function optFn(opt, ele) {
                        if (isFn(opt)) {
                            return opt(ele);
                        } else {
                            return opt;
                        }
                    };
                    /**** Postprocessing functions ****/ var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);
                    // transfer cytoscape nodes to cose nodes
                    var processChildrenList = function processChildrenList(parent, children, layout, options) {
                        var size = children.length;
                        for(var i = 0; i < size; i++){
                            var theChild = children[i];
                            var children_of_children = null;
                            if (theChild.intersection(parentsWithoutChildren).length == 0) {
                                children_of_children = theChild.children();
                            }
                            var theNode = void 0;
                            var dimensions = theChild.layoutDimensions({
                                nodeDimensionsIncludeLabels: options.nodeDimensionsIncludeLabels
                            });
                            if (theChild.outerWidth() != null && theChild.outerHeight() != null) {
                                if (options.randomize) {
                                    if (!theChild.isParent()) {
                                        theNode = parent.add(new CoSENode(layout.graphManager, new PointD(xCoords[nodeIndexes.get(theChild.id())] - dimensions.w / 2, yCoords[nodeIndexes.get(theChild.id())] - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));
                                    } else {
                                        var parentInfo = aux.calcBoundingBox(theChild, xCoords, yCoords, nodeIndexes);
                                        if (theChild.intersection(parentsWithoutChildren).length == 0) {
                                            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parentInfo.width, parentInfo.height)));
                                        } else {
                                            // for the parentsWithoutChildren
                                            theNode = parent.add(new CoSENode(layout.graphManager, new PointD(parentInfo.topLeftX, parentInfo.topLeftY), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));
                                        }
                                    }
                                } else {
                                    theNode = parent.add(new CoSENode(layout.graphManager, new PointD(theChild.position('x') - dimensions.w / 2, theChild.position('y') - dimensions.h / 2), new DimensionD(parseFloat(dimensions.w), parseFloat(dimensions.h))));
                                }
                            } else {
                                theNode = parent.add(new CoSENode(this.graphManager));
                            }
                            // Attach id to the layout node and repulsion value
                            theNode.id = theChild.data("id");
                            theNode.nodeRepulsion = optFn(options.nodeRepulsion, theChild);
                            // Attach the paddings of cy node to layout node
                            theNode.paddingLeft = parseInt(theChild.css('padding'));
                            theNode.paddingTop = parseInt(theChild.css('padding'));
                            theNode.paddingRight = parseInt(theChild.css('padding'));
                            theNode.paddingBottom = parseInt(theChild.css('padding'));
                            //Attach the label properties to both compound and simple nodes if labels will be included in node dimensions
                            //These properties will be used while updating bounds of compounds during iterations or tiling
                            //and will be used for simple nodes while transferring final positions to cytoscape
                            if (options.nodeDimensionsIncludeLabels) {
                                theNode.labelWidth = theChild.boundingBox({
                                    includeLabels: true,
                                    includeNodes: false,
                                    includeOverlays: false
                                }).w;
                                theNode.labelHeight = theChild.boundingBox({
                                    includeLabels: true,
                                    includeNodes: false,
                                    includeOverlays: false
                                }).h;
                                theNode.labelPosVertical = theChild.css("text-valign");
                                theNode.labelPosHorizontal = theChild.css("text-halign");
                            }
                            // Map the layout node
                            idToLNode[theChild.data("id")] = theNode;
                            if (isNaN(theNode.rect.x)) {
                                theNode.rect.x = 0;
                            }
                            if (isNaN(theNode.rect.y)) {
                                theNode.rect.y = 0;
                            }
                            if (children_of_children != null && children_of_children.length > 0) {
                                var theNewGraph = void 0;
                                theNewGraph = layout.getGraphManager().add(layout.newGraph(), theNode);
                                processChildrenList(theNewGraph, children_of_children, layout, options);
                            }
                        }
                    };
                    // transfer cytoscape edges to cose edges
                    var processEdges = function processEdges(layout, gm, edges) {
                        var idealLengthTotal = 0;
                        var edgeCount = 0;
                        for(var i = 0; i < edges.length; i++){
                            var edge = edges[i];
                            var sourceNode = idToLNode[edge.data("source")];
                            var targetNode = idToLNode[edge.data("target")];
                            if (sourceNode && targetNode && sourceNode !== targetNode && sourceNode.getEdgesBetween(targetNode).length == 0) {
                                var e1 = gm.add(layout.newEdge(), sourceNode, targetNode);
                                e1.id = edge.id();
                                e1.idealLength = optFn(options.idealEdgeLength, edge);
                                e1.edgeElasticity = optFn(options.edgeElasticity, edge);
                                idealLengthTotal += e1.idealLength;
                                edgeCount++;
                            }
                        }
                        // we need to update the ideal edge length constant with the avg. ideal length value after processing edges
                        // in case there is no edge, use other options
                        if (options.idealEdgeLength != null) {
                            if (edgeCount > 0) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = idealLengthTotal / edgeCount;
                            else if (!isFn(options.idealEdgeLength)) CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = options.idealEdgeLength;
                            else CoSEConstants.DEFAULT_EDGE_LENGTH = FDLayoutConstants.DEFAULT_EDGE_LENGTH = 50;
                            // we need to update these constant values based on the ideal edge length constant
                            CoSEConstants.MIN_REPULSION_DIST = FDLayoutConstants.MIN_REPULSION_DIST = FDLayoutConstants.DEFAULT_EDGE_LENGTH / 10.0;
                            CoSEConstants.DEFAULT_RADIAL_SEPARATION = FDLayoutConstants.DEFAULT_EDGE_LENGTH;
                        }
                    };
                    // transfer cytoscape constraints to cose layout
                    var processConstraints = function processConstraints(layout, options) {
                        // get nodes to be fixed
                        if (options.fixedNodeConstraint) {
                            layout.constraints["fixedNodeConstraint"] = options.fixedNodeConstraint;
                        }
                        // get nodes to be aligned
                        if (options.alignmentConstraint) {
                            layout.constraints["alignmentConstraint"] = options.alignmentConstraint;
                        }
                        // get nodes to be relatively placed
                        if (options.relativePlacementConstraint) {
                            layout.constraints["relativePlacementConstraint"] = options.relativePlacementConstraint;
                        }
                    };
                    /**** Apply postprocessing ****/ if (options.nestingFactor != null) CoSEConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = FDLayoutConstants.PER_LEVEL_IDEAL_EDGE_LENGTH_FACTOR = options.nestingFactor;
                    if (options.gravity != null) CoSEConstants.DEFAULT_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_GRAVITY_STRENGTH = options.gravity;
                    if (options.numIter != null) CoSEConstants.MAX_ITERATIONS = FDLayoutConstants.MAX_ITERATIONS = options.numIter;
                    if (options.gravityRange != null) CoSEConstants.DEFAULT_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_GRAVITY_RANGE_FACTOR = options.gravityRange;
                    if (options.gravityCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_STRENGTH = options.gravityCompound;
                    if (options.gravityRangeCompound != null) CoSEConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = FDLayoutConstants.DEFAULT_COMPOUND_GRAVITY_RANGE_FACTOR = options.gravityRangeCompound;
                    if (options.initialEnergyOnIncremental != null) CoSEConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = FDLayoutConstants.DEFAULT_COOLING_FACTOR_INCREMENTAL = options.initialEnergyOnIncremental;
                    if (options.tilingCompareBy != null) CoSEConstants.TILING_COMPARE_BY = options.tilingCompareBy;
                    if (options.quality == 'proof') LayoutConstants.QUALITY = 2;
                    else LayoutConstants.QUALITY = 0;
                    CoSEConstants.NODE_DIMENSIONS_INCLUDE_LABELS = FDLayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = LayoutConstants.NODE_DIMENSIONS_INCLUDE_LABELS = options.nodeDimensionsIncludeLabels;
                    CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = !options.randomize;
                    CoSEConstants.ANIMATE = FDLayoutConstants.ANIMATE = LayoutConstants.ANIMATE = options.animate;
                    CoSEConstants.TILE = options.tile;
                    CoSEConstants.TILING_PADDING_VERTICAL = typeof options.tilingPaddingVertical === 'function' ? options.tilingPaddingVertical.call() : options.tilingPaddingVertical;
                    CoSEConstants.TILING_PADDING_HORIZONTAL = typeof options.tilingPaddingHorizontal === 'function' ? options.tilingPaddingHorizontal.call() : options.tilingPaddingHorizontal;
                    CoSEConstants.DEFAULT_INCREMENTAL = FDLayoutConstants.DEFAULT_INCREMENTAL = LayoutConstants.DEFAULT_INCREMENTAL = true;
                    CoSEConstants.PURE_INCREMENTAL = !options.randomize;
                    LayoutConstants.DEFAULT_UNIFORM_LEAF_NODE_SIZES = options.uniformNodeDimensions;
                    // This part is for debug/demo purpose
                    if (options.step == "transformed") {
                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;
                        CoSEConstants.ENFORCE_CONSTRAINTS = false;
                        CoSEConstants.APPLY_LAYOUT = false;
                    }
                    if (options.step == "enforced") {
                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;
                        CoSEConstants.ENFORCE_CONSTRAINTS = true;
                        CoSEConstants.APPLY_LAYOUT = false;
                    }
                    if (options.step == "cose") {
                        CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;
                        CoSEConstants.ENFORCE_CONSTRAINTS = false;
                        CoSEConstants.APPLY_LAYOUT = true;
                    }
                    if (options.step == "all") {
                        if (options.randomize) CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = true;
                        else CoSEConstants.TRANSFORM_ON_CONSTRAINT_HANDLING = false;
                        CoSEConstants.ENFORCE_CONSTRAINTS = true;
                        CoSEConstants.APPLY_LAYOUT = true;
                    }
                    if (options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint) {
                        CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = false;
                    } else {
                        CoSEConstants.TREE_REDUCTION_ON_INCREMENTAL = true;
                    }
                    var coseLayout = new CoSELayout();
                    var gm = coseLayout.newGraphManager();
                    processChildrenList(gm.addRoot(), aux.getTopMostNodes(nodes), coseLayout, options);
                    processEdges(coseLayout, gm, edges);
                    processConstraints(coseLayout, options);
                    coseLayout.runLayout();
                    return idToLNode;
                };
                module1.exports = {
                    coseLayout: coseLayout
                };
            /***/ },
            /***/ 212: (module1, __unused_webpack_exports, __webpack_require__)=>{
                var _createClass = function() {
                    function defineProperties(target, props) {
                        for(var i = 0; i < props.length; i++){
                            var descriptor = props[i];
                            descriptor.enumerable = descriptor.enumerable || false;
                            descriptor.configurable = true;
                            if ("value" in descriptor) descriptor.writable = true;
                            Object.defineProperty(target, descriptor.key, descriptor);
                        }
                    }
                    return function(Constructor, protoProps, staticProps) {
                        if (protoProps) defineProperties(Constructor.prototype, protoProps);
                        if (staticProps) defineProperties(Constructor, staticProps);
                        return Constructor;
                    };
                }();
                function _classCallCheck(instance, Constructor) {
                    if (!(instance instanceof Constructor)) {
                        throw new TypeError("Cannot call a class as a function");
                    }
                }
                /**
  The implementation of the fcose layout algorithm
*/ var assign = __webpack_require__(658);
                var aux = __webpack_require__(548);
                var _require = __webpack_require__(657), spectralLayout = _require.spectralLayout;
                var _require2 = __webpack_require__(816), coseLayout = _require2.coseLayout;
                var defaults = Object.freeze({
                    // 'draft', 'default' or 'proof' 
                    // - 'draft' only applies spectral layout 
                    // - 'default' improves the quality with subsequent CoSE layout (fast cooling rate)
                    // - 'proof' improves the quality with subsequent CoSE layout (slow cooling rate) 
                    quality: "default",
                    // Use random node positions at beginning of layout
                    // if this is set to false, then quality option must be "proof"
                    randomize: true,
                    // Whether or not to animate the layout
                    animate: true,
                    // Duration of animation in ms, if enabled
                    animationDuration: 1000,
                    // Easing of animation, if enabled
                    animationEasing: undefined,
                    // Fit the viewport to the repositioned nodes
                    fit: true,
                    // Padding around layout
                    padding: 30,
                    // Whether to include labels in node dimensions. Valid in "proof" quality
                    nodeDimensionsIncludeLabels: false,
                    // Whether or not simple nodes (non-compound nodes) are of uniform dimensions
                    uniformNodeDimensions: false,
                    // Whether to pack disconnected components - valid only if randomize: true
                    packComponents: true,
                    // Layout step - all, transformed, enforced, cose - for debug purpose only
                    step: "all",
                    /* spectral layout options */ // False for random, true for greedy
                    samplingType: true,
                    // Sample size to construct distance matrix
                    sampleSize: 25,
                    // Separation amount between nodes
                    nodeSeparation: 75,
                    // Power iteration tolerance
                    piTol: 0.0000001,
                    /* CoSE layout options */ // Node repulsion (non overlapping) multiplier
                    nodeRepulsion: function nodeRepulsion(node) {
                        return 4500;
                    },
                    // Ideal edge (non nested) length
                    idealEdgeLength: function idealEdgeLength(edge) {
                        return 50;
                    },
                    // Divisor to compute edge forces
                    edgeElasticity: function edgeElasticity(edge) {
                        return 0.45;
                    },
                    // Nesting factor (multiplier) to compute ideal edge length for nested edges
                    nestingFactor: 0.1,
                    // Gravity force (constant)
                    gravity: 0.25,
                    // Maximum number of iterations to perform
                    numIter: 2500,
                    // For enabling tiling
                    tile: true,
                    // The function that specifies the criteria for comparing nodes while sorting them during tiling operation.
                    // Takes the node id as a parameter and the default tiling operation is perfomed when this option is not set.
                    tilingCompareBy: undefined,
                    // Represents the amount of the vertical space to put between the zero degree members during the tiling operation(can also be a function)
                    tilingPaddingVertical: 10,
                    // Represents the amount of the horizontal space to put between the zero degree members during the tiling operation(can also be a function)
                    tilingPaddingHorizontal: 10,
                    // Gravity range (constant) for compounds
                    gravityRangeCompound: 1.5,
                    // Gravity force (constant) for compounds
                    gravityCompound: 1.0,
                    // Gravity range (constant)
                    gravityRange: 3.8,
                    // Initial cooling factor for incremental layout  
                    initialEnergyOnIncremental: 0.3,
                    /* constraint options */ // Fix required nodes to predefined positions
                    // [{nodeId: 'n1', position: {x: 100, y: 200}, {...}]
                    fixedNodeConstraint: undefined,
                    // Align required nodes in vertical/horizontal direction
                    // {vertical: [['n1', 'n2')], ['n3', 'n4']], horizontal: ['n2', 'n4']}
                    alignmentConstraint: undefined,
                    // Place two nodes relatively in vertical/horizontal direction 
                    // [{top: 'n1', bottom: 'n2', gap: 100}, {left: 'n3', right: 'n4', gap: 75}]
                    relativePlacementConstraint: undefined,
                    /* layout event callbacks */ ready: function ready() {},
                    stop: function stop() {} // on layoutstop
                });
                var Layout = function() {
                    function Layout(options) {
                        _classCallCheck(this, Layout);
                        this.options = assign({}, defaults, options);
                    }
                    _createClass(Layout, [
                        {
                            key: 'run',
                            value: function run() {
                                var layout = this;
                                var options = this.options;
                                var cy = options.cy;
                                var eles = options.eles;
                                var spectralResult = [];
                                var xCoords = void 0;
                                var yCoords = void 0;
                                var coseResult = [];
                                var components = void 0;
                                var componentCenters = [];
                                // basic validity check for constraint inputs 
                                if (options.fixedNodeConstraint && (!Array.isArray(options.fixedNodeConstraint) || options.fixedNodeConstraint.length == 0)) {
                                    options.fixedNodeConstraint = undefined;
                                }
                                if (options.alignmentConstraint) {
                                    if (options.alignmentConstraint.vertical && (!Array.isArray(options.alignmentConstraint.vertical) || options.alignmentConstraint.vertical.length == 0)) {
                                        options.alignmentConstraint.vertical = undefined;
                                    }
                                    if (options.alignmentConstraint.horizontal && (!Array.isArray(options.alignmentConstraint.horizontal) || options.alignmentConstraint.horizontal.length == 0)) {
                                        options.alignmentConstraint.horizontal = undefined;
                                    }
                                }
                                if (options.relativePlacementConstraint && (!Array.isArray(options.relativePlacementConstraint) || options.relativePlacementConstraint.length == 0)) {
                                    options.relativePlacementConstraint = undefined;
                                }
                                // if any constraint exists, set some options
                                var constraintExist = options.fixedNodeConstraint || options.alignmentConstraint || options.relativePlacementConstraint;
                                if (constraintExist) {
                                    // constraints work with these options
                                    options.tile = false;
                                    options.packComponents = false;
                                }
                                // decide component packing is enabled or not
                                var layUtil = void 0;
                                var packingEnabled = false;
                                if (cy.layoutUtilities && options.packComponents) {
                                    layUtil = cy.layoutUtilities("get");
                                    if (!layUtil) layUtil = cy.layoutUtilities();
                                    packingEnabled = true;
                                }
                                if (eles.nodes().length > 0) {
                                    // if packing is not enabled, perform layout on the whole graph
                                    if (!packingEnabled) {
                                        // store component center
                                        var boundingBox = options.eles.boundingBox();
                                        componentCenters.push({
                                            x: boundingBox.x1 + boundingBox.w / 2,
                                            y: boundingBox.y1 + boundingBox.h / 2
                                        });
                                        // apply spectral layout
                                        if (options.randomize) {
                                            var result = spectralLayout(options);
                                            spectralResult.push(result);
                                        }
                                        // apply cose layout as postprocessing
                                        if (options.quality == "default" || options.quality == "proof") {
                                            coseResult.push(coseLayout(options, spectralResult[0]));
                                            aux.relocateComponent(componentCenters[0], coseResult[0], options); // relocate center to original position
                                        } else {
                                            aux.relocateComponent(componentCenters[0], spectralResult[0], options); // relocate center to original position
                                        }
                                    } else {
                                        // packing is enabled
                                        var topMostNodes = aux.getTopMostNodes(options.eles.nodes());
                                        components = aux.connectComponents(cy, options.eles, topMostNodes);
                                        // store component centers
                                        components.forEach(function(component) {
                                            var boundingBox = component.boundingBox();
                                            componentCenters.push({
                                                x: boundingBox.x1 + boundingBox.w / 2,
                                                y: boundingBox.y1 + boundingBox.h / 2
                                            });
                                        });
                                        //send each component to spectral layout if randomized
                                        if (options.randomize) {
                                            components.forEach(function(component) {
                                                options.eles = component;
                                                spectralResult.push(spectralLayout(options));
                                            });
                                        }
                                        if (options.quality == "default" || options.quality == "proof") {
                                            var toBeTiledNodes = cy.collection();
                                            if (options.tile) {
                                                // behave nodes to be tiled as one component
                                                var nodeIndexes = new Map();
                                                var _xCoords = [];
                                                var _yCoords = [];
                                                var count = 0;
                                                var tempSpectralResult = {
                                                    nodeIndexes: nodeIndexes,
                                                    xCoords: _xCoords,
                                                    yCoords: _yCoords
                                                };
                                                var indexesToBeDeleted = [];
                                                components.forEach(function(component, index) {
                                                    if (component.edges().length == 0) {
                                                        component.nodes().forEach(function(node, i) {
                                                            toBeTiledNodes.merge(component.nodes()[i]);
                                                            if (!node.isParent()) {
                                                                tempSpectralResult.nodeIndexes.set(component.nodes()[i].id(), count++);
                                                                tempSpectralResult.xCoords.push(component.nodes()[0].position().x);
                                                                tempSpectralResult.yCoords.push(component.nodes()[0].position().y);
                                                            }
                                                        });
                                                        indexesToBeDeleted.push(index);
                                                    }
                                                });
                                                if (toBeTiledNodes.length > 1) {
                                                    var _boundingBox = toBeTiledNodes.boundingBox();
                                                    componentCenters.push({
                                                        x: _boundingBox.x1 + _boundingBox.w / 2,
                                                        y: _boundingBox.y1 + _boundingBox.h / 2
                                                    });
                                                    components.push(toBeTiledNodes);
                                                    spectralResult.push(tempSpectralResult);
                                                    for(var i = indexesToBeDeleted.length - 1; i >= 0; i--){
                                                        components.splice(indexesToBeDeleted[i], 1);
                                                        spectralResult.splice(indexesToBeDeleted[i], 1);
                                                        componentCenters.splice(indexesToBeDeleted[i], 1);
                                                    }
                                                    ;
                                                }
                                            }
                                            components.forEach(function(component, index) {
                                                // send each component to cose layout
                                                options.eles = component;
                                                coseResult.push(coseLayout(options, spectralResult[index]));
                                                aux.relocateComponent(componentCenters[index], coseResult[index], options); // relocate center to original position
                                            });
                                        } else {
                                            components.forEach(function(component, index) {
                                                aux.relocateComponent(componentCenters[index], spectralResult[index], options); // relocate center to original position
                                            });
                                        }
                                        // packing
                                        var componentsEvaluated = new Set();
                                        if (components.length > 1) {
                                            var subgraphs = [];
                                            var hiddenEles = eles.filter(function(ele) {
                                                return ele.css('display') == 'none';
                                            });
                                            components.forEach(function(component, index) {
                                                var nodeIndexes = void 0;
                                                if (options.quality == "draft") {
                                                    nodeIndexes = spectralResult[index].nodeIndexes;
                                                }
                                                if (component.nodes().not(hiddenEles).length > 0) {
                                                    var subgraph = {};
                                                    subgraph.edges = [];
                                                    subgraph.nodes = [];
                                                    var nodeIndex = void 0;
                                                    component.nodes().not(hiddenEles).forEach(function(node) {
                                                        if (options.quality == "draft") {
                                                            if (!node.isParent()) {
                                                                nodeIndex = nodeIndexes.get(node.id());
                                                                subgraph.nodes.push({
                                                                    x: spectralResult[index].xCoords[nodeIndex] - node.boundingbox().w / 2,
                                                                    y: spectralResult[index].yCoords[nodeIndex] - node.boundingbox().h / 2,
                                                                    width: node.boundingbox().w,
                                                                    height: node.boundingbox().h
                                                                });
                                                            } else {
                                                                var parentInfo = aux.calcBoundingBox(node, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);
                                                                subgraph.nodes.push({
                                                                    x: parentInfo.topLeftX,
                                                                    y: parentInfo.topLeftY,
                                                                    width: parentInfo.width,
                                                                    height: parentInfo.height
                                                                });
                                                            }
                                                        } else {
                                                            if (coseResult[index][node.id()]) {
                                                                subgraph.nodes.push({
                                                                    x: coseResult[index][node.id()].getLeft(),
                                                                    y: coseResult[index][node.id()].getTop(),
                                                                    width: coseResult[index][node.id()].getWidth(),
                                                                    height: coseResult[index][node.id()].getHeight()
                                                                });
                                                            }
                                                        }
                                                    });
                                                    component.edges().forEach(function(edge) {
                                                        var source = edge.source();
                                                        var target = edge.target();
                                                        if (source.css("display") != "none" && target.css("display") != "none") {
                                                            if (options.quality == "draft") {
                                                                var sourceNodeIndex = nodeIndexes.get(source.id());
                                                                var targetNodeIndex = nodeIndexes.get(target.id());
                                                                var sourceCenter = [];
                                                                var targetCenter = [];
                                                                if (source.isParent()) {
                                                                    var parentInfo = aux.calcBoundingBox(source, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);
                                                                    sourceCenter.push(parentInfo.topLeftX + parentInfo.width / 2);
                                                                    sourceCenter.push(parentInfo.topLeftY + parentInfo.height / 2);
                                                                } else {
                                                                    sourceCenter.push(spectralResult[index].xCoords[sourceNodeIndex]);
                                                                    sourceCenter.push(spectralResult[index].yCoords[sourceNodeIndex]);
                                                                }
                                                                if (target.isParent()) {
                                                                    var _parentInfo = aux.calcBoundingBox(target, spectralResult[index].xCoords, spectralResult[index].yCoords, nodeIndexes);
                                                                    targetCenter.push(_parentInfo.topLeftX + _parentInfo.width / 2);
                                                                    targetCenter.push(_parentInfo.topLeftY + _parentInfo.height / 2);
                                                                } else {
                                                                    targetCenter.push(spectralResult[index].xCoords[targetNodeIndex]);
                                                                    targetCenter.push(spectralResult[index].yCoords[targetNodeIndex]);
                                                                }
                                                                subgraph.edges.push({
                                                                    startX: sourceCenter[0],
                                                                    startY: sourceCenter[1],
                                                                    endX: targetCenter[0],
                                                                    endY: targetCenter[1]
                                                                });
                                                            } else {
                                                                if (coseResult[index][source.id()] && coseResult[index][target.id()]) {
                                                                    subgraph.edges.push({
                                                                        startX: coseResult[index][source.id()].getCenterX(),
                                                                        startY: coseResult[index][source.id()].getCenterY(),
                                                                        endX: coseResult[index][target.id()].getCenterX(),
                                                                        endY: coseResult[index][target.id()].getCenterY()
                                                                    });
                                                                }
                                                            }
                                                        }
                                                    });
                                                    if (subgraph.nodes.length > 0) {
                                                        subgraphs.push(subgraph);
                                                        componentsEvaluated.add(index);
                                                    }
                                                }
                                            });
                                            var shiftResult = layUtil.packComponents(subgraphs, options.randomize).shifts;
                                            if (options.quality == "draft") {
                                                spectralResult.forEach(function(result, index) {
                                                    var newXCoords = result.xCoords.map(function(x) {
                                                        return x + shiftResult[index].dx;
                                                    });
                                                    var newYCoords = result.yCoords.map(function(y) {
                                                        return y + shiftResult[index].dy;
                                                    });
                                                    result.xCoords = newXCoords;
                                                    result.yCoords = newYCoords;
                                                });
                                            } else {
                                                var _count = 0;
                                                componentsEvaluated.forEach(function(index) {
                                                    Object.keys(coseResult[index]).forEach(function(item) {
                                                        var nodeRectangle = coseResult[index][item];
                                                        nodeRectangle.setCenter(nodeRectangle.getCenterX() + shiftResult[_count].dx, nodeRectangle.getCenterY() + shiftResult[_count].dy);
                                                    });
                                                    _count++;
                                                });
                                            }
                                        }
                                    }
                                }
                                // get each element's calculated position
                                var getPositions = function getPositions(ele, i) {
                                    if (options.quality == "default" || options.quality == "proof") {
                                        if (typeof ele === "number") {
                                            ele = i;
                                        }
                                        var pos = void 0;
                                        var node = void 0;
                                        var theId = ele.data('id');
                                        coseResult.forEach(function(result) {
                                            if (theId in result) {
                                                pos = {
                                                    x: result[theId].getRect().getCenterX(),
                                                    y: result[theId].getRect().getCenterY()
                                                };
                                                node = result[theId];
                                            }
                                        });
                                        if (options.nodeDimensionsIncludeLabels) {
                                            if (node.labelWidth) {
                                                if (node.labelPosHorizontal == "left") {
                                                    pos.x += node.labelWidth / 2;
                                                } else if (node.labelPosHorizontal == "right") {
                                                    pos.x -= node.labelWidth / 2;
                                                }
                                            }
                                            if (node.labelHeight) {
                                                if (node.labelPosVertical == "top") {
                                                    pos.y += node.labelHeight / 2;
                                                } else if (node.labelPosVertical == "bottom") {
                                                    pos.y -= node.labelHeight / 2;
                                                }
                                            }
                                        }
                                        if (pos == undefined) pos = {
                                            x: ele.position("x"),
                                            y: ele.position("y")
                                        };
                                        return {
                                            x: pos.x,
                                            y: pos.y
                                        };
                                    } else {
                                        var _pos = void 0;
                                        spectralResult.forEach(function(result) {
                                            var index = result.nodeIndexes.get(ele.id());
                                            if (index != undefined) {
                                                _pos = {
                                                    x: result.xCoords[index],
                                                    y: result.yCoords[index]
                                                };
                                            }
                                        });
                                        if (_pos == undefined) _pos = {
                                            x: ele.position("x"),
                                            y: ele.position("y")
                                        };
                                        return {
                                            x: _pos.x,
                                            y: _pos.y
                                        };
                                    }
                                };
                                // quality = "draft" and randomize = false are contradictive so in that case positions don't change
                                if (options.quality == "default" || options.quality == "proof" || options.randomize) {
                                    // transfer calculated positions to nodes (positions of only simple nodes are evaluated, compounds are positioned automatically)
                                    var parentsWithoutChildren = aux.calcParentsWithoutChildren(cy, eles);
                                    var _hiddenEles = eles.filter(function(ele) {
                                        return ele.css('display') == 'none';
                                    });
                                    options.eles = eles.not(_hiddenEles);
                                    eles.nodes().not(":parent").not(_hiddenEles).layoutPositions(layout, options, getPositions);
                                    if (parentsWithoutChildren.length > 0) {
                                        parentsWithoutChildren.forEach(function(ele) {
                                            ele.position(getPositions(ele));
                                        });
                                    }
                                } else {
                                    console.log("If randomize option is set to false, then quality option must be 'default' or 'proof'.");
                                }
                            }
                        }
                    ]);
                    return Layout;
                }();
                module1.exports = Layout;
            /***/ },
            /***/ 657: (module1, __unused_webpack_exports, __webpack_require__)=>{
                /**
  The implementation of the spectral layout that is the first part of the fcose layout algorithm
*/ var aux = __webpack_require__(548);
                var Matrix = __webpack_require__(140).layoutBase.Matrix;
                var SVD = __webpack_require__(140).layoutBase.SVD;
                // main function that spectral layout is processed
                var spectralLayout = function spectralLayout(options) {
                    var cy = options.cy;
                    var eles = options.eles;
                    var nodes = eles.nodes();
                    var parentNodes = eles.nodes(":parent");
                    var dummyNodes = new Map(); // map to keep dummy nodes and their neighbors
                    var nodeIndexes = new Map(); // map to keep indexes to nodes
                    var parentChildMap = new Map(); // mapping btw. compound and its representative node 
                    var allNodesNeighborhood = []; // array to keep neighborhood of all nodes
                    var xCoords = [];
                    var yCoords = [];
                    var samplesColumn = []; // sampled vertices
                    var minDistancesColumn = [];
                    var C = []; // column sampling matrix
                    var PHI = []; // intersection of column and row sampling matrices 
                    var INV = []; // inverse of PHI 
                    var firstSample = void 0; // the first sampled node
                    var nodeSize = void 0;
                    var infinity = 100000000;
                    var small = 0.000000001;
                    var piTol = options.piTol;
                    var samplingType = options.samplingType; // false for random, true for greedy
                    var nodeSeparation = options.nodeSeparation;
                    var sampleSize = void 0;
                    /**** Spectral-preprocessing functions ****/ /**** Spectral layout functions ****/ // determine which columns to be sampled
                    var randomSampleCR = function randomSampleCR() {
                        var sample = 0;
                        var count = 0;
                        var flag = false;
                        while(count < sampleSize){
                            sample = Math.floor(Math.random() * nodeSize);
                            flag = false;
                            for(var i = 0; i < count; i++){
                                if (samplesColumn[i] == sample) {
                                    flag = true;
                                    break;
                                }
                            }
                            if (!flag) {
                                samplesColumn[count] = sample;
                                count++;
                            } else {
                                continue;
                            }
                        }
                    };
                    // takes the index of the node(pivot) to initiate BFS as a parameter
                    var BFS = function BFS(pivot, index, samplingMethod) {
                        var path = []; // the front of the path
                        var front = 0; // the back of the path
                        var back = 0;
                        var current = 0;
                        var temp = void 0;
                        var distance = [];
                        var max_dist = 0; // the furthest node to be returned
                        var max_ind = 1;
                        for(var i = 0; i < nodeSize; i++){
                            distance[i] = infinity;
                        }
                        path[back] = pivot;
                        distance[pivot] = 0;
                        while(back >= front){
                            current = path[front++];
                            var neighbors = allNodesNeighborhood[current];
                            for(var _i = 0; _i < neighbors.length; _i++){
                                temp = nodeIndexes.get(neighbors[_i]);
                                if (distance[temp] == infinity) {
                                    distance[temp] = distance[current] + 1;
                                    path[++back] = temp;
                                }
                            }
                            C[current][index] = distance[current] * nodeSeparation;
                        }
                        if (samplingMethod) {
                            for(var _i2 = 0; _i2 < nodeSize; _i2++){
                                if (C[_i2][index] < minDistancesColumn[_i2]) minDistancesColumn[_i2] = C[_i2][index];
                            }
                            for(var _i3 = 0; _i3 < nodeSize; _i3++){
                                if (minDistancesColumn[_i3] > max_dist) {
                                    max_dist = minDistancesColumn[_i3];
                                    max_ind = _i3;
                                }
                            }
                        }
                        return max_ind;
                    };
                    // apply BFS to all nodes or selected samples
                    var allBFS = function allBFS(samplingMethod) {
                        var sample = void 0;
                        if (!samplingMethod) {
                            randomSampleCR();
                            // call BFS
                            for(var i = 0; i < sampleSize; i++){
                                BFS(samplesColumn[i], i, samplingMethod, false);
                            }
                        } else {
                            sample = Math.floor(Math.random() * nodeSize);
                            firstSample = sample;
                            for(var _i4 = 0; _i4 < nodeSize; _i4++){
                                minDistancesColumn[_i4] = infinity;
                            }
                            for(var _i5 = 0; _i5 < sampleSize; _i5++){
                                samplesColumn[_i5] = sample;
                                sample = BFS(sample, _i5, samplingMethod);
                            }
                        }
                        // form the squared distances for C
                        for(var _i6 = 0; _i6 < nodeSize; _i6++){
                            for(var j = 0; j < sampleSize; j++){
                                C[_i6][j] *= C[_i6][j];
                            }
                        }
                        // form PHI
                        for(var _i7 = 0; _i7 < sampleSize; _i7++){
                            PHI[_i7] = [];
                        }
                        for(var _i8 = 0; _i8 < sampleSize; _i8++){
                            for(var _j = 0; _j < sampleSize; _j++){
                                PHI[_i8][_j] = C[samplesColumn[_j]][_i8];
                            }
                        }
                    };
                    // perform the SVD algorithm and apply a regularization step
                    var sample = function sample() {
                        var SVDResult = SVD.svd(PHI);
                        var a_q = SVDResult.S;
                        var a_u = SVDResult.U;
                        var a_v = SVDResult.V;
                        var max_s = a_q[0] * a_q[0] * a_q[0];
                        var a_Sig = [];
                        //  regularization
                        for(var i = 0; i < sampleSize; i++){
                            a_Sig[i] = [];
                            for(var j = 0; j < sampleSize; j++){
                                a_Sig[i][j] = 0;
                                if (i == j) {
                                    a_Sig[i][j] = a_q[i] / (a_q[i] * a_q[i] + max_s / (a_q[i] * a_q[i]));
                                }
                            }
                        }
                        INV = Matrix.multMat(Matrix.multMat(a_v, a_Sig), Matrix.transpose(a_u));
                    };
                    // calculate final coordinates 
                    var powerIteration = function powerIteration() {
                        // two largest eigenvalues
                        var theta1 = void 0;
                        var theta2 = void 0;
                        // initial guesses for eigenvectors
                        var Y1 = [];
                        var Y2 = [];
                        var V1 = [];
                        var V2 = [];
                        for(var i = 0; i < nodeSize; i++){
                            Y1[i] = Math.random();
                            Y2[i] = Math.random();
                        }
                        Y1 = Matrix.normalize(Y1);
                        Y2 = Matrix.normalize(Y2);
                        var count = 0;
                        // to keep track of the improvement ratio in power iteration
                        var current = small;
                        var previous = small;
                        var temp = void 0;
                        while(true){
                            count++;
                            for(var _i9 = 0; _i9 < nodeSize; _i9++){
                                V1[_i9] = Y1[_i9];
                            }
                            Y1 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V1), C, INV));
                            theta1 = Matrix.dotProduct(V1, Y1);
                            Y1 = Matrix.normalize(Y1);
                            current = Matrix.dotProduct(V1, Y1);
                            temp = Math.abs(current / previous);
                            if (temp <= 1 + piTol && temp >= 1) {
                                break;
                            }
                            previous = current;
                        }
                        for(var _i10 = 0; _i10 < nodeSize; _i10++){
                            V1[_i10] = Y1[_i10];
                        }
                        count = 0;
                        previous = small;
                        while(true){
                            count++;
                            for(var _i11 = 0; _i11 < nodeSize; _i11++){
                                V2[_i11] = Y2[_i11];
                            }
                            V2 = Matrix.minusOp(V2, Matrix.multCons(V1, Matrix.dotProduct(V1, V2)));
                            Y2 = Matrix.multGamma(Matrix.multL(Matrix.multGamma(V2), C, INV));
                            theta2 = Matrix.dotProduct(V2, Y2);
                            Y2 = Matrix.normalize(Y2);
                            current = Matrix.dotProduct(V2, Y2);
                            temp = Math.abs(current / previous);
                            if (temp <= 1 + piTol && temp >= 1) {
                                break;
                            }
                            previous = current;
                        }
                        for(var _i12 = 0; _i12 < nodeSize; _i12++){
                            V2[_i12] = Y2[_i12];
                        }
                        // theta1 now contains dominant eigenvalue
                        // theta2 now contains the second-largest eigenvalue
                        // V1 now contains theta1's eigenvector
                        // V2 now contains theta2's eigenvector
                        //populate the two vectors
                        xCoords = Matrix.multCons(V1, Math.sqrt(Math.abs(theta1)));
                        yCoords = Matrix.multCons(V2, Math.sqrt(Math.abs(theta2)));
                    };
                    /**** Preparation for spectral layout (Preprocessing) ****/ // connect disconnected components (first top level, then inside of each compound node)
                    aux.connectComponents(cy, eles, aux.getTopMostNodes(nodes), dummyNodes);
                    parentNodes.forEach(function(ele) {
                        aux.connectComponents(cy, eles, aux.getTopMostNodes(ele.descendants().intersection(eles)), dummyNodes);
                    });
                    // assign indexes to nodes (first real, then dummy nodes)
                    var index = 0;
                    for(var i = 0; i < nodes.length; i++){
                        if (!nodes[i].isParent()) {
                            nodeIndexes.set(nodes[i].id(), index++);
                        }
                    }
                    var _iteratorNormalCompletion = true;
                    var _didIteratorError = false;
                    var _iteratorError = undefined;
                    try {
                        for(var _iterator = dummyNodes.keys()[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true){
                            var key = _step.value;
                            nodeIndexes.set(key, index++);
                        }
                    // instantiate the neighborhood matrix
                    } catch (err) {
                        _didIteratorError = true;
                        _iteratorError = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion && _iterator.return) {
                                _iterator.return();
                            }
                        } finally{
                            if (_didIteratorError) {
                                throw _iteratorError;
                            }
                        }
                    }
                    for(var _i13 = 0; _i13 < nodeIndexes.size; _i13++){
                        allNodesNeighborhood[_i13] = [];
                    }
                    // form a parent-child map to keep representative node of each compound node  
                    parentNodes.forEach(function(ele) {
                        var children = ele.children().intersection(eles);
                        //      let random = 0;
                        while(children.nodes(":childless").length == 0){
                            //        random = Math.floor(Math.random() * children.nodes().length); // if all children are compound then proceed randomly
                            children = children.nodes()[0].children().intersection(eles);
                        }
                        //  select the representative node - we can apply different methods here
                        //      random = Math.floor(Math.random() * children.nodes(":childless").length);
                        var index = 0;
                        var min = children.nodes(":childless")[0].connectedEdges().length;
                        children.nodes(":childless").forEach(function(ele2, i) {
                            if (ele2.connectedEdges().length < min) {
                                min = ele2.connectedEdges().length;
                                index = i;
                            }
                        });
                        parentChildMap.set(ele.id(), children.nodes(":childless")[index].id());
                    });
                    // add neighborhood relations (first real, then dummy nodes)
                    nodes.forEach(function(ele) {
                        var eleIndex = void 0;
                        if (ele.isParent()) eleIndex = nodeIndexes.get(parentChildMap.get(ele.id()));
                        else eleIndex = nodeIndexes.get(ele.id());
                        ele.neighborhood().nodes().forEach(function(node) {
                            if (eles.intersection(ele.edgesWith(node)).length > 0) {
                                if (node.isParent()) allNodesNeighborhood[eleIndex].push(parentChildMap.get(node.id()));
                                else allNodesNeighborhood[eleIndex].push(node.id());
                            }
                        });
                    });
                    var _loop = function _loop(_key) {
                        var eleIndex = nodeIndexes.get(_key);
                        var disconnectedId = void 0;
                        dummyNodes.get(_key).forEach(function(id) {
                            if (cy.getElementById(id).isParent()) disconnectedId = parentChildMap.get(id);
                            else disconnectedId = id;
                            allNodesNeighborhood[eleIndex].push(disconnectedId);
                            allNodesNeighborhood[nodeIndexes.get(disconnectedId)].push(_key);
                        });
                    };
                    var _iteratorNormalCompletion2 = true;
                    var _didIteratorError2 = false;
                    var _iteratorError2 = undefined;
                    try {
                        for(var _iterator2 = dummyNodes.keys()[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true){
                            var _key = _step2.value;
                            _loop(_key);
                        }
                    // nodeSize now only considers the size of transformed graph
                    } catch (err) {
                        _didIteratorError2 = true;
                        _iteratorError2 = err;
                    } finally{
                        try {
                            if (!_iteratorNormalCompletion2 && _iterator2.return) {
                                _iterator2.return();
                            }
                        } finally{
                            if (_didIteratorError2) {
                                throw _iteratorError2;
                            }
                        }
                    }
                    nodeSize = nodeIndexes.size;
                    var spectralResult = void 0;
                    // If number of nodes in transformed graph is 1 or 2, either SVD or powerIteration causes problem
                    // So skip spectral and layout the graph with cose
                    if (nodeSize > 2) {
                        // if # of nodes in transformed graph is smaller than sample size,
                        // then use # of nodes as sample size
                        sampleSize = nodeSize < options.sampleSize ? nodeSize : options.sampleSize;
                        // instantiates the partial matrices that will be used in spectral layout
                        for(var _i14 = 0; _i14 < nodeSize; _i14++){
                            C[_i14] = [];
                        }
                        for(var _i15 = 0; _i15 < sampleSize; _i15++){
                            INV[_i15] = [];
                        }
                        /**** Apply spectral layout ****/ if (options.quality == "draft" || options.step == "all") {
                            allBFS(samplingType);
                            sample();
                            powerIteration();
                            spectralResult = {
                                nodeIndexes: nodeIndexes,
                                xCoords: xCoords,
                                yCoords: yCoords
                            };
                        } else {
                            nodeIndexes.forEach(function(value, key) {
                                xCoords.push(cy.getElementById(key).position("x"));
                                yCoords.push(cy.getElementById(key).position("y"));
                            });
                            spectralResult = {
                                nodeIndexes: nodeIndexes,
                                xCoords: xCoords,
                                yCoords: yCoords
                            };
                        }
                        return spectralResult;
                    } else {
                        var iterator = nodeIndexes.keys();
                        var firstNode = cy.getElementById(iterator.next().value);
                        var firstNodePos = firstNode.position();
                        var firstNodeWidth = firstNode.outerWidth();
                        xCoords.push(firstNodePos.x);
                        yCoords.push(firstNodePos.y);
                        if (nodeSize == 2) {
                            var secondNode = cy.getElementById(iterator.next().value);
                            var secondNodeWidth = secondNode.outerWidth();
                            xCoords.push(firstNodePos.x + firstNodeWidth / 2 + secondNodeWidth / 2 + options.idealEdgeLength);
                            yCoords.push(firstNodePos.y);
                        }
                        spectralResult = {
                            nodeIndexes: nodeIndexes,
                            xCoords: xCoords,
                            yCoords: yCoords
                        };
                        return spectralResult;
                    }
                };
                module1.exports = {
                    spectralLayout: spectralLayout
                };
            /***/ },
            /***/ 579: (module1, __unused_webpack_exports, __webpack_require__)=>{
                var impl = __webpack_require__(212);
                // registers the extension on a cytoscape lib ref
                var register = function register(cytoscape1) {
                    if (!cytoscape1) {
                        return;
                    } // can't register if cytoscape unspecified
                    cytoscape1('layout', 'fcose', impl); // register with cytoscape.js
                };
                if (typeof cytoscape !== 'undefined') {
                    // expose to global cytoscape (i.e. window.cytoscape)
                    register(cytoscape);
                }
                module1.exports = register;
            /***/ },
            /***/ 140: (module1)=>{
                module1.exports = __WEBPACK_EXTERNAL_MODULE__140__;
            /***/ }
        };
        /************************************************************************/ /******/ // The module cache
        /******/ var __webpack_module_cache__ = {};
        /******/ /******/ // The require function
        /******/ function __webpack_require__(moduleId) {
            /******/ // Check if module is in cache
            /******/ var cachedModule = __webpack_module_cache__[moduleId];
            /******/ if (cachedModule !== undefined) {
                /******/ return cachedModule.exports;
            /******/ }
            /******/ // Create a new module (and put it into the cache)
            /******/ var module1 = __webpack_module_cache__[moduleId] = {
                /******/ // no module.id needed
                /******/ // no module.loaded needed
                /******/ exports: {}
            };
            /******/ /******/ // Execute the module function
            /******/ __webpack_modules__[moduleId](module1, module1.exports, __webpack_require__);
            /******/ /******/ // Return the exports of the module
            /******/ return module1.exports;
        /******/ }
        /******/ /************************************************************************/ /******/ /******/ // startup
        /******/ // Load entry module and return exports
        /******/ // This entry module is referenced by other modules so it can't be inlined
        /******/ var __webpack_exports__ = __webpack_require__(579);
        /******/ /******/ return __webpack_exports__;
    /******/ })();
});
}}),

};

//# sourceMappingURL=node_modules_3c363402._.js.map