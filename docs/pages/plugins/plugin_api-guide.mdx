import { Callout } from 'nextra/components'

# Yaci-Store Plugin API Reference

**Complete Developer Reference for Plugin Development**

## Table of Contents
1. [Overview](#overview)
2. [Storage Extension Points](#storage-extension-points)
3. [Event Classes](#event-classes)
4. [Domain Classes](#domain-classes)

---

## Overview

This reference guide provides comprehensive documentation for all extension points, domain classes, and variables available to plugin developers in the yaci-store system. The primary focus is on MVEL plugins with additional examples in JavaScript and Python.

### Key Concepts
- **Extension Points**: Predefined hooks where plugins can intercept and process data
- **Domain Classes**: Core blockchain data structures (blocks, transactions, assets, etc.)
- **Event Classes**: Data containers representing blockchain events
- **Plugin Variables**: Built-in variables for database access, HTTP calls, and utilities
- **Field Names**: All field names use camelCase (e.g., `lovelaceAmount`, `txHash`, `ownerAddr`)
- **Parameter Signatures**:
  - Storage plugins (filter, pre-action, post-action): `function(items)`
  - Event handlers: `function(event)`
  - Variables are directly available by name (no context parameter)

### Important: Field Access Patterns by Language

<Callout type="warning" title="Critical: Language-Specific Field Access">
Different plugin languages have different ways of accessing Java object fields. This is crucial to understand for writing working plugins.
</Callout>

#### MVEL and SPEL
- **Direct field access**: You can access fields directly using dot notation (e.g., `item.label`, `utxo.lovelaceAmount`)
- **Getter/setter access**: Also supports standard getter/setter methods (e.g., `item.getLabel()`, `utxo.setLovelaceAmount()`)
- **Both patterns work**: Choose based on preference, but direct field access is more concise

```mvel
// MVEL - Direct field access (recommended)
if (item.label == "721") { ... }
amount = utxo.lovelaceAmount;

// MVEL - Getter/setter access (also works)
if (item.getLabel() == "721") { ... }
amount = utxo.getLovelaceAmount();
```

#### JavaScript and Python
- **Only getter/setter access**: Must use getter/setter methods to access fields
- **Direct field access will NOT work**: `item.label` will return `undefined` or throw an error
- **Always use methods**: `getFieldName()` to read, `setFieldName(value)` to write

```javascript
// JavaScript - CORRECT
if (item.getLabel() === "721") { ... }
const amount = utxo.getLovelaceAmount();

// JavaScript - INCORRECT (will not work)
if (item.label === "721") { ... }  // ❌ Returns undefined
```

```python
# Python - CORRECT
if item.getLabel() == "721": ...
amount = utxo.getLovelaceAmount()

# Python - INCORRECT (will not work)
if item.label == "721": ...  # ❌ Throws AttributeError
```

<Callout type="info">
**Quick Reference**:
- MVEL/SPEL: `object.field` or `object.getField()`
- JavaScript/Python: `object.getField()` only
</Callout>

---

## Storage Extension Points

Storage extension points are predefined hooks where storage plugins can intercept data before it's saved to the database. Each extension point is identified by a unique key and processes specific domain objects.

### UTXO Store Extension Points

#### `utxo.unspent.save`
**Purpose**: Process new unspent UTXOs before storage
**Domain Object**: [`AddressUtxo`](#addressutxo)

**MVEL Example:**
```mvel
// Filter high-value UTXOs (> 1000 ADA)
def filterHighValueUtxos(items) {
    filtered = [];
    for (utxo : items) {
        if (utxo.lovelaceAmount > 1000000000) {
            filtered.add(utxo);
        }
    }
    return filtered;
}
```

```yaml
# Configuration
store:
  plugins:
    filters:
      utxo.unspent.save:
        - name: "High Value UTXO Filter"
          lang: mvel
          expression: lovelaceAmount > 1000000000
```

#### `utxo.spent.save`
**Purpose**: Process spent UTXOs before storage
**Domain Object**: [`TxInput`](#txinput)


### Transaction Store Extension Points

#### `transaction.save`
**Purpose**: Process transaction data before storage
**Domain Object**: [`Txn`](#txn)

```mvel
// Filter high-fee transactions
def filterHighFeeTransactions(items) {
    filtered = [];
    for (txn : items) {
        if (txn.fee > 10000000) { // > 10 ADA
            filtered.add(txn);
        }
    }
    return filtered;
}
```

#### `transaction.witness.save`
**Purpose**: Process transaction witnesses before storage
**Domain Object**: [`TxnWitness`](#txnwitness)

#### `transaction.withdrawal.save`
**Purpose**: Process stake withdrawals before storage
**Domain Object**: [`Withdrawal`](#withdrawal)

### Metadata Store Extension Points

#### `metadata.save`
**Purpose**: Process transaction metadata before storage
**Domain Object**: [`TxMetadataLabel`](#txmetadatalabel)

**MVEL Example:**
```mvel
// Filter NFT metadata (CIP-25)
expression: label == "721"
```

**JavaScript Example:**
```javascript
// Process NFT metadata
function processNFTMetadata(items) {
    const nftMetadata = [];

    for (const item of items) {
        if (item.getLabel() === "721") {
            try {
                // Parse NFT metadata
                const metadata = JSON.parse(item.getBody());
                console.log(`NFT metadata in tx: ${item.getTxHash()}`);
                nftMetadata.push(item);
            } catch (e) {
                console.error(`Invalid NFT metadata in ${item.getTxHash()}: ${e.message}`);
            }
        }
    }

    return nftMetadata;
}
```

### Asset Store Extension Points

#### `asset.save`
**Purpose**: Process native asset mint/burn operations before storage
**Domain Object**: [`TxAsset`](#txasset)

**MVEL Example:**
```mvel
// Filter NFT mints (quantity = 1)
def filterNFTMints(items) {
    nfts = [];
    for (asset : items) {
        if (asset.quantity == 1 && asset.mintType.name() == "MINT") {
            nfts.add(asset);
        }
    }
    return nfts;
}
```

>> **Note**: The `mintType` field is an enum with values `MINT` and `BURN`. Enum values can be accessed using `name()` method.

### Block Store Extension Points

#### `block.save`
**Purpose**: Process block data before storage
**Domain Object**: [`Block`](#block)

```mvel
// Filter high-activity blocks
expression: noOfTxs > 500
```

### Script Store Extension Points

#### `script.save`
**Purpose**: Process script definitions before storage
**Domain Object**: [`Script`](#script)

#### `script.datum.save`
**Purpose**: Process datum data before storage
**Domain Object**: [`Datum`](#datum)

#### `script.tx_script.save`
**Purpose**: Process transaction script executions before storage
**Domain Object**: [`TxScript`](#txscript)

### Staking Store Extension Points

#### `staking.key_registration.save`
**Purpose**: Process stake key registrations before storage
**Domain Object**: [`StakeRegistrationDetail`](#stakeregistrationdetail)

#### `staking.key_delegation.save`
**Purpose**: Process stake delegations before storage
**Domain Object**: [`Delegation`](#delegation)

#### `staking.pool_registration.save`
**Purpose**: Process pool registrations before storage
**Domain Object**: [`PoolRegistration`](#poolregistration)

```mvel
// Filter high-pledge pools
def filterHighPledgePools(items) {
    highPledge = [];
    for (pool : items) {
        if (pool.pledge > 1000000000000) { // > 1M ADA
            highPledge.add(pool);
        }
    }
    return highPledge;
}
```

#### `staking.pool_retirement.save`
**Purpose**: Process pool retirements before storage
**Domain Object**: [`PoolRetirement`](#poolretirement)

#### `staking.pool.save`
**Purpose**: Process pool status updates before storage
**Domain Object**: [`Pool`](#pool)

### Governance Store Extension Points (Conway Era)

#### `governance.gov_action_proposal.save`
**Purpose**: Process governance proposals before storage
**Domain Object**: [`GovActionProposal`](#govactionproposal)

```mvel
// Filter high-deposit proposals
expression: deposit > 10000000000 // > 10k ADA
```

#### `governance.voting_procedure.save`
**Purpose**: Process votes before storage
**Domain Object**: [`VotingProcedure`](#votingprocedure)

#### `governance.drep_registration.save`
**Purpose**: Process DRep registrations before storage
**Domain Object**: [`DRepRegistration`](#drepregistration)

#### `governance.drep.save`
**Purpose**: Process DRep status updates before storage
**Domain Object**: [`DRep`](#drep)

#### `governance.delegation_vote.save`
**Purpose**: Process vote delegations before storage
**Domain Object**: [`DelegationVote`](#delegationvote)

#### `governance.committee_registration.save`
**Purpose**: Process committee registrations before storage
**Domain Object**: [`CommitteeRegistration`](#committeeregistration)

#### `governance.committee_member.save`
**Purpose**: Process committee member updates before storage
**Domain Object**: [`CommitteeMember`](#committeemember)

#### `governance.committee_deregistration.save`
**Purpose**: Process committee deregistrations before storage
**Domain Object**: [`CommitteeDeRegistration`](#committeederegistration)

---

## Event Classes

Event classes represent blockchain events that can be processed by event handler plugins. Event handlers take one parameter: `event`.

**Common Field**: All event classes (except RollbackEvent and internal events) contain an `EventMetadata metadata` field with block context information like `blockNumber`, `blockHash`, `slot`, `epochNumber`, etc.

### System Events

#### `RollbackEvent`
**Purpose**: Notifies when blockchain rollback occurs

```mvel
def handleRollback(event) {
    System.out.println("Rollback to slot: " + event.rollbackTo.slot);
    System.out.println("Current block: " + event.currentBlock);

    // Cleanup plugin state if needed
    // global_state.removeKeysAfterSlot(event.rollbackTo.slot);
}
```

#### `CommitEvent`
**Purpose**: Triggered at the end of each block batch processing, enabling sequential post-processing after parallel block ingestion

**How it Works**:
- **During Initial Sync**: Blocks are processed in parallel batches (typically 200 blocks). CommitEvent fires when the entire batch is committed to storage
- **Sequential Processing**: Runs after parallel block processing is complete, ensuring all batch data is available
- **At Chain Tip**: After reaching tip, batch size becomes 1, but CommitEvent still fires for each block
- **Timing**: Perfect for operations that need to run sequentially after parallel processing completes

**Use Cases**: Aggregate calculations, cleanup tasks, external notifications, batch statistics, triggering dependent systems

```mvel
def handleCommitEvent(event) {
    System.out.println("Batch committed - processing complete for batch");
    System.out.println("Metadata: " + event.metadata);

    // Perform sequential post-processing
    // - Calculate batch statistics
    // - Send batch completion notifications
    // - Trigger dependent systems
    // - Cleanup temporary data

    // Example: Aggregate batch metrics
    batchKey = "batch_" + event.metadata.blockNumber;
    global_state.put(batchKey + "_processed", true);

    System.out.println("Batch post-processing completed");
}
```

#### `PreCommitEvent`
**Purpose**: Triggered before data commit operations

#### `PreEpochTransitionEvent`
**Purpose**: Triggered before epoch transition processing

#### `EpochTransitionCommitEvent`
**Purpose**: Triggered during epoch transition commit phase

#### `EpochChangeEvent`
**Purpose**: Notifies when epoch changes

**JavaScript Example:**
```javascript
function handleEpochChange(event) {
    const metadata = event.getMetadata();
    console.log(`Epoch changed from ${event.getPreviousEpoch()} to ${metadata.getEpochNumber()}`);

    // Trigger epoch-specific processing
    if (metadata.getEpochNumber() % 10 === 0) {
        console.log("Milestone epoch reached!");
    }
}
```

### Blockchain Data Events

#### `BlockEvent`
**Purpose**: Contains complete block data

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `Block block` - Complete block data from yaci-core (see [`Block`](#block-yaci-core))

```mvel
def handleBlockEvent(event) {
    block = event.block;  // This is the yaci-core Block object
    metadata = event.metadata;

    // Access yaci-core Block fields
    System.out.println("Era: " + block.era);
    System.out.println("Block number: " + block.header.headerBody.blockNumber);
    System.out.println("Slot: " + block.header.headerBody.slot);
    System.out.println("Previous hash: " + block.header.headerBody.prevHash);
    System.out.println("Block hash: " + block.header.headerBody.blockHash);

    // Transaction information
    System.out.println("Transactions: " + block.transactionBodies.size());
    System.out.println("Witnesses: " + block.transactionWitness.size());

    // Check for invalid transactions
    if (!block.invalidTransactions.isEmpty()) {
        System.out.println("Invalid transactions: " + block.invalidTransactions);
    }

    // Check auxiliary data
    if (!block.auxiliaryDataMap.isEmpty()) {
        System.out.println("Blocks with metadata: " + block.auxiliaryDataMap.size());
    }
}
```

#### `TransactionEvent`
**Purpose**: Contains transaction data from yaci-helper

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<Transaction> transactions` - Transaction data (see [`Transaction`](#transaction))

**Python Example:**
```python
def handle_transaction_event(event):
    """Process transaction events"""
    transactions = event.getTransactions()
    metadata = event.getMetadata()

    high_value_count = 0
    smart_contract_count = 0

    for tx in transactions:
        # Calculate total output
        total_output = sum(out.getAmount() for out in tx.getOutputs() if hasattr(out, 'getAmount'))

        # Track high-value transactions
        if total_output > 1000 * 1_000_000:  # > 1000 ADA
            high_value_count += 1
            print(f"High value transaction: {tx.getHash()}")

        # Track smart contract transactions
        if hasattr(tx, 'getScriptDataHash') and tx.getScriptDataHash():
            smart_contract_count += 1

    if high_value_count > 0:
        print(f"Found {high_value_count} high-value transactions")

    if smart_contract_count > 0:
        print(f"Found {smart_contract_count} smart contract transactions")
```

#### `MintBurnEvent`
**Purpose**: Contains asset mint/burn operations

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<TxMintBurn> txMintBurns` - Asset mint/burn operations (see [`TxMintBurn`](#txmintburn))

**MVEL Example:**
```mvel
def handleMintBurnEvent(event) {
    for (mintBurn : event.txMintBurns) {
        if (mintBurn.quantity > 0) {
            System.out.println("MINT: " + mintBurn.quantity + " of " + mintBurn.policy);
        } else {
            System.out.println("BURN: " + Math.abs(mintBurn.quantity) + " of " + mintBurn.policy);
        }

        // Track NFT operations
        if (Math.abs(mintBurn.quantity) == 1) {
            System.out.println("NFT operation detected: " + mintBurn.policy + "." + mintBurn.assetName);
        }
    }
}
```

#### `GovernanceEvent`
**Purpose**: Contains Conway era governance data

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<TxGovernance> txGovernanceList` - Governance transactions

**JavaScript Example:**
```javascript
function handleGovernanceEvent(event) {
    const govList = event.getTxGovernanceList();

    for (const govTx of govList) {
        console.log(`Governance transaction: ${govTx.getTransactionHash()}`);

        // Process proposals
        if (govTx.getProposalProcedures()) {
            for (const proposal of govTx.getProposalProcedures()) {
                console.log(`New proposal: ${proposal.getGovActionType()}`);
                console.log(`Deposit: ${proposal.getDeposit() / 1_000_000} ADA`);
            }
        }

        // Process votes
        if (govTx.getVotingProcedures()) {
            for (const vote of govTx.getVotingProcedures()) {
                console.log(`Vote: ${vote.getVoterType()} voted ${vote.getVote()}`);
            }
        }
    }
}
```

#### `CertificateEvent`
**Purpose**: Contains stake pool and delegation certificate data

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<TxCertificates> txCertificatesList` - Certificate data (see [`TxCertificates`](#txcertificates))

#### `UpdateEvent`
**Purpose**: Contains protocol parameter update information

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<TxUpdate> updates` - Protocol parameter updates

### Staking Events

#### `PoolRegistrationEvent`
**Purpose**: Contains stake pool registration data

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<PoolRegistration> poolRegistrations` - Pool registration certificates (see [`PoolRegistration`](#poolregistration))

#### `PoolRetiredEvent`
**Purpose**: Notifies when stake pools are retired

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<Pool> retiredPools` - Retired pool information (see [`Pool`](#pool))

#### `PoolRetirementEvent`
**Purpose**: Contains stake pool retirement certificate data

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<PoolRetirement> poolRetirements` - Pool retirement certificates (see [`PoolRetirement`](#poolretirement))

#### `StakeRegDeregEvent`
**Purpose**: Contains stake key registration/deregistration data

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<StakeRegistrationDetail> stakeRegistrationDetails` - Registration/deregistration details (see [`StakeRegistrationDetail`](#stakeregistrationdetail))

#### `StakingDepositEvent`
**Purpose**: Contains staking-related deposit information

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `int stakeKeyRegistrationCount` - Number of stake key registrations
- `int stakeKeyDeRegistrationCount` - Number of stake key deregistrations
- `int stakePoolRegistrationCount` - Number of pool registrations

### Store-Specific Events

#### `AddressUtxoEvent`
**Purpose**: Address UTXO changes

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<TxInputOutput> txInputOutputs` - UTXO changes

**MVEL Example:**
```mvel
def handleAddressUtxoEvent(event) {
    for (txInputOutput : event.txInputOutputs) {
        if (txInputOutput.type == "OUTPUT") {
            System.out.println("New UTXO: " + txInputOutput.txHash + "#" + txInputOutput.outputIndex);
        } else {
            System.out.println("Spent UTXO: " + txInputOutput.txHash + "#" + txInputOutput.outputIndex);
        }
    }
}
```

#### `TxMetadataEvent`
**Purpose**: Processed metadata events

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<TxMetadata> txMetadataList` - Transaction metadata

#### `TxnEvent`
**Purpose**: Processed transaction events

**Key Fields**:
- `EventMetadata metadata` - Block context information
- `List<Txn> txnList` - Processed transactions (see [`Txn`](#txn))

---

## Domain Classes

Domain classes represent the core blockchain data structures. All field names use camelCase.

**Mutability**: Most domain classes are **mutable** (provide both getters and setters), except where noted as **immutable** (getters only).

### Core Classes

#### `AddressUtxo`
**Purpose**: Represents a UTXO at a specific address (see [utxo.unspent.save](#utxounspentsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`Amt`](#amt)

**Key Fields**:
```mvel
// UTXO identification
utxo.txHash              // String: Source transaction hash
utxo.outputIndex         // Integer: Output index
utxo.slot                // Long: Creation slot
utxo.blockHash           // String: Creation block hash
utxo.epoch               // Integer: Creation epoch

// Address information
utxo.ownerAddr           // String: Owner address (bech32)
utxo.ownerStakeAddr      // String: Stake address
utxo.ownerPaymentCredential  // String: Payment credential
utxo.ownerStakeCredential    // String: Stake credential

// Value
utxo.lovelaceAmount      // BigInteger: ADA amount in lovelace
utxo.amounts             // List<Amt>: Native asset amounts

// Smart contract data
utxo.dataHash            // String: Datum hash
utxo.inlineDatum         // String: Inline datum
utxo.scriptRef           // String: Script reference
utxo.referenceScriptHash // String: Reference script hash

// Special flags
utxo.isCollateralReturn  // Boolean: Whether this is collateral return
```

**Usage Example**:
```mvel
def analyzeUtxo(items) {
    highValue = [];
    nftUtxos = [];
    scriptUtxos = [];

    for (utxo : items) {
        // High-value detection
        if (utxo.lovelaceAmount > 1000000000) {
            highValue.add(utxo);
        }

        // NFT detection
        if (utxo.amounts != null) {
            for (amount : utxo.amounts) {
                if (amount.quantity == 1) {
                    nftUtxos.add(utxo);
                    break;
                }
            }
        }

        // Script UTXO detection
        if (utxo.dataHash != null || utxo.inlineDatum != null || utxo.scriptRef != null) {
            scriptUtxos.add(utxo);
        }
    }

    System.out.println("High-value UTXOs: " + highValue.size());
    System.out.println("NFT UTXOs: " + nftUtxos.size());
    System.out.println("Script UTXOs: " + scriptUtxos.size());

    return items;
}
```

#### `Block`
**Purpose**: Represents a blockchain block

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`Vrf`](#vrf)

**Key Fields**:
```mvel
// Block identification
block.hash               // String: Block hash
block.number             // Long: Block number
block.slot               // Long: Slot number
block.epochNumber        // Integer: Epoch number
block.epochSlot          // Integer: Slot within epoch

// Block content
block.prevHash           // String: Previous block hash
block.totalOutput        // BigInteger: Total output in lovelace
block.totalFees          // BigInteger: Total fees in lovelace
block.noOfTxs            // int: Number of transactions

// Timing
block.blockTime          // Long: Block timestamp

// Block producer info
block.slotLeader         // String: Slot leader
block.issuerVkey         // String: Block issuer verification key
block.vrfVkey            // String: VRF verification key
block.nonceVrf           // Vrf: Nonce VRF
block.leaderVrf          // Vrf: Leader VRF
block.vrfResult          // Vrf: VRF result

// Block structure
block.blockBodySize      // long: Body size in bytes
block.blockBodyHash      // String: Body hash
block.protocolVersion    // String: Protocol version
```

#### `TxMetadataLabel`
**Purpose**: Transaction metadata organized by label

**Mutability**: Immutable (getters only)

**Key Fields**:
```mvel
// Transaction reference
metadata.txHash          // String: Transaction hash
metadata.slot            // Long: Slot number

// Metadata content
metadata.label           // String: Metadata label
metadata.body            // String: Metadata body (JSON)
metadata.cbor            // String: Raw CBOR data
```

**Usage Example**:
**JavaScript Example:**
```javascript
function processMetadata(items) {
    const nftMetadata = [];
    const tokenMetadata = [];

    for (const item of items) {
        switch (item.getLabel()) {
            case "721":
                // NFT metadata (CIP-25)
                try {
                    const nftData = JSON.parse(item.getBody());
                    console.log(`NFT metadata in ${item.getTxHash()}`);
                    nftMetadata.push(item);
                } catch (e) {
                    console.error(`Invalid NFT metadata: ${e.message}`);
                }
                break;

            case "1967":
                // Token metadata
                tokenMetadata.push(item);
                break;

            case "674":
                // Message metadata
                console.log(`Message in ${item.getTxHash()}: ${item.getBody()}`);
                break;
        }
    }

    console.log(`Processed ${nftMetadata.length} NFT metadata items`);

    return items;
}
```

#### `TxAsset`
**Purpose**: Represents native assets in transactions (see [asset.save](#assetsave))

**Mutability**: Immutable (getters only)
**Nested Classes**: [`MintType`](#minttype) (enum)

**Key Fields**:
```mvel
// Asset identification
asset.policy             // String: Policy ID (hex)
asset.assetName          // String: Asset name (hex)
asset.unit               // String: Policy + asset name
asset.fingerprint        // String: Asset fingerprint (CIP-14)

// Transaction context
asset.slot               // Long: Slot number
asset.txHash             // String: Transaction hash

// Asset operation
asset.quantity           // BigInteger: Asset quantity
asset.mintType           // MintType: "MINT" or "BURN"
```

#### `Txn`
**Purpose**: Represents a processed transaction (see [transaction.save](#transactionsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`UtxoKey`](#utxokey), [`TxOuput`](#txouput)

**Key Fields**:
```mvel
// Transaction identification
txn.txHash               // String: Transaction hash
txn.blockHash            // String: Containing block hash
txn.slot                 // Long: Slot number
txn.txIndex              // Integer: Index within block

// Transaction structure
txn.fee                  // BigInteger: Transaction fee in lovelace
txn.ttl                  // Long: Time to live
txn.auxiliaryDataHash    // String: Metadata hash
txn.scriptDataHash       // String: Script data hash
txn.inputs               // List<UtxoKey>: Transaction inputs
txn.outputs              // List<UtxoKey>: Transaction outputs
txn.collateralInputs     // List<UtxoKey>: Collateral inputs
txn.referenceInputs      // List<UtxoKey>: Reference inputs
txn.collateralReturn     // UtxoKey: Collateral return
txn.collateralReturnJson // TxOuput: Collateral return details
txn.requiredSigners      // Set<String>: Required signers

// Status
txn.invalid              // Boolean: Whether transaction is invalid
```

#### `TxnWitness`
**Purpose**: Represents transaction witness data (see [transaction.witness.save](#transactionwitnesssave))

**Mutability**: Mutable (getters and setters)

**Key Fields**:
```mvel
// Transaction reference
witness.txHash           // String: Transaction hash
witness.index            // Integer: Witness index
witness.slot             // Long: Slot number

// Witness data
witness.pubKey           // String: Public key
witness.signature        // String: Signature
witness.pubKeyhash       // String: Public key hash
witness.type             // TxWitnessType: Witness type enum
witness.additionalData   // JsonNode: Additional witness data
```

#### `Withdrawal`
**Purpose**: Represents stake withdrawal operations (see [transaction.withdrawal.save](#transactionwithdrawalsave))

**Mutability**: Mutable (getters and setters)

**Key Fields**:
```mvel
// Transaction reference
withdrawal.txHash        // String: Transaction hash
withdrawal.slot          // Long: Slot number
withdrawal.blockNumber   // String: Block number
withdrawal.epoch         // Integer: Epoch number

// Withdrawal details
withdrawal.address       // String: Reward address
withdrawal.amount        // BigInteger: Withdrawal amount in lovelace
```

#### `TxInput`
**Purpose**: Represents transaction inputs/spent UTXOs (see [utxo.spent.save](#utxospentsave))

**Mutability**: Mutable (getters and setters)

**Key Fields**:
```mvel
// Input reference
input.txHash             // String: Source transaction hash
input.outputIndex        // Integer: Output index being spent

// Spent information
input.spentAtSlot        // Long: Slot when UTXO was spent
input.spentAtBlock       // Long: Block number when spent
input.spentAtBlockHash   // String: Block hash when spent
input.spentBlockTime     // Long: Block timestamp when spent
input.spentEpoch         // Integer: Epoch when spent
input.spentTxHash        // String: Transaction hash that spent this UTXO
```

### Smart Contract Classes

#### `Datum`
**Purpose**: Represents datum data in smart contracts (see [script.datum.save](#scriptdatumsave))

**Mutability**: Mutable (getters and setters)

**Key Fields**:
```mvel
// Datum identification
datum.hash                // String: Datum hash
datum.datum               // String: CBOR representation
datum.createdAtTx         // String: Created at tx hash
```

#### `Script`
**Purpose**: Represents script definitions (see [script.save](#scriptsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`ScriptType`](#scripttype) (enum)

**Key Fields**:
```mvel
// Script identification
script.scriptHash            // String: Script hash
script.scriptType            // ScriptType: Script type
script.content               // String: Script content
```

#### `TxScript`
**Purpose**: Represents script execution in transactions (see [script.tx_script.save](#scripttx_scriptsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`RedeemerTag`](#redeemertag) (enum), [`ScriptType`](#scripttype) (enum)

**Key Fields**:
```mvel
// Transaction reference
txScript.txHash          // String: Transaction hash
txScript.slot            // Long: Slot number
txScript.blockHash       // String: Block hash

// Script execution context
txScript.scriptHash      // String: Script hash
txScript.type            // ScriptType: Script type
txScript.redeemerCbor    // String: Redeemer CBOR data
txScript.datum           // String: Datum data
txScript.datumHash       // String: Datum hash
txScript.unitMem         // BigInteger: Memory units consumed
txScript.unitSteps       // BigInteger: CPU steps consumed
txScript.purpose         // RedeemerTag: Script execution purpose
txScript.redeemerIndex   // Integer: Redeemer index
txScript.redeemerData    // String: Redeemer data
txScript.redeemerDatahash // String: Redeemer data hash
```

### Staking Classes

#### `PoolRegistration`
**Purpose**: Represents stake pool registration certificates (see [staking.pool_registration.save](#stakingpool_registrationsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`Relay`](#relay)

**Key Fields**:
```mvel
// Transaction reference
pool.txHash              // String: Transaction hash
pool.certIndex           // int: Certificate index
pool.txIndex             // int: Transaction index
pool.slot                // long: Slot number
pool.blockHash           // String: Block hash
pool.epoch               // int: Epoch number

// Pool identification
pool.poolId              // String: Pool ID (hex)
pool.vrfKeyHash          // String: VRF key hash
pool.pledge              // BigInteger: Pool pledge in lovelace
pool.cost                // BigInteger: Pool cost in lovelace
pool.margin              // double: Pool margin
pool.marginNumerator     // BigInteger: Margin numerator
pool.marginDenominator   // BigInteger: Margin denominator

// Pool metadata
pool.rewardAccount       // String: Reward account
pool.poolOwners          // Set<String>: Pool owner stake keys
pool.relays              // List<Relay>: Pool relays
pool.metadataUrl         // String: Pool metadata URL
pool.metadataHash        // String: Pool metadata hash
```

#### `PoolRetirement`
**Purpose**: Represents stake pool retirement certificates (see [staking.pool_retirement.save](#stakingpool_retirementsave))

**Mutability**: Mutable (getters and setters)

**Key Fields**:
```mvel
// Transaction reference
retirement.txHash        // String: Transaction hash
retirement.certIndex     // int: Certificate index
retirement.txIndex       // int: Transaction index
retirement.slot          // long: Slot number
retirement.blockHash     // String: Block hash
retirement.epoch         // int: Epoch number

// Retirement details
retirement.poolId        // String: Pool ID being retired
retirement.retirementEpoch // int: Epoch when pool retires
```

#### `Pool`
**Purpose**: Represents current pool state (see [staking.pool.save](#stakingpoolsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`PoolStatusType`](#poolstatustype) (enum)

**Key Fields**:
```mvel
// Transaction reference
pool.txHash              // String: Transaction hash
pool.certIndex           // Integer: Certificate index
pool.txIndex             // Integer: Transaction index
pool.slot                // Long: Slot number
pool.blockHash           // String: Block hash
pool.epoch               // Integer: Epoch number

// Pool state
pool.poolId              // String: Pool ID
pool.status              // PoolStatusType: Pool status
pool.amount              // BigInteger: Pool amount
pool.activeEpoch         // Integer: Active epoch
pool.retireEpoch         // Integer: Retirement epoch
pool.registrationSlot    // Long: Registration slot
```

#### `StakeRegistrationDetail`
**Purpose**: Represents stake key registration/deregistration (see [staking.key_registration.save](#stakingkey_registrationsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`CredentialType`](#credentialtype) (enum), [`CertificateType`](#certificatetype) (enum)

**Key Fields**:
```mvel
// Transaction reference
reg.txHash               // String: Transaction hash
reg.certIndex            // int: Certificate index
reg.txIndex              // int: Transaction index
reg.slot                 // long: Slot number
reg.blockHash            // String: Block hash
reg.epoch                // int: Epoch number

// Registration details
reg.credential           // String: Stake credential
reg.credentialType       // CredentialType: Credential type
reg.address              // String: Stake address
reg.type                 // CertificateType: Certificate type
```

#### `Delegation`
**Purpose**: Represents stake delegation operations (see [staking.key_delegation.save](#stakingkey_delegationsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`CredentialType`](#credentialtype) (enum)

**Key Fields**:
```mvel
// Transaction reference
delegation.txHash        // String: Transaction hash
delegation.certIndex     // int: Certificate index
delegation.txIndex       // int: Transaction index
delegation.slot          // long: Slot number
delegation.blockHash     // String: Block hash
delegation.epoch         // int: Epoch number

// Delegation details
delegation.credential    // String: Delegating credential
delegation.credentialType // CredentialType: Credential type
delegation.address       // String: Delegating stake address
delegation.poolId        // String: Target pool ID
```

#### `Relay`
**Purpose**: Represents stake pool relay information (used in `PoolRegistration.relays`)

**Mutability**: Mutable (getters and setters)

**Key Fields**:
```mvel
// Network configuration
relay.port               // Integer: Port number
relay.ipv4               // String: IPv4 address
relay.ipv6               // String: IPv6 address
relay.dnsName            // String: DNS name
```

**Usage Example**:
```mvel
def analyzePoolRelays(items) {
    for (pool : items) {
        if (pool.relays != null) {
            System.out.println("Pool " + pool.poolId + " has " + pool.relays.size() + " relays:");
            for (relay : pool.relays) {
                if (relay.dnsName != null) {
                    System.out.println("  DNS: " + relay.dnsName + ":" + relay.port);
                } else if (relay.ipv4 != null) {
                    System.out.println("  IPv4: " + relay.ipv4 + ":" + relay.port);
                } else if (relay.ipv6 != null) {
                    System.out.println("  IPv6: " + relay.ipv6 + ":" + relay.port);
                }
            }
        }
    }
    return items;
}
```

### Governance Classes (Conway Era)

#### `GovActionProposal`
**Purpose**: Represents governance action proposals (see [governance.gov_action_proposal.save](#governancegov_action_proposalsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`GovActionType`](#govactiontype) (enum)

**Key Fields**:
```mvel
// Transaction reference
proposal.txHash          // String: Transaction hash
proposal.index           // long: Proposal index
proposal.txIndex         // int: Transaction index
proposal.slot            // Long: Slot number
proposal.epoch           // Integer: Epoch number

// Proposal details
proposal.deposit         // BigInteger: Proposal deposit
proposal.returnAddress   // String: Return address
proposal.type            // GovActionType: Action type
proposal.details         // JsonNode: Proposal details
proposal.anchorUrl       // String: Anchor URL
proposal.anchorHash      // String: Anchor hash
```

#### `VotingProcedure`
**Purpose**: Represents votes on governance proposals (see [governance.voting_procedure.save](#governancevoting_proceduresave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`VoterType`](#votertype) (enum), [`Vote`](#vote) (enum)

**Key Fields**:
```mvel
// Transaction reference
vote.txHash              // String: Transaction hash
vote.index               // long: Vote index
vote.txIndex             // int: Transaction index
vote.slot                // Long: Slot number
vote.epoch               // Integer: Epoch number

// Vote details
vote.voterType           // VoterType: Voter type
vote.voterHash           // String: Voter hash
vote.govActionTxHash     // String: Governance action transaction hash
vote.govActionIndex      // Integer: Governance action index
vote.vote                // Vote: Vote value
vote.anchorUrl           // String: Anchor URL
vote.anchorHash          // String: Anchor hash
```

#### `DRepRegistration`
**Purpose**: Represents DRep registration certificates (see [governance.drep_registration.save](#governancedrep_registrationsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`CertificateType`](#certificatetype) (enum), [`StakeCredType`](#stakecredtype) (enum)

**Key Fields**:
```mvel
// Transaction reference
drep.txHash              // String: Transaction hash
drep.certIndex           // long: Certificate index
drep.txIndex             // int: Transaction index
drep.slot                // Long: Slot number
drep.epoch               // Integer: Epoch number

// DRep registration
drep.type                // CertificateType: Certificate type
drep.deposit             // BigInteger: Registration deposit
drep.drepHash            // String: DRep hash
drep.drepId              // String: DRep ID
drep.anchorUrl           // String: Anchor URL
drep.anchorHash          // String: Anchor hash
drep.credType            // StakeCredType: Credential type
```

#### `DRep`
**Purpose**: Represents current DRep state (see [governance.drep.save](#governancedrepsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`CertificateType`](#certificatetype) (enum), [`DRepStatus`](#drepstatus) (enum)

**Key Fields**:
```mvel
// Transaction reference
drep.txHash              // String: Transaction hash
drep.certIndex           // Integer: Certificate index
drep.txIndex             // Integer: Transaction index
drep.slot                // Long: Slot number
drep.blockHash           // String: Block hash
drep.epoch               // Integer: Epoch number

// DRep state
drep.drepId              // String: DRep ID
drep.drepHash            // String: DRep hash
drep.certType            // CertificateType: Certificate type
drep.status              // DRepStatus: DRep status
drep.deposit             // BigInteger: Deposit amount
drep.registrationSlot    // Long: Registration slot
```

#### `DelegationVote`
**Purpose**: Represents vote delegations to DReps (see [governance.delegation_vote.save](#governancedelegation_votesave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`DrepType`](#dreptype) (enum), [`StakeCredType`](#stakecredtype) (enum)

**Key Fields**:
```mvel
// Transaction reference
delegation.txHash        // String: Transaction hash
delegation.certIndex     // long: Certificate index
delegation.txIndex       // int: Transaction index
delegation.slot          // Long: Slot number
delegation.epoch         // Integer: Epoch number

// Vote delegation
delegation.address       // String: Delegating stake address
delegation.drepHash      // String: Target DRep hash
delegation.drepId        // String: Target DRep ID
delegation.drepType      // DrepType: DRep type
delegation.credential    // String: Delegating credential
delegation.credType      // StakeCredType: Credential type
```

#### `CommitteeRegistration`
**Purpose**: Represents constitutional committee registrations (see [governance.committee_registration.save](#governancecommittee_registrationsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`StakeCredType`](#stakecredtype) (enum)

**Key Fields**:
```mvel
// Transaction reference
committee.txHash         // String: Transaction hash
committee.certIndex      // long: Certificate index
committee.txIndex        // int: Transaction index
committee.slot           // Long: Slot number
committee.epoch          // Integer: Epoch number

// Committee registration
committee.coldKey        // String: Cold key hash
committee.hotKey         // String: Hot key hash
committee.credType       // StakeCredType: Credential type
```

#### `CommitteeMember`
**Purpose**: Represents committee member state (see [governance.committee_member.save](#governancecommittee_membersave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`CredentialType`](#credentialtype) (enum)

**Key Fields**:
```mvel
// Member identification
member.hash              // String: Member hash
member.slot              // Long: Slot number
member.credType          // CredentialType: Credential type
member.epoch             // Integer: Epoch number

// Member state
member.startEpoch        // Integer: Start epoch
member.expiredEpoch      // Integer: Expiration epoch
```

#### `CommitteeDeRegistration`
**Purpose**: Represents committee member deregistrations (see [governance.committee_deregistration.save](#governancecommittee_deregistrationsave))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`StakeCredType`](#stakecredtype) (enum)

**Key Fields**:
```mvel
// Transaction reference
dereg.txHash             // String: Transaction hash
dereg.certIndex          // long: Certificate index
dereg.txIndex            // int: Transaction index
dereg.slot               // Long: Slot number
dereg.epoch              // Integer: Epoch number

// Deregistration
dereg.anchorUrl          // String: Anchor URL
dereg.anchorHash         // String: Anchor hash
dereg.coldKey            // String: Cold key being deregistered
dereg.credType           // StakeCredType: Credential type
```

### Event-Specific Domain Classes

These domain classes are used specifically in event contexts and are not part of the main storage domain classes.

#### `TxInputOutput`
**Purpose**: Represents UTXO changes in transactions (used in [`AddressUtxoEvent`](#addressutxoevent))

**Mutability**: Immutable (getters only)
**Nested Classes**: [`TxInput`](#txinput), [`AddressUtxo`](#addressutxo)

**Key Fields**:
```mvel
// Transaction reference
txInputOutput.txHash     // String: Transaction hash
txInputOutput.inputs     // List<TxInput>: Transaction inputs
txInputOutput.outputs    // List<AddressUtxo>: Transaction outputs
```

#### `TxCertificates`
**Purpose**: Represents certificates in transactions (used in [`CertificateEvent`](#certificateevent))

**Mutability**: Immutable (getters only)

**Key Fields**:
```mvel
// Transaction reference
txCerts.txHash           // String: Transaction hash
txCerts.txIndex          // int: Transaction index
txCerts.certificates     // List<Certificate>: Certificate data (yaci-core)
```

#### `TxMintBurn`
**Purpose**: Represents asset mint/burn operations (used in [`MintBurnEvent`](#mintburnevent))

**Mutability**: Immutable (getters only)

**Key Fields**:
```mvel
// Transaction reference
txMintBurn.txHash        // String: Transaction hash
txMintBurn.amounts       // List<Amount>: Asset amounts (see [`Amount`](#amount))
```

#### `TxGovernance`
**Purpose**: Represents governance data in transactions (used in [`GovernanceEvent`](#governanceevent))

**Mutability**: Immutable (getters only)

**Key Fields**:
```mvel
// Transaction reference
txGov.txHash             // String: Transaction hash
txGov.txIndex            // int: Transaction index
txGov.votingProcedures   // VotingProcedures: Voting data (see [`VotingProcedures`](#votingprocedures-1))
txGov.proposalProcedures // List<ProposalProcedure>: Proposal data (see [`ProposalProcedure`](#proposalprocedure))
```

#### `TxAuxData`
**Purpose**: Represents auxiliary/metadata in transactions (used in [`AuxDataEvent`](#auxdataevent))

**Mutability**: Immutable (getters only)

**Key Fields**:
```mvel
// Transaction reference
txAux.txHash             // String: Transaction hash
txAux.auxData            // AuxData: Auxiliary data (yaci-core)
```

#### `TxUpdate`
**Purpose**: Represents protocol updates in transactions (used in [`UpdateEvent`](#updateevent))

**Mutability**: Immutable (getters only)

**Key Fields**:
```mvel
// Transaction reference
txUpdate.txHash          // String: Transaction hash
txUpdate.update          // Update: Protocol update data (yaci-core)
```

#### `TxScripts`
**Purpose**: Represents script data in transactions (used in [`ScriptEvent`](#scriptevent))

**Mutability**: Immutable (getters only)

**Key Fields**:
```mvel
// Transaction reference
txScripts.txHash         // String: Transaction hash
txScripts.plutusV1Scripts // List<PlutusScript>: Plutus V1 scripts (yaci-core)
txScripts.plutusV2Scripts // List<PlutusScript>: Plutus V2 scripts (yaci-core)
txScripts.plutusV3Scripts // List<PlutusScript>: Plutus V3 scripts (yaci-core)
txScripts.nativeScripts  // List<NativeScript>: Native scripts (yaci-core)
txScripts.datums         // List<Datum>: Script datums (yaci-core)
txScripts.redeemers      // List<Redeemer>: Script redeemers (yaci-core)
```

#### `OutputDatumContext`
**Purpose**: Represents output datum context (used in [`DatumEvent`](#datumevent))

**Mutability**: Immutable (getters only)
**Nested Classes**: [`Datum`](#datum)

**Key Fields**:
```mvel
// Output context
outputDatum.txHash       // String: Transaction hash
outputDatum.outputIndex  // Integer: Output index
outputDatum.outputAddress // String: Output address
outputDatum.datum        // Datum: Datum data
```

#### `WitnessDatumContext`
**Purpose**: Represents witness datum context (used in [`DatumEvent`](#datumevent))

**Mutability**: Immutable (getters only)
**Nested Classes**: [`Datum`](#datum)

**Key Fields**:
```mvel
// Witness context
witnessDatum.txHash      // String: Transaction hash
witnessDatum.datum       // Datum: Datum data
```

#### `Transaction`
**Purpose**: Represents complete transaction data from yaci-helper (used in [`TransactionEvent`](#transactionevent))

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`TransactionBody`](#transactionbody), [`Utxo`](#utxo), [`Witnesses`](#witnesses), [`AuxData`](#auxdata)

**Key Fields**:
```mvel
// Transaction context
tx.blockNumber           // long: Block number
tx.slot                  // long: Slot number
tx.txHash                // String: Transaction hash
tx.invalid               // boolean: Whether transaction is invalid

// Transaction data
tx.body                  // TransactionBody: Transaction body
tx.utxos                 // List<Utxo>: Transaction UTXOs
tx.collateralReturnUtxo  // Utxo: Collateral return UTXO
tx.witnesses             // Witnesses: Transaction witnesses
tx.auxData               // AuxData: Auxiliary data/metadata
```

**Usage Example**:
```mvel
def analyzeTransactions(items) {
    for (tx : items) {
        System.out.println("Transaction: " + tx.txHash);
        System.out.println("Block: " + tx.blockNumber + ", Slot: " + tx.slot);
        System.out.println("Fee: " + (tx.body.fee / 1000000) + " ADA");
        System.out.println("Inputs: " + tx.body.inputs.size());
        System.out.println("Outputs: " + tx.body.outputs.size());

        // Check for smart contract interaction
        if (tx.witnesses.plutusV1Scripts.size() > 0 || tx.witnesses.plutusV2Scripts.size() > 0) {
            System.out.println("Smart contract transaction detected");
        }

        // Check for metadata
        if (tx.auxData != null && tx.auxData.metadataJson != null) {
            System.out.println("Transaction has metadata");
        }
    }
    return items;
}
```

#### `TransactionBody`
**Purpose**: Represents transaction body data (yaci-core class)

**Mutability**: Immutable (builder pattern)
**Nested Classes**: [`TransactionInput`](#transactioninput), [`TransactionOutput`](#transactionoutput), [`Amount`](#amount)

**Key Fields**:
```mvel
// Basic transaction data
body.txHash              // String: Transaction hash
body.fee                 // BigInteger: Transaction fee
body.ttl                 // long: Time to live
body.validityIntervalStart // long: Validity interval start

// Transaction structure
body.inputs              // Set<TransactionInput>: Transaction inputs
body.outputs             // List<TransactionOutput>: Transaction outputs
body.collateralInputs    // Set<TransactionInput>: Collateral inputs
body.referenceInputs     // Set<TransactionInput>: Reference inputs
body.collateralReturn    // TransactionOutput: Collateral return
body.totalCollateral     // BigInteger: Total collateral

// Advanced features
body.certificates        // List<Certificate>: Certificates
body.withdrawals         // Map<String, BigInteger>: Stake withdrawals
body.mint                // List<Amount>: Minted assets (see [`Amount`](#amount))
body.requiredSigners     // Set<String>: Required signers

// Metadata and scripts
body.auxiliaryDataHash   // String: Metadata hash
body.scriptDataHash      // String: Script data hash

// Governance (Conway era)
body.votingProcedures    // VotingProcedures: Governance votes (see [`VotingProcedures`](#votingprocedures-1))
body.proposalProcedures  // List<ProposalProcedure>: Governance proposals (see [`ProposalProcedure`](#proposalprocedure))
```

#### `Utxo`
**Purpose**: Represents UTXO data from yaci-helper

**Mutability**: Mutable (getters and setters)
**Nested Classes**: [`Amount`](#amount)

**Key Fields**:
```mvel
// UTXO identification
utxo.txHash              // String: Transaction hash
utxo.index               // int: Output index
utxo.address             // String: Address

// Value and assets
utxo.amounts             // List<Amount>: Asset amounts (see [`Amount`](#amount))

// Smart contract data
utxo.datumHash           // String: Datum hash
utxo.inlineDatum         // String: Inline datum
utxo.scriptRef           // String: Script reference
```

#### `Witnesses`
**Purpose**: Represents transaction witnesses (yaci-core class)

**Mutability**: Immutable (builder pattern)

**Key Fields**:
```mvel
// Signature witnesses
witnesses.vkeyWitnesses  // List<VkeyWitness>: Verification key witnesses
witnesses.bootstrapWitnesses // List<BootstrapWitness>: Bootstrap witnesses

// Script witnesses
witnesses.nativeScripts  // List<NativeScript>: Native scripts
witnesses.plutusV1Scripts // List<PlutusScript>: Plutus V1 scripts
witnesses.plutusV2Scripts // List<PlutusScript>: Plutus V2 scripts
witnesses.plutusV3Scripts // List<PlutusScript>: Plutus V3 scripts

// Script execution data
witnesses.datums         // List<Datum>: Script datums
witnesses.redeemers      // List<Redeemer>: Script redeemers
```

#### `AuxData`
**Purpose**: Represents auxiliary data/metadata (yaci-core class)

**Mutability**: Immutable

**Key Fields**:
```mvel
// Metadata
auxData.metadataCbor     // String: Metadata in CBOR format
auxData.metadataJson     // String: Metadata in JSON format

// Scripts
auxData.nativeScripts    // List<NativeScript>: Native scripts
auxData.plutusV1Scripts  // List<PlutusScript>: Plutus V1 scripts
auxData.plutusV2Scripts  // List<PlutusScript>: Plutus V2 scripts
auxData.plutusV3Scripts  // List<PlutusScript>: Plutus V3 scripts
```

#### `TransactionInput`
**Purpose**: Represents transaction input reference (yaci-core class)

**Key Fields**:
```mvel
input.transactionId      // String: Referenced transaction ID
input.index              // int: Referenced output index
```

#### `TransactionOutput`
**Purpose**: Represents transaction output (yaci-core class)

**Nested Classes**: [`Amount`](#amount)

**Key Fields**:
```mvel
output.address           // String: Output address
output.amounts           // List<Amount>: Output amounts (see [`Amount`](#amount))
output.datumHash         // String: Datum hash
output.inlineDatum       // String: Inline datum
output.scriptRef         // String: Script reference
```

#### `Amount`
**Purpose**: Represents asset amounts in yaci-core (different from yaci-store Amt)

**Key Fields**:
```mvel
amount.unit              // String: Asset unit
amount.policyId          // String: Policy ID
amount.assetName         // String: Asset name
amount.assetNameBytes    // byte[]: Asset name bytes
amount.quantity          // BigInteger: Asset quantity
```

#### `VotingProcedures`
**Purpose**: Represents governance voting procedures (yaci-core governance class)

**Mutability**: Mutable
**Nested Classes**: [`Voter`](#voter), [`GovActionId`](#govactionid), [`VotingProcedure`](#votingprocedure-1)

**Key Fields**:
```mvel
// Voting structure
votingProcs.voting       // Map<Voter, Map<GovActionId, VotingProcedure>>: Nested voting map
```

**Usage Example**:
```mvel
def analyzeVotingProcedures(items) {
    for (txGov : items) {
        if (txGov.votingProcedures != null && txGov.votingProcedures.voting != null) {
            voterMap = txGov.votingProcedures.voting;
            System.out.println("Voters in transaction: " + voterMap.size());

            for (voter : voterMap.keySet()) {
                govActions = voterMap.get(voter);
                System.out.println("Voter " + voter.hash + " voted on " + govActions.size() + " actions");

                for (actionId : govActions.keySet()) {
                    vote = govActions.get(actionId);
                    System.out.println("  Vote: " + vote.vote + " on action " + actionId.transactionId);
                }
            }
        }
    }
    return items;
}
```

#### `ProposalProcedure`
**Purpose**: Represents governance proposal procedures (yaci-core governance class)

**Mutability**: Mutable
**Nested Classes**: [`GovAction`](#govaction), [`Anchor`](#anchor)

**Key Fields**:
```mvel
// Proposal details
proposal.deposit         // BigInteger: Proposal deposit amount
proposal.rewardAccount   // String: Reward account
proposal.govAction       // GovAction: Governance action
proposal.anchor          // Anchor: Metadata anchor
```

**Usage Example**:
```mvel
def analyzeProposals(items) {
    for (txGov : items) {
        if (txGov.proposalProcedures != null) {
            for (proposal : txGov.proposalProcedures) {
                depositAda = proposal.deposit / 1000000;
                System.out.println("Proposal deposit: " + depositAda + " ADA");
                System.out.println("Action type: " + proposal.govAction.type);
                System.out.println("Reward account: " + proposal.rewardAccount);

                if (proposal.anchor != null) {
                    System.out.println("Metadata URL: " + proposal.anchor.anchorUrl);
                }
            }
        }
    }
    return items;
}
```

#### `Voter`
**Purpose**: Represents a governance voter (yaci-core governance class)

**Key Fields**:
```mvel
voter.type               // VoterType: Voter type (DREP, SPO, Committee)
voter.hash               // String: Voter key/script hash
```

#### `GovActionId`
**Purpose**: Represents governance action identifier (yaci-core governance class)

**Key Fields**:
```mvel
actionId.transactionId   // String: Transaction ID
actionId.govActionIndex  // Integer: Action index within transaction
```

#### `VotingProcedure`
**Purpose**: Represents individual voting procedure (yaci-core governance class)

**Nested Classes**: [`Vote`](#vote), [`Anchor`](#anchor)

**Key Fields**:
```mvel
votingProc.vote          // Vote: Vote value (YES, NO, ABSTAIN)
votingProc.anchor        // Anchor: Vote metadata anchor
```

#### `GovAction`
**Purpose**: Interface for governance actions (yaci-core governance class)

**Key Fields**:
```mvel
govAction.type           // GovActionType: Action type (PARAMETER_CHANGE, HARD_FORK, etc.)
```

#### `Anchor`
**Purpose**: Represents metadata anchor (yaci-core governance class)

**Key Fields**:
```mvel
anchor.anchorUrl         // String: Metadata URL
anchor.anchorDataHash    // String: Metadata hash
```

---

## Nested/Dependent Classes

These classes are used as field types within the main domain classes. Understanding these is crucial for accessing nested data in plugins.

### Core Nested Classes

#### `Amt`
**Purpose**: Represents native asset amounts (used in `AddressUtxo.amounts`, `TxOuput.amounts`)

**Key Fields**:
```mvel
// Asset identification
amount.unit              // String: Asset unit (policy + asset name)
amount.policyId          // String: Policy ID
amount.assetName         // String: Asset name
amount.quantity          // BigInteger: Asset quantity
```

**Usage Example**:
**MVEL Example:**
```mvel
def analyzeAssets(items) {
    for (utxo : items) {
        if (utxo.amounts != null) {
            for (amount : utxo.amounts) {
                System.out.println("Asset: " + amount.policyId + "." + amount.assetName);
                System.out.println("Quantity: " + amount.quantity);

                // Check if it's an NFT
                if (amount.quantity == 1) {
                    System.out.println("NFT detected: " + amount.unit);
                }
            }
        }
    }
    return items;
}
```

#### `Vrf`
**Purpose**: Represents VRF (Verifiable Random Function) data (used in `Block.nonceVrf`, `Block.leaderVrf`, `Block.vrfResult`)

**Key Fields**:
```mvel
// VRF data
vrf.output               // String: VRF output
vrf.proof                // String: VRF proof
```

#### `UtxoKey`
**Purpose**: Represents UTXO reference (used in `Txn.inputs`, `Txn.outputs`, etc.)

**Key Fields**:
```mvel
// UTXO reference
utxoKey.txHash           // String: Transaction hash
utxoKey.outputIndex      // Integer: Output index
```

#### `TxOuput`
**Purpose**: Represents transaction output data (used in `Txn.collateralReturnJson`)

**Nested Classes**: [`Amt`](#amt)

**Key Fields**:
```mvel
// Output details
output.address           // String: Output address
output.amounts           // List<Amt>: Asset amounts
output.dataHash          // String: Datum hash
output.inlineDatum       // String: Inline datum
output.referenceScriptHash // String: Reference script hash
```

#### `Amount`
**Purpose**: Alternative asset amount representation (used in some contexts)

**Key Fields**:
```mvel
// Simple amount
amount.unit              // String: Asset unit
amount.quantity          // BigInteger: Quantity
```

#### `RewardAmt`
**Purpose**: Represents reward amounts (used in reward-related events)

**Nested Classes**: [`RewardType`](#rewardtype) (enum)

**Key Fields**:
```mvel
// Reward details
reward.rewardType        // RewardType: Type of reward
reward.poolId            // String: Pool ID
reward.address           // String: Reward address
reward.amount            // BigInteger: Reward amount
```

#### `BlockAwareDomain`
**Purpose**: Base class providing block context (extended by many domain classes)

**Key Fields**:
```mvel
// Block context
entity.blockNumber       // Long: Block number
entity.blockTime         // Long: Block timestamp
```

### Enum Classes

These enum values are used throughout the domain classes to represent specific states or types.

**Enum values are accessed using name() method in plugin script.**

**Example:**
```mvel
if (asset.mintType.name() == "MINT") {
    // Handle mint operation
}
```

#### `MintType`
**Purpose**: Represents asset minting operation type (used in `TxAsset.mintType`)

**Values**:
- `"MINT"` - Asset minting operation
- `"BURN"` - Asset burning operation

```mvel
def filterMintOperations(items) {
    mints = [];
    burns = [];

    for (asset : items) {
        if (asset.mintType.name() == "MINT") {
            mints.add(asset);
        } else if (asset.mintType.name() == "BURN") {
            burns.add(asset);
        }
    }

    System.out.println("Mints: " + mints.size() + ", Burns: " + burns.size());
    return items;
}
```

#### `ScriptType`
**Purpose**: Represents script types (used in `Script.type`, `TxScript.type`)

**Values**:
- `"NATIVE_SCRIPT"` - Native script
- `"PLUTUS_V1"` - Plutus V1 script
- `"PLUTUS_V2"` - Plutus V2 script
- `"PLUTUS_V3"` - Plutus V3 script

#### `RewardType`
**Purpose**: Represents reward types (used in `RewardAmt.rewardType`)

**Values**:
- `"member"` - Pool member reward
- `"leader"` - Pool leader reward
- `"refund"` - Deposit refund

#### `RedeemerTag`
**Purpose**: Represents script execution purpose (used in `TxScript.purpose`, `Redeemer.tag`)

**Common Values**:
- `"Spend"` - Spending script
- `"Mint"` - Minting script
- `"Cert"` - Certificate script
- `"Reward"` - Reward script
- `"Voting"` - Voting script
- `"Proposing"` - Proposing script

#### `Vote`
**Purpose**: Represents governance vote values (used in `VotingProcedure.vote`)

**Values**:
- `"YES"` - Yes vote
- `"NO"` - No vote
- `"ABSTAIN"` - Abstain vote

#### `VoterType`
**Purpose**: Represents governance voter types (used in `VotingProcedure.voterType`)

**Values**:
- `"CONSTITUTIONAL_COMMITTEE_HOT_KEY_HASH"` - Constitutional Committee Hot Key Hash
- `"CONSTITUTIONAL_COMMITTEE_HOT_SCRIPT_HASH"` - Constitutional Committee Hot Script Hash
- `"DREP_KEY_HASH"` - DRep Key Hash
- `"DREP_SCRIPT_HASH"` - DRep Script Hash
- `"STAKING_POOL_KEY_HASH"` - Staking Pool Key Hash

#### `PoolStatusType`
**Purpose**: Represents pool status types (used in `Pool.status`)

**Values**:
- `"REGISTRATION"` - Pool registration
- `"UPDATE"` - Pool update
- `"RETIRING"` - Pool retiring
- `"RETIRED"` - Pool retired

#### `CertificateType`
**Purpose**: Represents certificate types (used in `StakeRegistrationDetail.type`, `DRepRegistration.type`, `DRep.certType`)

**Values**:
- `"STAKE_REGISTRATION"` - Stake key registration
- `"STAKE_DEREGISTRATION"` - Stake key deregistration
- `"STAKE_DELEGATION"` - Stake delegation
- `"POOL_REGISTRATION"` - Pool registration
- `"POOL_RETIREMENT"` - Pool retirement
- `"GENESIS_KEY_DELEGATION"` - Genesis key delegation
- `"MOVE_INSTATENEOUS_REWARDS_CERT"` - Move instantaneous rewards certificate
- `"REG_CERT"` - Registration certificate
- `"UNREG_CERT"` - Unregistration certificate
- `"VOTE_DELEG_CERT"` - Vote delegation certificate
- `"STAKE_VOTE_DELEG_CERT"` - Stake vote delegation certificate
- `"STAKE_REG_DELEG_CERT"` - Stake registration delegation certificate
- `"VOTE_REG_DELEG_CERT"` - Vote registration delegation certificate
- `"STAKE_VOTE_REG_DELEG_CERT"` - Stake vote registration delegation certificate
- `"AUTH_COMMITTEE_HOT_CERT"` - Authorize committee hot certificate
- `"RESIGN_COMMITTEE_COLD_CERT"` - Resign committee cold certificate
- `"REG_DREP_CERT"` - Register DRep certificate
- `"UNREG_DREP_CERT"` - Unregister DRep certificate
- `"UPDATE_DREP_CERT"` - Update DRep certificate

#### `DrepType`
**Purpose**: Represents DRep types (used in `DelegationVote.drepType`)

**Values**:
- `"ADDR_KEYHASH"` - Address key hash
- `"SCRIPTHASH"` - Script hash
- `"ABSTAIN"` - Abstain
- `"NO_CONFIDENCE"` - No confidence

#### `StakeCredType`
**Purpose**: Represents stake credential types (used in `DRepRegistration.credType`, `DelegationVote.credType`, `CommitteeRegistration.credType`, `CommitteeDeRegistration.credType`)

**Values**:
- `"ADDR_KEYHASH"` - Address key hash
- `"SCRIPTHASH"` - Script hash

#### `CredentialType`
**Purpose**: Represents credential types (used in `StakeRegistrationDetail.credentialType`, `Delegation.credentialType`, `CommitteeMember.credType`)

**Values**:
- `"ADDR_KEYHASH"` - Address key hash
- `"SCRIPTHASH"` - Script hash

#### `GovActionType`
**Purpose**: Represents governance action types (used in `GovActionProposal.type`)

**Values**:
- `"PARAMETER_CHANGE_ACTION"` - Parameter change action
- `"HARD_FORK_INITIATION_ACTION"` - Hard fork initiation action
- `"TREASURY_WITHDRAWALS_ACTION"` - Treasury withdrawals action
- `"NO_CONFIDENCE"` - No confidence action
- `"UPDATE_COMMITTEE"` - Update committee action
- `"NEW_CONSTITUTION"` - New constitution action
- `"INFO_ACTION"` - Info action

#### `DRepStatus`
**Purpose**: Represents DRep status (used in `DRep.status`)

**Values**:
- `"REGISTERED"` - DRep registered
- `"UPDATED"` - DRep updated
- `"RETIRED"` - DRep retired

### External Dependencies

Some classes are imported from the yaci-core library and represent standard Cardano data structures:

- `Relay` - Pool relay information
- `Certificate` - Cardano certificates
- `ExUnits` - Execution units for scripts
- `UnitInterval` - Values between 0 and 1
- `NonNegativeInterval` - Non-negative numeric intervals

These external classes follow similar patterns and can be accessed using standard field notation in plugins.

### Yaci-Core Classes

These classes are from the yaci-core library and are used in various events:

#### `Block` (yaci-core)
**Purpose**: Represents a complete Cardano block structure from yaci-core (used in [`BlockEvent`](#blockevent))

**Package**: `com.bloxbean.cardano.yaci.core.model.Block`

**Key Fields**:
```mvel
// Block era
block.era                // Era: Cardano era (Byron, Shelley, Allegra, Mary, Alonzo, Babbage, Conway)

// Block header
block.header             // BlockHeader: Block header information
block.header.headerBody  // HeaderBody: Header body with block metadata
block.header.bodySignature // String: Body signature

// Transaction data
block.transactionBodies  // List<TransactionBody>: Transaction bodies
block.transactionWitness // List<Witnesses>: Transaction witnesses
block.auxiliaryDataMap   // Map<Integer, AuxData>: Auxiliary data by index
block.invalidTransactions // List<Integer>: Invalid transaction indices

// Raw data
block.cbor               // String: CBOR representation of the block
```

#### `BlockHeader` (yaci-core)
**Purpose**: Contains block header information

**Key Fields**:
```mvel
header.headerBody        // HeaderBody: Header body data
header.bodySignature     // String: Body signature
```

#### `HeaderBody` (yaci-core)
**Purpose**: Contains detailed block header metadata

**Key Fields**:
```mvel
// Block identification
headerBody.blockNumber   // long: Block number
headerBody.slot          // long: Slot number
headerBody.prevHash      // String: Previous block hash
headerBody.blockHash     // String: Current block hash (derived)

// Block producer
headerBody.issuerVkey    // String: Issuer verification key
headerBody.vrfVkey       // String: VRF verification key

// VRF certificates
headerBody.nonceVrf      // VrfCert: Nonce VRF (removed in Babbage)
headerBody.leaderVrf     // VrfCert: Leader VRF (removed in Babbage)
headerBody.vrfResult     // VrfCert: VRF result (Babbage onwards)

// Block structure
headerBody.blockBodySize // long: Body size in bytes
headerBody.blockBodyHash // String: Body hash

// Operational data
headerBody.operationalCert // OperationalCert: Operational certificate
headerBody.protocolVersion // ProtocolVersion: Protocol version
```

#### `VrfCert` (yaci-core)
**Purpose**: VRF certificate data

**Key Fields**:
```mvel
vrf._1                   // String: First component
vrf._2                   // String: Second component
```

#### `OperationalCert` (yaci-core)
**Purpose**: Operational certificate for block production

**Key Fields**:
```mvel
opCert.hotVKey           // String: Hot verification key
opCert.sequenceNumber    // Integer: Sequence number
opCert.kesPeriod         // Integer: KES period
opCert.sigma             // String: Signature
```

**Usage Example**:
```mvel
def analyzeBlockStructure(event) {
    block = event.block;
    headerBody = block.header.headerBody;

    // Era-specific handling
    if (block.era == "CONWAY") {
        System.out.println("Conway era block detected");
    }

    // Check VRF data based on era
    if (block.era == "BABBAGE" || block.era == "CONWAY") {
        if (headerBody.vrfResult != null) {
            System.out.println("VRF Result: " + headerBody.vrfResult._1);
        }
    } else {
        if (headerBody.nonceVrf != null) {
            System.out.println("Nonce VRF: " + headerBody.nonceVrf._1);
        }
    }

    // Operational certificate
    if (headerBody.operationalCert != null) {
        System.out.println("KES Period: " + headerBody.operationalCert.kesPeriod);
        System.out.println("Sequence: " + headerBody.operationalCert.sequenceNumber);
    }

    // Transaction analysis
    System.out.println("Transaction count: " + block.transactionBodies.size());

    // Check for transactions with metadata
    metadataCount = 0;
    for (index : block.auxiliaryDataMap.keySet()) {
        auxData = block.auxiliaryDataMap.get(index);
        if (auxData != null) {
            metadataCount++;
        }
    }
    System.out.println("Transactions with metadata: " + metadataCount);
}
```

---

This comprehensive API reference provides plugin developers with all the information needed to build sophisticated blockchain data processing plugins for the yaci-store system.
