{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 23, "column": 0}, "map": {"version":3,"sources":["turbopack:///[turbopack-node]/transforms/webpack-loaders.ts"],"sourcesContent":["declare const __turbopack_external_require__: {\n  resolve: (name: string, opt: { paths: string[] }) => string;\n} & ((id: string, thunk: () => any, esm?: boolean) => any);\n\nimport type { Ipc } from \"../ipc/evaluate\";\nimport {\n  relative,\n  isAbsolute,\n  join,\n  sep,\n  dirname,\n  resolve as pathResolve,\n} from \"path\";\nimport {\n  StackFrame,\n  parse as parseStackTrace,\n} from \"../compiled/stacktrace-parser\";\nimport { type StructuredError } from \"src/ipc\";\n\nexport type IpcInfoMessage =\n  | {\n    type: \"fileDependency\";\n    path: string;\n  }\n  | {\n    type: \"buildDependency\";\n    path: string;\n  }\n  | {\n    type: \"dirDependency\";\n    path: string;\n    glob: string;\n  }\n  | {\n    type: \"envDependency\";\n    name: string;\n  }\n  | {\n    type: \"emittedError\";\n    severity: \"warning\" | \"error\";\n    error: StructuredError;\n  }\n  | {\n    type: \"log\";\n    time: number;\n    logType: string;\n    args: any[];\n    trace?: StackFrame[];\n  };\n\nexport type IpcRequestMessage = {\n  type: \"resolve\";\n  options: any;\n  lookupPath: string;\n  request: string;\n};\n\ntype LoaderConfig =\n  | string\n  | {\n    loader: string;\n    options: { [k: string]: unknown };\n  };\n\nconst { runLoaders }: typeof import(\"loader-runner\") = require(\"@vercel/turbopack/loader-runner\");\n\nconst contextDir = process.cwd();\nconst toPath = (file: string) => {\n  const relPath = relative(contextDir, file);\n  if (isAbsolute(relPath)) {\n    throw new Error(\n      `Cannot depend on path (${file}) outside of root directory (${contextDir})`\n    );\n  }\n  return sep !== \"/\" ? relPath.replaceAll(sep, \"/\") : relPath;\n};\nconst fromPath = (path: string) => {\n  return join(contextDir, sep !== \"/\" ? path.replaceAll(\"/\", sep) : path);\n};\n\nconst LogType = Object.freeze({\n  error: \"error\",\n  warn: \"warn\",\n  info: \"info\",\n  log: \"log\",\n  debug: \"debug\",\n\n  trace: \"trace\",\n\n  group: \"group\",\n  groupCollapsed: \"groupCollapsed\",\n  groupEnd: \"groupEnd\",\n\n  profile: \"profile\",\n  profileEnd: \"profileEnd\",\n\n  time: \"time\",\n\n  clear: \"clear\",\n  status: \"status\",\n});\n\nconst loaderFlag = \"LOADER_EXECUTION\";\n\nconst cutOffByFlag = (stack: string, flag: string): string => {\n  const errorStack = stack.split(\"\\n\");\n  for (let i = 0; i < errorStack.length; i++) {\n    if (errorStack[i].includes(flag)) {\n      errorStack.length = i;\n    }\n  }\n  return errorStack.join(\"\\n\");\n};\n\n/**\n * @param stack stack trace\n * @returns stack trace without the loader execution flag included\n */\nconst cutOffLoaderExecution = (stack: string): string =>\n  cutOffByFlag(stack, loaderFlag);\n\nclass DummySpan {\n  traceChild() {\n    return new DummySpan();\n  }\n\n  traceFn<T>(fn: (span: DummySpan) => T): T {\n    return fn(this);\n  }\n\n  async traceAsyncFn<T>(fn: (span: DummySpan) => T | Promise<T>): Promise<T> {\n    return await fn(this);\n  }\n\n  stop() {\n    return;\n  }\n}\n\ntype ResolveOptions = {\n  dependencyType?: string;\n  alias?: Record<string, string[]> | unknown[];\n  aliasFields?: string[];\n  cacheWithContext?: boolean;\n  conditionNames?: string[];\n  descriptionFiles?: string[];\n  enforceExtension?: boolean;\n  extensionAlias: Record<string, string[]>;\n  extensions?: string[];\n  fallback?: Record<string, string[]>;\n  mainFields?: string[];\n  mainFiles?: string[];\n  exportsFields?: string[];\n  modules?: string[];\n  plugins?: unknown[];\n  symlinks?: boolean;\n  unsafeCache?: boolean;\n  useSyncFileSystemCalls?: boolean;\n  preferRelative?: boolean;\n  preferAbsolute?: boolean;\n  restrictions?: unknown[];\n  roots?: string[];\n  importFields?: string[];\n};\n\n// Patch process.env to track which env vars are read\nconst originalEnv = process.env;\nconst readEnvVars = new Set<string>();\nprocess.env = new Proxy(originalEnv, {\n  get(target, prop) {\n    if (typeof prop === 'string' && !readEnvVars.has(prop)) {\n      // We register the env var as dependency on the\n      // current transform and all future transforms\n      // since the env var might be cached in module scope\n      // and influence them all\n      readEnvVars.add(prop);\n    }\n    return Reflect.get(target, prop);\n  },\n})\n\nconst transform = (\n  ipc: Ipc<IpcInfoMessage, IpcRequestMessage>,\n  content: string,\n  name: string,\n  query: string,\n  loaders: LoaderConfig[],\n  sourceMap: boolean\n) => {\n  return new Promise((resolve, reject) => {\n    const resource = pathResolve(contextDir, name);\n    const resourceDir = dirname(resource);\n\n    const loadersWithOptions = loaders.map((loader) =>\n      typeof loader === \"string\" ? { loader, options: {} } : loader\n    );\n\n    runLoaders(\n      {\n        resource: resource + query,\n        context: {\n          _module: {\n            // For debugging purpose, if someone find context is not full compatible to\n            // webpack they can guess this comes from turbopack\n            __reserved: \"TurbopackContext\",\n          },\n          currentTraceSpan: new DummySpan(),\n          rootContext: contextDir,\n          sourceMap,\n          getOptions() {\n            const entry = this.loaders[this.loaderIndex];\n            return entry.options && typeof entry.options === \"object\"\n              ? entry.options\n              : {};\n          },\n          getResolve: (options: ResolveOptions) => {\n            const rustOptions = {\n              aliasFields: undefined as undefined | string[],\n              conditionNames: undefined as undefined | string[],\n              noPackageJson: false,\n              extensions: undefined as undefined | string[],\n              mainFields: undefined as undefined | string[],\n              noExportsField: false,\n              mainFiles: undefined as undefined | string[],\n              noModules: false,\n              preferRelative: false,\n            };\n            if (options.alias) {\n              if (!Array.isArray(options.alias) || options.alias.length > 0) {\n                throw new Error(\"alias resolve option is not supported\");\n              }\n            }\n            if (options.aliasFields) {\n              if (!Array.isArray(options.aliasFields)) {\n                throw new Error(\"aliasFields resolve option must be an array\");\n              }\n              rustOptions.aliasFields = options.aliasFields;\n            }\n            if (options.conditionNames) {\n              if (!Array.isArray(options.conditionNames)) {\n                throw new Error(\n                  \"conditionNames resolve option must be an array\"\n                );\n              }\n              rustOptions.conditionNames = options.conditionNames;\n            }\n            if (options.descriptionFiles) {\n              if (\n                !Array.isArray(options.descriptionFiles) ||\n                options.descriptionFiles.length > 0\n              ) {\n                throw new Error(\n                  \"descriptionFiles resolve option is not supported\"\n                );\n              }\n              rustOptions.noPackageJson = true;\n            }\n            if (options.extensions) {\n              if (!Array.isArray(options.extensions)) {\n                throw new Error(\"extensions resolve option must be an array\");\n              }\n              rustOptions.extensions = options.extensions;\n            }\n            if (options.mainFields) {\n              if (!Array.isArray(options.mainFields)) {\n                throw new Error(\"mainFields resolve option must be an array\");\n              }\n              rustOptions.mainFields = options.mainFields;\n            }\n            if (options.exportsFields) {\n              if (\n                !Array.isArray(options.exportsFields) ||\n                options.exportsFields.length > 0\n              ) {\n                throw new Error(\n                  \"exportsFields resolve option is not supported\"\n                );\n              }\n              rustOptions.noExportsField = true;\n            }\n            if (options.mainFiles) {\n              if (!Array.isArray(options.mainFiles)) {\n                throw new Error(\"mainFiles resolve option must be an array\");\n              }\n              rustOptions.mainFiles = options.mainFiles;\n            }\n            if (options.modules) {\n              if (\n                !Array.isArray(options.modules) ||\n                options.modules.length > 0\n              ) {\n                throw new Error(\"modules resolve option is not supported\");\n              }\n              rustOptions.noModules = true;\n            }\n            if (options.restrictions) {\n              // TODO This is ignored for now\n            }\n            if (options.dependencyType) {\n              // TODO This is ignored for now\n            }\n            if (options.preferRelative) {\n              if (typeof options.preferRelative !== \"boolean\") {\n                throw new Error(\n                  \"preferRelative resolve option must be a boolean\"\n                );\n              }\n              rustOptions.preferRelative = options.preferRelative;\n            }\n            return (\n              lookupPath: string,\n              request: string,\n              callback?: (err?: Error, result?: string) => void\n            ) => {\n              const promise = ipc\n                .sendRequest({\n                  type: \"resolve\",\n                  options: rustOptions,\n                  lookupPath: toPath(lookupPath),\n                  request,\n                })\n                .then((unknownResult) => {\n                  let result = unknownResult as { path: string };\n                  if (result && typeof result.path === \"string\") {\n                    return fromPath(result.path);\n                  } else {\n                    throw Error(\n                      \"Expected { path: string } from resolve request\"\n                    );\n                  }\n                });\n              if (callback) {\n                promise\n                  .then(\n                    (result) => callback(undefined, result),\n                    (err) => callback(err)\n                  )\n                  .catch((err) => {\n                    ipc.sendError(err);\n                  });\n              } else {\n                return promise;\n              }\n            };\n          },\n          emitWarning: makeErrorEmitter(\"warning\", ipc),\n          emitError: makeErrorEmitter(\"error\", ipc),\n          getLogger(name: unknown) {\n            const logFn = (logType: string, ...args: unknown[]) => {\n              let trace;\n              switch (logType) {\n                case LogType.warn:\n                case LogType.error:\n                case LogType.trace:\n                case LogType.debug:\n                  trace = parseStackTrace(\n                    cutOffLoaderExecution(new Error(\"Trace\").stack!)\n                      .split(\"\\n\")\n                      .slice(3)\n                      .join(\"\\n\")\n                  );\n                  break;\n                default:\n                  // TODO: do we need to handle this?\n                  break\n              }\n\n              ipc.sendInfo({\n                type: \"log\",\n                time: Date.now(),\n                logType,\n                args,\n                trace,\n              });\n            };\n            let timers: Map<string, [number, number]> | undefined;\n            let timersAggregates: Map<string, [number, number]> | undefined;\n\n            // See https://github.com/webpack/webpack/blob/a48c34b34d2d6c44f9b2b221d7baf278d34ac0be/lib/logging/Logger.js#L8\n            return {\n              error: logFn.bind(this, LogType.error),\n              warn: logFn.bind(this, LogType.warn),\n              info: logFn.bind(this, LogType.info),\n              log: logFn.bind(this, LogType.log),\n              debug: logFn.bind(this, LogType.debug),\n              assert: (assertion: boolean, ...args: any[]) => {\n                if (!assertion) {\n                  logFn(LogType.error, ...args);\n                }\n              },\n              trace: logFn.bind(this, LogType.trace),\n              clear: logFn.bind(this, LogType.clear),\n              status: logFn.bind(this, LogType.status),\n              group: logFn.bind(this, LogType.group),\n              groupCollapsed: logFn.bind(this, LogType.groupCollapsed),\n              groupEnd: logFn.bind(this, LogType.groupEnd),\n              profile: logFn.bind(this, LogType.profile),\n              profileEnd: logFn.bind(this, LogType.profileEnd),\n              time: (label: string) => {\n                timers = timers || new Map();\n                timers.set(label, process.hrtime());\n              },\n              timeLog: (label: string) => {\n                const prev = timers && timers.get(label);\n                if (!prev) {\n                  throw new Error(\n                    `No such label '${label}' for WebpackLogger.timeLog()`\n                  );\n                }\n                const time = process.hrtime(prev);\n                logFn(LogType.time, [label, ...time]);\n              },\n              timeEnd: (label: string) => {\n                const prev = timers && timers.get(label);\n                if (!prev) {\n                  throw new Error(\n                    `No such label '${label}' for WebpackLogger.timeEnd()`\n                  );\n                }\n                const time = process.hrtime(prev);\n                /** @type {Map<string | undefined, [number, number]>} */\n                timers!.delete(label);\n                logFn(LogType.time, [label, ...time]);\n              },\n              timeAggregate: (label: string) => {\n                const prev = timers && timers.get(label);\n                if (!prev) {\n                  throw new Error(\n                    `No such label '${label}' for WebpackLogger.timeAggregate()`\n                  );\n                }\n                const time = process.hrtime(prev);\n                /** @type {Map<string | undefined, [number, number]>} */\n                timers!.delete(label);\n                /** @type {Map<string | undefined, [number, number]>} */\n                timersAggregates = timersAggregates || new Map();\n                const current = timersAggregates.get(label);\n                if (current !== undefined) {\n                  if (time[1] + current[1] > 1e9) {\n                    time[0] += current[0] + 1;\n                    time[1] = time[1] - 1e9 + current[1];\n                  } else {\n                    time[0] += current[0];\n                    time[1] += current[1];\n                  }\n                }\n                timersAggregates.set(label, time);\n              },\n              timeAggregateEnd: (label: string) => {\n                if (timersAggregates === undefined) return;\n                const time = timersAggregates.get(label);\n                if (time === undefined) return;\n                timersAggregates.delete(label);\n                logFn(LogType.time, [label, ...time]);\n              },\n            };\n          },\n        },\n\n        loaders: loadersWithOptions.map((loader) => ({\n          loader: __turbopack_external_require__.resolve(loader.loader, {\n            paths: [resourceDir],\n          }),\n          options: loader.options,\n        })),\n        readResource: (_filename, callback) => {\n          // TODO assuming the filename === resource, but loaders might change that\n          callback(null, Buffer.from(content, \"utf-8\"));\n        },\n      },\n      (err, result) => {\n        for (const envVar of readEnvVars) {\n          ipc.sendInfo({\n            type: \"envDependency\",\n            name: envVar,\n          });\n        }\n        for (const dep of result.contextDependencies) {\n          ipc.sendInfo({\n            type: \"dirDependency\",\n            path: toPath(dep),\n            glob: \"**\",\n          });\n        }\n        for (const dep of result.fileDependencies) {\n          ipc.sendInfo({\n            type: \"fileDependency\",\n            path: toPath(dep),\n          });\n        }\n        if (err) return reject(err);\n        if (!result.result) return reject(new Error(\"No result from loaders\"));\n        const [source, map] = result.result;\n        resolve({\n          source: Buffer.isBuffer(source) ? { binary: source.toString('base64') } : source,\n          map:\n            typeof map === \"string\"\n              ? map\n              : typeof map === \"object\"\n                ? JSON.stringify(map)\n                : undefined,\n        });\n      }\n    );\n  });\n};\n\nexport { transform as default };\n\nfunction makeErrorEmitter(\n  severity: \"warning\" | \"error\",\n  ipc: Ipc<IpcInfoMessage, IpcRequestMessage>\n) {\n  return function (error: Error | string) {\n    ipc.sendInfo({\n      type: \"emittedError\",\n      severity: severity,\n      error:\n        error instanceof Error\n          ? {\n            name: error.name,\n            message: error.message,\n            stack: error.stack ? parseStackTrace(error.stack) : [],\n            cause: undefined,\n          }\n          : {\n            name: \"Error\",\n            message: error,\n            stack: [],\n            cause: undefined,\n          },\n    });\n  };\n}\n"],"names":[],"mappings":"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"}}]
}